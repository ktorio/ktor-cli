// Code generated from KotlinParser.g4 by ANTLR 4.13.2. DO NOT EDIT.

package parser // KotlinParser

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type KotlinParser struct {
	*antlr.BaseParser
}

var KotlinParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func kotlinparserParserInit() {
	staticData := &KotlinParserParserStaticData
	staticData.LiteralNames = []string{
		"", "", "", "", "", "", "'...'", "'.'", "','", "'('", "')'", "'['",
		"']'", "'{'", "'}'", "'*'", "'%'", "'/'", "'+'", "'-'", "'++'", "'--'",
		"'&&'", "'||'", "", "'!'", "':'", "';'", "'='", "'+='", "'-='", "'*='",
		"'/='", "'%='", "'->'", "'=>'", "'..'", "'..<'", "'::'", "';;'", "'#'",
		"'@'", "", "", "", "", "'?'", "'<'", "'>'", "'<='", "'>='", "'!='",
		"'!=='", "'as?'", "'=='", "'==='", "'''", "'&'", "", "", "", "", "",
		"'file'", "'field'", "'property'", "'get'", "'set'", "'receiver'", "'param'",
		"'setparam'", "'delegate'", "'package'", "'import'", "'class'", "'interface'",
		"'fun'", "'object'", "'val'", "'var'", "'typealias'", "'constructor'",
		"'by'", "'companion'", "'init'", "'this'", "'super'", "'typeof'", "'where'",
		"'if'", "'else'", "'when'", "'try'", "'catch'", "'finally'", "'for'",
		"'do'", "'while'", "'throw'", "'return'", "'continue'", "'break'", "'as'",
		"'is'", "'in'", "", "", "'out'", "'dynamic'", "'public'", "'private'",
		"'protected'", "'internal'", "'enum'", "'sealed'", "'annotation'", "'data'",
		"'inner'", "'value'", "'tailrec'", "'operator'", "'inline'", "'infix'",
		"'external'", "'suspend'", "'override'", "'abstract'", "'final'", "'open'",
		"'const'", "'lateinit'", "'vararg'", "'noinline'", "'crossinline'",
		"'reified'", "'expect'", "'actual'", "", "", "", "", "", "", "", "",
		"", "'null'", "", "", "", "", "", "'\"\"\"'",
	}
	staticData.SymbolicNames = []string{
		"", "ShebangLine", "DelimitedComment", "LineComment", "WS", "NL", "RESERVED",
		"DOT", "COMMA", "LPAREN", "RPAREN", "LSQUARE", "RSQUARE", "LCURL", "RCURL",
		"MULT", "MOD", "DIV", "ADD", "SUB", "INCR", "DECR", "CONJ", "DISJ",
		"EXCL_WS", "EXCL_NO_WS", "COLON", "SEMICOLON", "ASSIGNMENT", "ADD_ASSIGNMENT",
		"SUB_ASSIGNMENT", "MULT_ASSIGNMENT", "DIV_ASSIGNMENT", "MOD_ASSIGNMENT",
		"ARROW", "DOUBLE_ARROW", "RANGE", "RANGE_UNTIL", "COLONCOLON", "DOUBLE_SEMICOLON",
		"HASH", "AT_NO_WS", "AT_POST_WS", "AT_PRE_WS", "AT_BOTH_WS", "QUEST_WS",
		"QUEST_NO_WS", "LANGLE", "RANGLE", "LE", "GE", "EXCL_EQ", "EXCL_EQEQ",
		"AS_SAFE", "EQEQ", "EQEQEQ", "SINGLE_QUOTE", "AMP", "RETURN_AT", "CONTINUE_AT",
		"BREAK_AT", "THIS_AT", "SUPER_AT", "FILE", "FIELD", "PROPERTY", "GET",
		"SET", "RECEIVER", "PARAM", "SETPARAM", "DELEGATE", "PACKAGE", "IMPORT",
		"CLASS", "INTERFACE", "FUN", "OBJECT", "VAL", "VAR", "TYPE_ALIAS", "CONSTRUCTOR",
		"BY", "COMPANION", "INIT", "THIS", "SUPER", "TYPEOF", "WHERE", "IF",
		"ELSE", "WHEN", "TRY", "CATCH", "FINALLY", "FOR", "DO", "WHILE", "THROW",
		"RETURN", "CONTINUE", "BREAK", "AS", "IS", "IN", "NOT_IS", "NOT_IN",
		"OUT", "DYNAMIC", "PUBLIC", "PRIVATE", "PROTECTED", "INTERNAL", "ENUM",
		"SEALED", "ANNOTATION", "DATA", "INNER", "VALUE", "TAILREC", "OPERATOR",
		"INLINE", "INFIX", "EXTERNAL", "SUSPEND", "OVERRIDE", "ABSTRACT", "FINAL",
		"OPEN", "CONST", "LATEINIT", "VARARG", "NOINLINE", "CROSSINLINE", "REIFIED",
		"EXPECT", "ACTUAL", "RealLiteral", "FloatLiteral", "DoubleLiteral",
		"IntegerLiteral", "HexLiteral", "BinLiteral", "UnsignedLiteral", "LongLiteral",
		"BooleanLiteral", "NullLiteral", "CharacterLiteral", "Identifier", "IdentifierOrSoftKey",
		"FieldIdentifier", "QUOTE_OPEN", "TRIPLE_QUOTE_OPEN", "UNICODE_CLASS_LL",
		"UNICODE_CLASS_LM", "UNICODE_CLASS_LO", "UNICODE_CLASS_LT", "UNICODE_CLASS_LU",
		"UNICODE_CLASS_ND", "UNICODE_CLASS_NL", "QUOTE_CLOSE", "LineStrRef",
		"LineStrText", "LineStrEscapedChar", "LineStrExprStart", "TRIPLE_QUOTE_CLOSE",
		"MultiLineStringQuote", "MultiLineStrRef", "MultiLineStrText", "MultiLineStrExprStart",
		"Inside_Comment", "Inside_WS", "Inside_NL", "ErrorCharacter",
	}
	staticData.RuleNames = []string{
		"kotlinFile", "script", "shebangLine", "fileAnnotation", "packageHeader",
		"importList", "importHeader", "importAlias", "topLevelObject", "typeAlias",
		"declaration", "classDeclaration", "primaryConstructor", "classBody",
		"classParameters", "classParameter", "delegationSpecifiers", "delegationSpecifier",
		"constructorInvocation", "annotatedDelegationSpecifier", "explicitDelegation",
		"typeParameters", "typeParameter", "typeConstraints", "typeConstraint",
		"classMemberDeclarations", "classMemberDeclaration", "anonymousInitializer",
		"companionObject", "functionValueParameters", "functionValueParameter",
		"functionDeclaration", "functionBody", "variableDeclaration", "multiVariableDeclaration",
		"propertyDeclaration", "propertyDelegate", "getter", "setter", "parametersWithOptionalType",
		"functionValueParameterWithOptionalType", "parameterWithOptionalType",
		"parameter", "objectDeclaration", "secondaryConstructor", "constructorDelegationCall",
		"enumClassBody", "enumEntries", "enumEntry", "type", "typeReference",
		"nullableType", "quest", "userType", "simpleUserType", "typeProjection",
		"typeProjectionModifiers", "typeProjectionModifier", "functionType",
		"functionTypeParameters", "parenthesizedType", "receiverType", "parenthesizedUserType",
		"definitelyNonNullableType", "statements", "statement", "label", "controlStructureBody",
		"block", "loopStatement", "forStatement", "whileStatement", "doWhileStatement",
		"assignment", "semi", "semis", "expression", "disjunction", "conjunction",
		"equality", "comparison", "genericCallLikeComparison", "infixOperation",
		"elvisExpression", "elvis", "infixFunctionCall", "rangeExpression",
		"additiveExpression", "multiplicativeExpression", "asExpression", "prefixUnaryExpression",
		"unaryPrefix", "postfixUnaryExpression", "postfixUnarySuffix", "directlyAssignableExpression",
		"parenthesizedDirectlyAssignableExpression", "assignableExpression",
		"parenthesizedAssignableExpression", "assignableSuffix", "indexingSuffix",
		"navigationSuffix", "callSuffix", "annotatedLambda", "typeArguments",
		"valueArguments", "valueArgument", "primaryExpression", "parenthesizedExpression",
		"collectionLiteral", "literalConstant", "stringLiteral", "lineStringLiteral",
		"multiLineStringLiteral", "lineStringContent", "lineStringExpression",
		"multiLineStringContent", "multiLineStringExpression", "lambdaLiteral",
		"lambdaParameters", "lambdaParameter", "anonymousFunction", "functionLiteral",
		"objectLiteral", "thisExpression", "superExpression", "ifExpression",
		"whenSubject", "whenExpression", "whenEntry", "whenCondition", "rangeTest",
		"typeTest", "tryExpression", "catchBlock", "finallyBlock", "jumpExpression",
		"callableReference", "assignmentAndOperator", "equalityOperator", "comparisonOperator",
		"inOperator", "isOperator", "additiveOperator", "multiplicativeOperator",
		"asOperator", "prefixUnaryOperator", "postfixUnaryOperator", "excl",
		"memberAccessOperator", "safeNav", "modifiers", "parameterModifiers",
		"modifier", "typeModifiers", "typeModifier", "classModifier", "memberModifier",
		"visibilityModifier", "varianceModifier", "typeParameterModifiers",
		"typeParameterModifier", "functionModifier", "propertyModifier", "inheritanceModifier",
		"parameterModifier", "reificationModifier", "platformModifier", "annotation",
		"singleAnnotation", "multiAnnotation", "annotationUseSiteTarget", "unescapedAnnotation",
		"simpleIdentifier", "identifier",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 173, 3520, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7,
		153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2,
		158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7,
		162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2,
		167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7,
		171, 2, 172, 7, 172, 2, 173, 7, 173, 1, 0, 3, 0, 350, 8, 0, 1, 0, 5, 0,
		353, 8, 0, 10, 0, 12, 0, 356, 9, 0, 1, 0, 5, 0, 359, 8, 0, 10, 0, 12, 0,
		362, 9, 0, 1, 0, 1, 0, 1, 0, 5, 0, 367, 8, 0, 10, 0, 12, 0, 370, 9, 0,
		1, 0, 1, 0, 1, 1, 3, 1, 375, 8, 1, 1, 1, 5, 1, 378, 8, 1, 10, 1, 12, 1,
		381, 9, 1, 1, 1, 5, 1, 384, 8, 1, 10, 1, 12, 1, 387, 9, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 5, 1, 394, 8, 1, 10, 1, 12, 1, 397, 9, 1, 1, 1, 1, 1,
		1, 2, 1, 2, 4, 2, 403, 8, 2, 11, 2, 12, 2, 404, 1, 3, 1, 3, 1, 3, 5, 3,
		410, 8, 3, 10, 3, 12, 3, 413, 9, 3, 1, 3, 1, 3, 5, 3, 417, 8, 3, 10, 3,
		12, 3, 420, 9, 3, 1, 3, 1, 3, 4, 3, 424, 8, 3, 11, 3, 12, 3, 425, 1, 3,
		1, 3, 1, 3, 3, 3, 431, 8, 3, 1, 3, 5, 3, 434, 8, 3, 10, 3, 12, 3, 437,
		9, 3, 1, 4, 1, 4, 1, 4, 3, 4, 442, 8, 4, 3, 4, 444, 8, 4, 1, 5, 5, 5, 447,
		8, 5, 10, 5, 12, 5, 450, 9, 5, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 3, 6, 457,
		8, 6, 1, 6, 3, 6, 460, 8, 6, 1, 7, 1, 7, 1, 7, 1, 8, 1, 8, 3, 8, 467, 8,
		8, 1, 9, 3, 9, 470, 8, 9, 1, 9, 1, 9, 5, 9, 474, 8, 9, 10, 9, 12, 9, 477,
		9, 9, 1, 9, 1, 9, 5, 9, 481, 8, 9, 10, 9, 12, 9, 484, 9, 9, 1, 9, 3, 9,
		487, 8, 9, 1, 9, 5, 9, 490, 8, 9, 10, 9, 12, 9, 493, 9, 9, 1, 9, 1, 9,
		5, 9, 497, 8, 9, 10, 9, 12, 9, 500, 9, 9, 1, 9, 1, 9, 1, 10, 1, 10, 1,
		10, 1, 10, 1, 10, 3, 10, 509, 8, 10, 1, 11, 3, 11, 512, 8, 11, 1, 11, 1,
		11, 1, 11, 5, 11, 517, 8, 11, 10, 11, 12, 11, 520, 9, 11, 3, 11, 522, 8,
		11, 1, 11, 3, 11, 525, 8, 11, 1, 11, 5, 11, 528, 8, 11, 10, 11, 12, 11,
		531, 9, 11, 1, 11, 1, 11, 5, 11, 535, 8, 11, 10, 11, 12, 11, 538, 9, 11,
		1, 11, 3, 11, 541, 8, 11, 1, 11, 5, 11, 544, 8, 11, 10, 11, 12, 11, 547,
		9, 11, 1, 11, 3, 11, 550, 8, 11, 1, 11, 5, 11, 553, 8, 11, 10, 11, 12,
		11, 556, 9, 11, 1, 11, 1, 11, 5, 11, 560, 8, 11, 10, 11, 12, 11, 563, 9,
		11, 1, 11, 3, 11, 566, 8, 11, 1, 11, 5, 11, 569, 8, 11, 10, 11, 12, 11,
		572, 9, 11, 1, 11, 3, 11, 575, 8, 11, 1, 11, 5, 11, 578, 8, 11, 10, 11,
		12, 11, 581, 9, 11, 1, 11, 1, 11, 5, 11, 585, 8, 11, 10, 11, 12, 11, 588,
		9, 11, 1, 11, 3, 11, 591, 8, 11, 1, 12, 3, 12, 594, 8, 12, 1, 12, 1, 12,
		5, 12, 598, 8, 12, 10, 12, 12, 12, 601, 9, 12, 3, 12, 603, 8, 12, 1, 12,
		1, 12, 1, 13, 1, 13, 5, 13, 609, 8, 13, 10, 13, 12, 13, 612, 9, 13, 1,
		13, 1, 13, 5, 13, 616, 8, 13, 10, 13, 12, 13, 619, 9, 13, 1, 13, 1, 13,
		1, 14, 1, 14, 5, 14, 625, 8, 14, 10, 14, 12, 14, 628, 9, 14, 1, 14, 1,
		14, 5, 14, 632, 8, 14, 10, 14, 12, 14, 635, 9, 14, 1, 14, 1, 14, 5, 14,
		639, 8, 14, 10, 14, 12, 14, 642, 9, 14, 1, 14, 5, 14, 645, 8, 14, 10, 14,
		12, 14, 648, 9, 14, 1, 14, 5, 14, 651, 8, 14, 10, 14, 12, 14, 654, 9, 14,
		1, 14, 3, 14, 657, 8, 14, 3, 14, 659, 8, 14, 1, 14, 5, 14, 662, 8, 14,
		10, 14, 12, 14, 665, 9, 14, 1, 14, 1, 14, 1, 15, 3, 15, 670, 8, 15, 1,
		15, 3, 15, 673, 8, 15, 1, 15, 5, 15, 676, 8, 15, 10, 15, 12, 15, 679, 9,
		15, 1, 15, 1, 15, 1, 15, 5, 15, 684, 8, 15, 10, 15, 12, 15, 687, 9, 15,
		1, 15, 1, 15, 5, 15, 691, 8, 15, 10, 15, 12, 15, 694, 9, 15, 1, 15, 1,
		15, 5, 15, 698, 8, 15, 10, 15, 12, 15, 701, 9, 15, 1, 15, 3, 15, 704, 8,
		15, 1, 16, 1, 16, 5, 16, 708, 8, 16, 10, 16, 12, 16, 711, 9, 16, 1, 16,
		1, 16, 5, 16, 715, 8, 16, 10, 16, 12, 16, 718, 9, 16, 1, 16, 5, 16, 721,
		8, 16, 10, 16, 12, 16, 724, 9, 16, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1,
		17, 5, 17, 732, 8, 17, 10, 17, 12, 17, 735, 9, 17, 1, 17, 3, 17, 738, 8,
		17, 1, 18, 1, 18, 5, 18, 742, 8, 18, 10, 18, 12, 18, 745, 9, 18, 1, 18,
		1, 18, 1, 19, 5, 19, 750, 8, 19, 10, 19, 12, 19, 753, 9, 19, 1, 19, 5,
		19, 756, 8, 19, 10, 19, 12, 19, 759, 9, 19, 1, 19, 1, 19, 1, 20, 1, 20,
		3, 20, 765, 8, 20, 1, 20, 5, 20, 768, 8, 20, 10, 20, 12, 20, 771, 9, 20,
		1, 20, 1, 20, 5, 20, 775, 8, 20, 10, 20, 12, 20, 778, 9, 20, 1, 20, 1,
		20, 1, 21, 1, 21, 5, 21, 784, 8, 21, 10, 21, 12, 21, 787, 9, 21, 1, 21,
		1, 21, 5, 21, 791, 8, 21, 10, 21, 12, 21, 794, 9, 21, 1, 21, 1, 21, 5,
		21, 798, 8, 21, 10, 21, 12, 21, 801, 9, 21, 1, 21, 5, 21, 804, 8, 21, 10,
		21, 12, 21, 807, 9, 21, 1, 21, 5, 21, 810, 8, 21, 10, 21, 12, 21, 813,
		9, 21, 1, 21, 3, 21, 816, 8, 21, 1, 21, 5, 21, 819, 8, 21, 10, 21, 12,
		21, 822, 9, 21, 1, 21, 1, 21, 1, 22, 3, 22, 827, 8, 22, 1, 22, 5, 22, 830,
		8, 22, 10, 22, 12, 22, 833, 9, 22, 1, 22, 1, 22, 5, 22, 837, 8, 22, 10,
		22, 12, 22, 840, 9, 22, 1, 22, 1, 22, 5, 22, 844, 8, 22, 10, 22, 12, 22,
		847, 9, 22, 1, 22, 3, 22, 850, 8, 22, 1, 23, 1, 23, 5, 23, 854, 8, 23,
		10, 23, 12, 23, 857, 9, 23, 1, 23, 1, 23, 5, 23, 861, 8, 23, 10, 23, 12,
		23, 864, 9, 23, 1, 23, 1, 23, 5, 23, 868, 8, 23, 10, 23, 12, 23, 871, 9,
		23, 1, 23, 5, 23, 874, 8, 23, 10, 23, 12, 23, 877, 9, 23, 1, 24, 5, 24,
		880, 8, 24, 10, 24, 12, 24, 883, 9, 24, 1, 24, 1, 24, 5, 24, 887, 8, 24,
		10, 24, 12, 24, 890, 9, 24, 1, 24, 1, 24, 5, 24, 894, 8, 24, 10, 24, 12,
		24, 897, 9, 24, 1, 24, 1, 24, 1, 25, 1, 25, 3, 25, 903, 8, 25, 5, 25, 905,
		8, 25, 10, 25, 12, 25, 908, 9, 25, 1, 26, 1, 26, 1, 26, 1, 26, 3, 26, 914,
		8, 26, 1, 27, 1, 27, 5, 27, 918, 8, 27, 10, 27, 12, 27, 921, 9, 27, 1,
		27, 1, 27, 1, 28, 3, 28, 926, 8, 28, 1, 28, 1, 28, 5, 28, 930, 8, 28, 10,
		28, 12, 28, 933, 9, 28, 1, 28, 3, 28, 936, 8, 28, 1, 28, 5, 28, 939, 8,
		28, 10, 28, 12, 28, 942, 9, 28, 1, 28, 1, 28, 5, 28, 946, 8, 28, 10, 28,
		12, 28, 949, 9, 28, 1, 28, 3, 28, 952, 8, 28, 1, 28, 5, 28, 955, 8, 28,
		10, 28, 12, 28, 958, 9, 28, 1, 28, 1, 28, 5, 28, 962, 8, 28, 10, 28, 12,
		28, 965, 9, 28, 1, 28, 3, 28, 968, 8, 28, 1, 28, 5, 28, 971, 8, 28, 10,
		28, 12, 28, 974, 9, 28, 1, 28, 3, 28, 977, 8, 28, 1, 29, 1, 29, 5, 29,
		981, 8, 29, 10, 29, 12, 29, 984, 9, 29, 1, 29, 1, 29, 5, 29, 988, 8, 29,
		10, 29, 12, 29, 991, 9, 29, 1, 29, 1, 29, 5, 29, 995, 8, 29, 10, 29, 12,
		29, 998, 9, 29, 1, 29, 5, 29, 1001, 8, 29, 10, 29, 12, 29, 1004, 9, 29,
		1, 29, 5, 29, 1007, 8, 29, 10, 29, 12, 29, 1010, 9, 29, 1, 29, 3, 29, 1013,
		8, 29, 3, 29, 1015, 8, 29, 1, 29, 5, 29, 1018, 8, 29, 10, 29, 12, 29, 1021,
		9, 29, 1, 29, 1, 29, 1, 30, 3, 30, 1026, 8, 30, 1, 30, 1, 30, 5, 30, 1030,
		8, 30, 10, 30, 12, 30, 1033, 9, 30, 1, 30, 1, 30, 5, 30, 1037, 8, 30, 10,
		30, 12, 30, 1040, 9, 30, 1, 30, 3, 30, 1043, 8, 30, 1, 31, 3, 31, 1046,
		8, 31, 1, 31, 1, 31, 5, 31, 1050, 8, 31, 10, 31, 12, 31, 1053, 9, 31, 1,
		31, 3, 31, 1056, 8, 31, 1, 31, 5, 31, 1059, 8, 31, 10, 31, 12, 31, 1062,
		9, 31, 1, 31, 1, 31, 5, 31, 1066, 8, 31, 10, 31, 12, 31, 1069, 9, 31, 1,
		31, 1, 31, 3, 31, 1073, 8, 31, 1, 31, 5, 31, 1076, 8, 31, 10, 31, 12, 31,
		1079, 9, 31, 1, 31, 1, 31, 5, 31, 1083, 8, 31, 10, 31, 12, 31, 1086, 9,
		31, 1, 31, 1, 31, 5, 31, 1090, 8, 31, 10, 31, 12, 31, 1093, 9, 31, 1, 31,
		1, 31, 5, 31, 1097, 8, 31, 10, 31, 12, 31, 1100, 9, 31, 1, 31, 3, 31, 1103,
		8, 31, 1, 31, 5, 31, 1106, 8, 31, 10, 31, 12, 31, 1109, 9, 31, 1, 31, 3,
		31, 1112, 8, 31, 1, 31, 5, 31, 1115, 8, 31, 10, 31, 12, 31, 1118, 9, 31,
		1, 31, 3, 31, 1121, 8, 31, 1, 32, 1, 32, 1, 32, 5, 32, 1126, 8, 32, 10,
		32, 12, 32, 1129, 9, 32, 1, 32, 3, 32, 1132, 8, 32, 1, 33, 5, 33, 1135,
		8, 33, 10, 33, 12, 33, 1138, 9, 33, 1, 33, 5, 33, 1141, 8, 33, 10, 33,
		12, 33, 1144, 9, 33, 1, 33, 1, 33, 5, 33, 1148, 8, 33, 10, 33, 12, 33,
		1151, 9, 33, 1, 33, 1, 33, 5, 33, 1155, 8, 33, 10, 33, 12, 33, 1158, 9,
		33, 1, 33, 3, 33, 1161, 8, 33, 1, 34, 1, 34, 5, 34, 1165, 8, 34, 10, 34,
		12, 34, 1168, 9, 34, 1, 34, 1, 34, 5, 34, 1172, 8, 34, 10, 34, 12, 34,
		1175, 9, 34, 1, 34, 1, 34, 5, 34, 1179, 8, 34, 10, 34, 12, 34, 1182, 9,
		34, 1, 34, 5, 34, 1185, 8, 34, 10, 34, 12, 34, 1188, 9, 34, 1, 34, 5, 34,
		1191, 8, 34, 10, 34, 12, 34, 1194, 9, 34, 1, 34, 3, 34, 1197, 8, 34, 1,
		34, 5, 34, 1200, 8, 34, 10, 34, 12, 34, 1203, 9, 34, 1, 34, 1, 34, 1, 35,
		3, 35, 1208, 8, 35, 1, 35, 1, 35, 5, 35, 1212, 8, 35, 10, 35, 12, 35, 1215,
		9, 35, 1, 35, 3, 35, 1218, 8, 35, 1, 35, 5, 35, 1221, 8, 35, 10, 35, 12,
		35, 1224, 9, 35, 1, 35, 1, 35, 5, 35, 1228, 8, 35, 10, 35, 12, 35, 1231,
		9, 35, 1, 35, 1, 35, 3, 35, 1235, 8, 35, 1, 35, 5, 35, 1238, 8, 35, 10,
		35, 12, 35, 1241, 9, 35, 1, 35, 1, 35, 3, 35, 1245, 8, 35, 1, 35, 5, 35,
		1248, 8, 35, 10, 35, 12, 35, 1251, 9, 35, 1, 35, 3, 35, 1254, 8, 35, 1,
		35, 5, 35, 1257, 8, 35, 10, 35, 12, 35, 1260, 9, 35, 1, 35, 1, 35, 5, 35,
		1264, 8, 35, 10, 35, 12, 35, 1267, 9, 35, 1, 35, 1, 35, 3, 35, 1271, 8,
		35, 3, 35, 1273, 8, 35, 1, 35, 5, 35, 1276, 8, 35, 10, 35, 12, 35, 1279,
		9, 35, 1, 35, 3, 35, 1282, 8, 35, 1, 35, 5, 35, 1285, 8, 35, 10, 35, 12,
		35, 1288, 9, 35, 1, 35, 3, 35, 1291, 8, 35, 1, 35, 5, 35, 1294, 8, 35,
		10, 35, 12, 35, 1297, 9, 35, 1, 35, 3, 35, 1300, 8, 35, 1, 35, 3, 35, 1303,
		8, 35, 1, 35, 3, 35, 1306, 8, 35, 1, 35, 5, 35, 1309, 8, 35, 10, 35, 12,
		35, 1312, 9, 35, 1, 35, 3, 35, 1315, 8, 35, 1, 35, 3, 35, 1318, 8, 35,
		3, 35, 1320, 8, 35, 1, 36, 1, 36, 5, 36, 1324, 8, 36, 10, 36, 12, 36, 1327,
		9, 36, 1, 36, 1, 36, 1, 37, 3, 37, 1332, 8, 37, 1, 37, 1, 37, 5, 37, 1336,
		8, 37, 10, 37, 12, 37, 1339, 9, 37, 1, 37, 1, 37, 5, 37, 1343, 8, 37, 10,
		37, 12, 37, 1346, 9, 37, 1, 37, 1, 37, 5, 37, 1350, 8, 37, 10, 37, 12,
		37, 1353, 9, 37, 1, 37, 1, 37, 5, 37, 1357, 8, 37, 10, 37, 12, 37, 1360,
		9, 37, 1, 37, 3, 37, 1363, 8, 37, 1, 37, 5, 37, 1366, 8, 37, 10, 37, 12,
		37, 1369, 9, 37, 1, 37, 3, 37, 1372, 8, 37, 1, 38, 3, 38, 1375, 8, 38,
		1, 38, 1, 38, 5, 38, 1379, 8, 38, 10, 38, 12, 38, 1382, 9, 38, 1, 38, 1,
		38, 5, 38, 1386, 8, 38, 10, 38, 12, 38, 1389, 9, 38, 1, 38, 1, 38, 5, 38,
		1393, 8, 38, 10, 38, 12, 38, 1396, 9, 38, 1, 38, 3, 38, 1399, 8, 38, 1,
		38, 5, 38, 1402, 8, 38, 10, 38, 12, 38, 1405, 9, 38, 1, 38, 1, 38, 5, 38,
		1409, 8, 38, 10, 38, 12, 38, 1412, 9, 38, 1, 38, 1, 38, 5, 38, 1416, 8,
		38, 10, 38, 12, 38, 1419, 9, 38, 1, 38, 3, 38, 1422, 8, 38, 1, 38, 5, 38,
		1425, 8, 38, 10, 38, 12, 38, 1428, 9, 38, 1, 38, 1, 38, 3, 38, 1432, 8,
		38, 1, 39, 1, 39, 5, 39, 1436, 8, 39, 10, 39, 12, 39, 1439, 9, 39, 1, 39,
		1, 39, 5, 39, 1443, 8, 39, 10, 39, 12, 39, 1446, 9, 39, 1, 39, 1, 39, 5,
		39, 1450, 8, 39, 10, 39, 12, 39, 1453, 9, 39, 1, 39, 5, 39, 1456, 8, 39,
		10, 39, 12, 39, 1459, 9, 39, 1, 39, 5, 39, 1462, 8, 39, 10, 39, 12, 39,
		1465, 9, 39, 1, 39, 3, 39, 1468, 8, 39, 3, 39, 1470, 8, 39, 1, 39, 5, 39,
		1473, 8, 39, 10, 39, 12, 39, 1476, 9, 39, 1, 39, 1, 39, 1, 40, 3, 40, 1481,
		8, 40, 1, 40, 1, 40, 5, 40, 1485, 8, 40, 10, 40, 12, 40, 1488, 9, 40, 1,
		40, 1, 40, 5, 40, 1492, 8, 40, 10, 40, 12, 40, 1495, 9, 40, 1, 40, 3, 40,
		1498, 8, 40, 1, 41, 1, 41, 5, 41, 1502, 8, 41, 10, 41, 12, 41, 1505, 9,
		41, 1, 41, 1, 41, 5, 41, 1509, 8, 41, 10, 41, 12, 41, 1512, 9, 41, 1, 41,
		3, 41, 1515, 8, 41, 1, 42, 1, 42, 5, 42, 1519, 8, 42, 10, 42, 12, 42, 1522,
		9, 42, 1, 42, 1, 42, 5, 42, 1526, 8, 42, 10, 42, 12, 42, 1529, 9, 42, 1,
		42, 1, 42, 1, 43, 3, 43, 1534, 8, 43, 1, 43, 1, 43, 5, 43, 1538, 8, 43,
		10, 43, 12, 43, 1541, 9, 43, 1, 43, 1, 43, 5, 43, 1545, 8, 43, 10, 43,
		12, 43, 1548, 9, 43, 1, 43, 1, 43, 5, 43, 1552, 8, 43, 10, 43, 12, 43,
		1555, 9, 43, 1, 43, 3, 43, 1558, 8, 43, 1, 43, 5, 43, 1561, 8, 43, 10,
		43, 12, 43, 1564, 9, 43, 1, 43, 3, 43, 1567, 8, 43, 1, 44, 3, 44, 1570,
		8, 44, 1, 44, 1, 44, 5, 44, 1574, 8, 44, 10, 44, 12, 44, 1577, 9, 44, 1,
		44, 1, 44, 5, 44, 1581, 8, 44, 10, 44, 12, 44, 1584, 9, 44, 1, 44, 1, 44,
		5, 44, 1588, 8, 44, 10, 44, 12, 44, 1591, 9, 44, 1, 44, 3, 44, 1594, 8,
		44, 1, 44, 5, 44, 1597, 8, 44, 10, 44, 12, 44, 1600, 9, 44, 1, 44, 3, 44,
		1603, 8, 44, 1, 45, 1, 45, 5, 45, 1607, 8, 45, 10, 45, 12, 45, 1610, 9,
		45, 1, 45, 1, 45, 1, 46, 1, 46, 5, 46, 1616, 8, 46, 10, 46, 12, 46, 1619,
		9, 46, 1, 46, 3, 46, 1622, 8, 46, 1, 46, 5, 46, 1625, 8, 46, 10, 46, 12,
		46, 1628, 9, 46, 1, 46, 1, 46, 5, 46, 1632, 8, 46, 10, 46, 12, 46, 1635,
		9, 46, 1, 46, 3, 46, 1638, 8, 46, 1, 46, 5, 46, 1641, 8, 46, 10, 46, 12,
		46, 1644, 9, 46, 1, 46, 1, 46, 1, 47, 1, 47, 5, 47, 1650, 8, 47, 10, 47,
		12, 47, 1653, 9, 47, 1, 47, 1, 47, 5, 47, 1657, 8, 47, 10, 47, 12, 47,
		1660, 9, 47, 1, 47, 5, 47, 1663, 8, 47, 10, 47, 12, 47, 1666, 9, 47, 1,
		47, 5, 47, 1669, 8, 47, 10, 47, 12, 47, 1672, 9, 47, 1, 47, 3, 47, 1675,
		8, 47, 1, 48, 1, 48, 5, 48, 1679, 8, 48, 10, 48, 12, 48, 1682, 9, 48, 3,
		48, 1684, 8, 48, 1, 48, 1, 48, 5, 48, 1688, 8, 48, 10, 48, 12, 48, 1691,
		9, 48, 1, 48, 3, 48, 1694, 8, 48, 1, 48, 5, 48, 1697, 8, 48, 10, 48, 12,
		48, 1700, 9, 48, 1, 48, 3, 48, 1703, 8, 48, 1, 49, 3, 49, 1706, 8, 49,
		1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 3, 49, 1713, 8, 49, 1, 50, 1, 50, 3,
		50, 1717, 8, 50, 1, 51, 1, 51, 3, 51, 1721, 8, 51, 1, 51, 5, 51, 1724,
		8, 51, 10, 51, 12, 51, 1727, 9, 51, 1, 51, 4, 51, 1730, 8, 51, 11, 51,
		12, 51, 1731, 1, 52, 1, 52, 1, 53, 1, 53, 5, 53, 1738, 8, 53, 10, 53, 12,
		53, 1741, 9, 53, 1, 53, 1, 53, 5, 53, 1745, 8, 53, 10, 53, 12, 53, 1748,
		9, 53, 1, 53, 5, 53, 1751, 8, 53, 10, 53, 12, 53, 1754, 9, 53, 1, 54, 1,
		54, 5, 54, 1758, 8, 54, 10, 54, 12, 54, 1761, 9, 54, 1, 54, 3, 54, 1764,
		8, 54, 1, 55, 3, 55, 1767, 8, 55, 1, 55, 1, 55, 3, 55, 1771, 8, 55, 1,
		56, 4, 56, 1774, 8, 56, 11, 56, 12, 56, 1775, 1, 57, 1, 57, 5, 57, 1780,
		8, 57, 10, 57, 12, 57, 1783, 9, 57, 1, 57, 3, 57, 1786, 8, 57, 1, 58, 1,
		58, 5, 58, 1790, 8, 58, 10, 58, 12, 58, 1793, 9, 58, 1, 58, 1, 58, 5, 58,
		1797, 8, 58, 10, 58, 12, 58, 1800, 9, 58, 3, 58, 1802, 8, 58, 1, 58, 1,
		58, 5, 58, 1806, 8, 58, 10, 58, 12, 58, 1809, 9, 58, 1, 58, 1, 58, 5, 58,
		1813, 8, 58, 10, 58, 12, 58, 1816, 9, 58, 1, 58, 1, 58, 1, 59, 1, 59, 5,
		59, 1822, 8, 59, 10, 59, 12, 59, 1825, 9, 59, 1, 59, 1, 59, 3, 59, 1829,
		8, 59, 1, 59, 5, 59, 1832, 8, 59, 10, 59, 12, 59, 1835, 9, 59, 1, 59, 1,
		59, 5, 59, 1839, 8, 59, 10, 59, 12, 59, 1842, 9, 59, 1, 59, 1, 59, 3, 59,
		1846, 8, 59, 5, 59, 1848, 8, 59, 10, 59, 12, 59, 1851, 9, 59, 1, 59, 5,
		59, 1854, 8, 59, 10, 59, 12, 59, 1857, 9, 59, 1, 59, 3, 59, 1860, 8, 59,
		1, 59, 5, 59, 1863, 8, 59, 10, 59, 12, 59, 1866, 9, 59, 1, 59, 1, 59, 1,
		60, 1, 60, 5, 60, 1872, 8, 60, 10, 60, 12, 60, 1875, 9, 60, 1, 60, 1, 60,
		5, 60, 1879, 8, 60, 10, 60, 12, 60, 1882, 9, 60, 1, 60, 1, 60, 1, 61, 3,
		61, 1887, 8, 61, 1, 61, 1, 61, 1, 61, 3, 61, 1892, 8, 61, 1, 62, 1, 62,
		5, 62, 1896, 8, 62, 10, 62, 12, 62, 1899, 9, 62, 1, 62, 1, 62, 3, 62, 1903,
		8, 62, 1, 62, 5, 62, 1906, 8, 62, 10, 62, 12, 62, 1909, 9, 62, 1, 62, 1,
		62, 1, 63, 3, 63, 1914, 8, 63, 1, 63, 1, 63, 3, 63, 1918, 8, 63, 1, 63,
		5, 63, 1921, 8, 63, 10, 63, 12, 63, 1924, 9, 63, 1, 63, 1, 63, 5, 63, 1928,
		8, 63, 10, 63, 12, 63, 1931, 9, 63, 1, 63, 3, 63, 1934, 8, 63, 1, 63, 1,
		63, 3, 63, 1938, 8, 63, 1, 64, 1, 64, 1, 64, 1, 64, 5, 64, 1944, 8, 64,
		10, 64, 12, 64, 1947, 9, 64, 3, 64, 1949, 8, 64, 1, 64, 3, 64, 1952, 8,
		64, 1, 65, 1, 65, 5, 65, 1956, 8, 65, 10, 65, 12, 65, 1959, 9, 65, 1, 65,
		1, 65, 1, 65, 1, 65, 3, 65, 1965, 8, 65, 1, 66, 1, 66, 1, 66, 5, 66, 1970,
		8, 66, 10, 66, 12, 66, 1973, 9, 66, 1, 67, 1, 67, 3, 67, 1977, 8, 67, 1,
		68, 1, 68, 5, 68, 1981, 8, 68, 10, 68, 12, 68, 1984, 9, 68, 1, 68, 1, 68,
		5, 68, 1988, 8, 68, 10, 68, 12, 68, 1991, 9, 68, 1, 68, 1, 68, 1, 69, 1,
		69, 1, 69, 3, 69, 1998, 8, 69, 1, 70, 1, 70, 5, 70, 2002, 8, 70, 10, 70,
		12, 70, 2005, 9, 70, 1, 70, 1, 70, 5, 70, 2009, 8, 70, 10, 70, 12, 70,
		2012, 9, 70, 1, 70, 1, 70, 3, 70, 2016, 8, 70, 1, 70, 1, 70, 1, 70, 1,
		70, 5, 70, 2022, 8, 70, 10, 70, 12, 70, 2025, 9, 70, 1, 70, 3, 70, 2028,
		8, 70, 1, 71, 1, 71, 5, 71, 2032, 8, 71, 10, 71, 12, 71, 2035, 9, 71, 1,
		71, 1, 71, 1, 71, 1, 71, 5, 71, 2041, 8, 71, 10, 71, 12, 71, 2044, 9, 71,
		1, 71, 1, 71, 3, 71, 2048, 8, 71, 1, 72, 1, 72, 5, 72, 2052, 8, 72, 10,
		72, 12, 72, 2055, 9, 72, 1, 72, 3, 72, 2058, 8, 72, 1, 72, 5, 72, 2061,
		8, 72, 10, 72, 12, 72, 2064, 9, 72, 1, 72, 1, 72, 5, 72, 2068, 8, 72, 10,
		72, 12, 72, 2071, 9, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 73, 1, 73, 1, 73,
		1, 73, 1, 73, 1, 73, 3, 73, 2083, 8, 73, 1, 73, 5, 73, 2086, 8, 73, 10,
		73, 12, 73, 2089, 9, 73, 1, 73, 1, 73, 1, 74, 1, 74, 5, 74, 2095, 8, 74,
		10, 74, 12, 74, 2098, 9, 74, 1, 75, 4, 75, 2101, 8, 75, 11, 75, 12, 75,
		2102, 1, 76, 1, 76, 1, 77, 1, 77, 5, 77, 2109, 8, 77, 10, 77, 12, 77, 2112,
		9, 77, 1, 77, 1, 77, 5, 77, 2116, 8, 77, 10, 77, 12, 77, 2119, 9, 77, 1,
		77, 5, 77, 2122, 8, 77, 10, 77, 12, 77, 2125, 9, 77, 1, 78, 1, 78, 5, 78,
		2129, 8, 78, 10, 78, 12, 78, 2132, 9, 78, 1, 78, 1, 78, 5, 78, 2136, 8,
		78, 10, 78, 12, 78, 2139, 9, 78, 1, 78, 5, 78, 2142, 8, 78, 10, 78, 12,
		78, 2145, 9, 78, 1, 79, 1, 79, 1, 79, 5, 79, 2150, 8, 79, 10, 79, 12, 79,
		2153, 9, 79, 1, 79, 1, 79, 5, 79, 2157, 8, 79, 10, 79, 12, 79, 2160, 9,
		79, 1, 80, 1, 80, 1, 80, 5, 80, 2165, 8, 80, 10, 80, 12, 80, 2168, 9, 80,
		1, 80, 1, 80, 5, 80, 2172, 8, 80, 10, 80, 12, 80, 2175, 9, 80, 1, 81, 1,
		81, 5, 81, 2179, 8, 81, 10, 81, 12, 81, 2182, 9, 81, 1, 82, 1, 82, 1, 82,
		5, 82, 2187, 8, 82, 10, 82, 12, 82, 2190, 9, 82, 1, 82, 1, 82, 1, 82, 1,
		82, 5, 82, 2196, 8, 82, 10, 82, 12, 82, 2199, 9, 82, 1, 82, 1, 82, 5, 82,
		2203, 8, 82, 10, 82, 12, 82, 2206, 9, 82, 1, 83, 1, 83, 5, 83, 2210, 8,
		83, 10, 83, 12, 83, 2213, 9, 83, 1, 83, 1, 83, 5, 83, 2217, 8, 83, 10,
		83, 12, 83, 2220, 9, 83, 1, 83, 1, 83, 5, 83, 2224, 8, 83, 10, 83, 12,
		83, 2227, 9, 83, 1, 84, 1, 84, 1, 84, 1, 85, 1, 85, 1, 85, 5, 85, 2235,
		8, 85, 10, 85, 12, 85, 2238, 9, 85, 1, 85, 1, 85, 5, 85, 2242, 8, 85, 10,
		85, 12, 85, 2245, 9, 85, 1, 86, 1, 86, 1, 86, 5, 86, 2250, 8, 86, 10, 86,
		12, 86, 2253, 9, 86, 1, 86, 5, 86, 2256, 8, 86, 10, 86, 12, 86, 2259, 9,
		86, 1, 87, 1, 87, 1, 87, 5, 87, 2264, 8, 87, 10, 87, 12, 87, 2267, 9, 87,
		1, 87, 1, 87, 5, 87, 2271, 8, 87, 10, 87, 12, 87, 2274, 9, 87, 1, 88, 1,
		88, 1, 88, 5, 88, 2279, 8, 88, 10, 88, 12, 88, 2282, 9, 88, 1, 88, 1, 88,
		5, 88, 2286, 8, 88, 10, 88, 12, 88, 2289, 9, 88, 1, 89, 1, 89, 5, 89, 2293,
		8, 89, 10, 89, 12, 89, 2296, 9, 89, 1, 89, 1, 89, 5, 89, 2300, 8, 89, 10,
		89, 12, 89, 2303, 9, 89, 1, 89, 1, 89, 5, 89, 2307, 8, 89, 10, 89, 12,
		89, 2310, 9, 89, 1, 90, 5, 90, 2313, 8, 90, 10, 90, 12, 90, 2316, 9, 90,
		1, 90, 1, 90, 1, 91, 1, 91, 1, 91, 1, 91, 5, 91, 2324, 8, 91, 10, 91, 12,
		91, 2327, 9, 91, 3, 91, 2329, 8, 91, 1, 92, 1, 92, 5, 92, 2333, 8, 92,
		10, 92, 12, 92, 2336, 9, 92, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 3, 93,
		2343, 8, 93, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 3, 94, 2350, 8, 94, 1,
		95, 1, 95, 5, 95, 2354, 8, 95, 10, 95, 12, 95, 2357, 9, 95, 1, 95, 1, 95,
		5, 95, 2361, 8, 95, 10, 95, 12, 95, 2364, 9, 95, 1, 95, 1, 95, 1, 96, 1,
		96, 3, 96, 2370, 8, 96, 1, 97, 1, 97, 5, 97, 2374, 8, 97, 10, 97, 12, 97,
		2377, 9, 97, 1, 97, 1, 97, 5, 97, 2381, 8, 97, 10, 97, 12, 97, 2384, 9,
		97, 1, 97, 1, 97, 1, 98, 1, 98, 1, 98, 3, 98, 2391, 8, 98, 1, 99, 1, 99,
		5, 99, 2395, 8, 99, 10, 99, 12, 99, 2398, 9, 99, 1, 99, 1, 99, 5, 99, 2402,
		8, 99, 10, 99, 12, 99, 2405, 9, 99, 1, 99, 1, 99, 5, 99, 2409, 8, 99, 10,
		99, 12, 99, 2412, 9, 99, 1, 99, 5, 99, 2415, 8, 99, 10, 99, 12, 99, 2418,
		9, 99, 1, 99, 5, 99, 2421, 8, 99, 10, 99, 12, 99, 2424, 9, 99, 1, 99, 3,
		99, 2427, 8, 99, 1, 99, 5, 99, 2430, 8, 99, 10, 99, 12, 99, 2433, 9, 99,
		1, 99, 1, 99, 1, 100, 1, 100, 5, 100, 2439, 8, 100, 10, 100, 12, 100, 2442,
		9, 100, 1, 100, 1, 100, 1, 100, 3, 100, 2447, 8, 100, 1, 101, 3, 101, 2450,
		8, 101, 1, 101, 3, 101, 2453, 8, 101, 1, 101, 1, 101, 3, 101, 2457, 8,
		101, 1, 102, 5, 102, 2460, 8, 102, 10, 102, 12, 102, 2463, 9, 102, 1, 102,
		3, 102, 2466, 8, 102, 1, 102, 5, 102, 2469, 8, 102, 10, 102, 12, 102, 2472,
		9, 102, 1, 102, 1, 102, 1, 103, 1, 103, 5, 103, 2478, 8, 103, 10, 103,
		12, 103, 2481, 9, 103, 1, 103, 1, 103, 5, 103, 2485, 8, 103, 10, 103, 12,
		103, 2488, 9, 103, 1, 103, 1, 103, 5, 103, 2492, 8, 103, 10, 103, 12, 103,
		2495, 9, 103, 1, 103, 5, 103, 2498, 8, 103, 10, 103, 12, 103, 2501, 9,
		103, 1, 103, 5, 103, 2504, 8, 103, 10, 103, 12, 103, 2507, 9, 103, 1, 103,
		3, 103, 2510, 8, 103, 1, 103, 5, 103, 2513, 8, 103, 10, 103, 12, 103, 2516,
		9, 103, 1, 103, 1, 103, 1, 104, 1, 104, 5, 104, 2522, 8, 104, 10, 104,
		12, 104, 2525, 9, 104, 1, 104, 1, 104, 5, 104, 2529, 8, 104, 10, 104, 12,
		104, 2532, 9, 104, 1, 104, 1, 104, 5, 104, 2536, 8, 104, 10, 104, 12, 104,
		2539, 9, 104, 1, 104, 5, 104, 2542, 8, 104, 10, 104, 12, 104, 2545, 9,
		104, 1, 104, 5, 104, 2548, 8, 104, 10, 104, 12, 104, 2551, 9, 104, 1, 104,
		3, 104, 2554, 8, 104, 1, 104, 5, 104, 2557, 8, 104, 10, 104, 12, 104, 2560,
		9, 104, 3, 104, 2562, 8, 104, 1, 104, 1, 104, 1, 105, 3, 105, 2567, 8,
		105, 1, 105, 5, 105, 2570, 8, 105, 10, 105, 12, 105, 2573, 9, 105, 1, 105,
		1, 105, 5, 105, 2577, 8, 105, 10, 105, 12, 105, 2580, 9, 105, 1, 105, 1,
		105, 5, 105, 2584, 8, 105, 10, 105, 12, 105, 2587, 9, 105, 3, 105, 2589,
		8, 105, 1, 105, 3, 105, 2592, 8, 105, 1, 105, 5, 105, 2595, 8, 105, 10,
		105, 12, 105, 2598, 9, 105, 1, 105, 1, 105, 1, 106, 1, 106, 1, 106, 1,
		106, 1, 106, 1, 106, 1, 106, 1, 106, 1, 106, 1, 106, 1, 106, 1, 106, 1,
		106, 1, 106, 3, 106, 2616, 8, 106, 1, 107, 1, 107, 5, 107, 2620, 8, 107,
		10, 107, 12, 107, 2623, 9, 107, 1, 107, 1, 107, 5, 107, 2627, 8, 107, 10,
		107, 12, 107, 2630, 9, 107, 1, 107, 1, 107, 1, 108, 1, 108, 5, 108, 2636,
		8, 108, 10, 108, 12, 108, 2639, 9, 108, 1, 108, 1, 108, 5, 108, 2643, 8,
		108, 10, 108, 12, 108, 2646, 9, 108, 1, 108, 1, 108, 5, 108, 2650, 8, 108,
		10, 108, 12, 108, 2653, 9, 108, 1, 108, 5, 108, 2656, 8, 108, 10, 108,
		12, 108, 2659, 9, 108, 1, 108, 5, 108, 2662, 8, 108, 10, 108, 12, 108,
		2665, 9, 108, 1, 108, 3, 108, 2668, 8, 108, 1, 108, 5, 108, 2671, 8, 108,
		10, 108, 12, 108, 2674, 9, 108, 3, 108, 2676, 8, 108, 1, 108, 1, 108, 1,
		109, 1, 109, 1, 110, 1, 110, 3, 110, 2684, 8, 110, 1, 111, 1, 111, 1, 111,
		5, 111, 2689, 8, 111, 10, 111, 12, 111, 2692, 9, 111, 1, 111, 1, 111, 1,
		112, 1, 112, 1, 112, 1, 112, 5, 112, 2700, 8, 112, 10, 112, 12, 112, 2703,
		9, 112, 1, 112, 1, 112, 1, 113, 1, 113, 1, 114, 1, 114, 5, 114, 2711, 8,
		114, 10, 114, 12, 114, 2714, 9, 114, 1, 114, 1, 114, 5, 114, 2718, 8, 114,
		10, 114, 12, 114, 2721, 9, 114, 1, 114, 1, 114, 1, 115, 1, 115, 1, 116,
		1, 116, 5, 116, 2729, 8, 116, 10, 116, 12, 116, 2732, 9, 116, 1, 116, 1,
		116, 5, 116, 2736, 8, 116, 10, 116, 12, 116, 2739, 9, 116, 1, 116, 1, 116,
		1, 117, 1, 117, 5, 117, 2745, 8, 117, 10, 117, 12, 117, 2748, 9, 117, 1,
		117, 3, 117, 2751, 8, 117, 1, 117, 5, 117, 2754, 8, 117, 10, 117, 12, 117,
		2757, 9, 117, 1, 117, 1, 117, 5, 117, 2761, 8, 117, 10, 117, 12, 117, 2764,
		9, 117, 3, 117, 2766, 8, 117, 1, 117, 1, 117, 5, 117, 2770, 8, 117, 10,
		117, 12, 117, 2773, 9, 117, 1, 117, 1, 117, 1, 118, 1, 118, 5, 118, 2779,
		8, 118, 10, 118, 12, 118, 2782, 9, 118, 1, 118, 1, 118, 5, 118, 2786, 8,
		118, 10, 118, 12, 118, 2789, 9, 118, 1, 118, 5, 118, 2792, 8, 118, 10,
		118, 12, 118, 2795, 9, 118, 1, 118, 5, 118, 2798, 8, 118, 10, 118, 12,
		118, 2801, 9, 118, 1, 118, 3, 118, 2804, 8, 118, 1, 119, 1, 119, 1, 119,
		5, 119, 2809, 8, 119, 10, 119, 12, 119, 2812, 9, 119, 1, 119, 1, 119, 5,
		119, 2816, 8, 119, 10, 119, 12, 119, 2819, 9, 119, 1, 119, 3, 119, 2822,
		8, 119, 3, 119, 2824, 8, 119, 1, 120, 3, 120, 2827, 8, 120, 1, 120, 5,
		120, 2830, 8, 120, 10, 120, 12, 120, 2833, 9, 120, 1, 120, 1, 120, 5, 120,
		2837, 8, 120, 10, 120, 12, 120, 2840, 9, 120, 1, 120, 1, 120, 5, 120, 2844,
		8, 120, 10, 120, 12, 120, 2847, 9, 120, 1, 120, 1, 120, 3, 120, 2851, 8,
		120, 1, 120, 5, 120, 2854, 8, 120, 10, 120, 12, 120, 2857, 9, 120, 1, 120,
		1, 120, 5, 120, 2861, 8, 120, 10, 120, 12, 120, 2864, 9, 120, 1, 120, 1,
		120, 5, 120, 2868, 8, 120, 10, 120, 12, 120, 2871, 9, 120, 1, 120, 3, 120,
		2874, 8, 120, 1, 120, 5, 120, 2877, 8, 120, 10, 120, 12, 120, 2880, 9,
		120, 1, 120, 3, 120, 2883, 8, 120, 1, 120, 5, 120, 2886, 8, 120, 10, 120,
		12, 120, 2889, 9, 120, 1, 120, 3, 120, 2892, 8, 120, 1, 121, 1, 121, 3,
		121, 2896, 8, 121, 1, 122, 3, 122, 2899, 8, 122, 1, 122, 5, 122, 2902,
		8, 122, 10, 122, 12, 122, 2905, 9, 122, 1, 122, 1, 122, 5, 122, 2909, 8,
		122, 10, 122, 12, 122, 2912, 9, 122, 1, 122, 1, 122, 5, 122, 2916, 8, 122,
		10, 122, 12, 122, 2919, 9, 122, 1, 122, 1, 122, 5, 122, 2923, 8, 122, 10,
		122, 12, 122, 2926, 9, 122, 3, 122, 2928, 8, 122, 1, 122, 5, 122, 2931,
		8, 122, 10, 122, 12, 122, 2934, 9, 122, 1, 122, 3, 122, 2937, 8, 122, 1,
		123, 1, 123, 1, 124, 1, 124, 1, 124, 5, 124, 2944, 8, 124, 10, 124, 12,
		124, 2947, 9, 124, 1, 124, 1, 124, 5, 124, 2951, 8, 124, 10, 124, 12, 124,
		2954, 9, 124, 1, 124, 1, 124, 3, 124, 2958, 8, 124, 1, 124, 1, 124, 3,
		124, 2962, 8, 124, 1, 124, 3, 124, 2965, 8, 124, 1, 125, 1, 125, 5, 125,
		2969, 8, 125, 10, 125, 12, 125, 2972, 9, 125, 1, 125, 1, 125, 5, 125, 2976,
		8, 125, 10, 125, 12, 125, 2979, 9, 125, 1, 125, 1, 125, 5, 125, 2983, 8,
		125, 10, 125, 12, 125, 2986, 9, 125, 1, 125, 1, 125, 5, 125, 2990, 8, 125,
		10, 125, 12, 125, 2993, 9, 125, 1, 125, 1, 125, 3, 125, 2997, 8, 125, 1,
		125, 5, 125, 3000, 8, 125, 10, 125, 12, 125, 3003, 9, 125, 1, 125, 3, 125,
		3006, 8, 125, 1, 125, 5, 125, 3009, 8, 125, 10, 125, 12, 125, 3012, 9,
		125, 1, 125, 1, 125, 5, 125, 3016, 8, 125, 10, 125, 12, 125, 3019, 9, 125,
		1, 125, 1, 125, 3, 125, 3023, 8, 125, 1, 125, 3, 125, 3026, 8, 125, 1,
		126, 1, 126, 5, 126, 3030, 8, 126, 10, 126, 12, 126, 3033, 9, 126, 1, 126,
		5, 126, 3036, 8, 126, 10, 126, 12, 126, 3039, 9, 126, 1, 126, 1, 126, 5,
		126, 3043, 8, 126, 10, 126, 12, 126, 3046, 9, 126, 1, 126, 1, 126, 5, 126,
		3050, 8, 126, 10, 126, 12, 126, 3053, 9, 126, 1, 126, 1, 126, 5, 126, 3057,
		8, 126, 10, 126, 12, 126, 3060, 9, 126, 3, 126, 3062, 8, 126, 1, 126, 1,
		126, 1, 126, 1, 127, 1, 127, 5, 127, 3069, 8, 127, 10, 127, 12, 127, 3072,
		9, 127, 1, 127, 3, 127, 3075, 8, 127, 1, 127, 5, 127, 3078, 8, 127, 10,
		127, 12, 127, 3081, 9, 127, 1, 127, 1, 127, 5, 127, 3085, 8, 127, 10, 127,
		12, 127, 3088, 9, 127, 1, 127, 1, 127, 5, 127, 3092, 8, 127, 10, 127, 12,
		127, 3095, 9, 127, 5, 127, 3097, 8, 127, 10, 127, 12, 127, 3100, 9, 127,
		1, 127, 5, 127, 3103, 8, 127, 10, 127, 12, 127, 3106, 9, 127, 1, 127, 1,
		127, 1, 128, 1, 128, 5, 128, 3112, 8, 128, 10, 128, 12, 128, 3115, 9, 128,
		1, 128, 1, 128, 5, 128, 3119, 8, 128, 10, 128, 12, 128, 3122, 9, 128, 1,
		128, 5, 128, 3125, 8, 128, 10, 128, 12, 128, 3128, 9, 128, 1, 128, 5, 128,
		3131, 8, 128, 10, 128, 12, 128, 3134, 9, 128, 1, 128, 3, 128, 3137, 8,
		128, 1, 128, 5, 128, 3140, 8, 128, 10, 128, 12, 128, 3143, 9, 128, 1, 128,
		1, 128, 5, 128, 3147, 8, 128, 10, 128, 12, 128, 3150, 9, 128, 1, 128, 1,
		128, 3, 128, 3154, 8, 128, 1, 128, 1, 128, 5, 128, 3158, 8, 128, 10, 128,
		12, 128, 3161, 9, 128, 1, 128, 1, 128, 5, 128, 3165, 8, 128, 10, 128, 12,
		128, 3168, 9, 128, 1, 128, 1, 128, 3, 128, 3172, 8, 128, 3, 128, 3174,
		8, 128, 1, 129, 1, 129, 1, 129, 3, 129, 3179, 8, 129, 1, 130, 1, 130, 5,
		130, 3183, 8, 130, 10, 130, 12, 130, 3186, 9, 130, 1, 130, 1, 130, 1, 131,
		1, 131, 5, 131, 3192, 8, 131, 10, 131, 12, 131, 3195, 9, 131, 1, 131, 1,
		131, 1, 132, 1, 132, 5, 132, 3201, 8, 132, 10, 132, 12, 132, 3204, 9, 132,
		1, 132, 1, 132, 5, 132, 3208, 8, 132, 10, 132, 12, 132, 3211, 9, 132, 1,
		132, 4, 132, 3214, 8, 132, 11, 132, 12, 132, 3215, 1, 132, 5, 132, 3219,
		8, 132, 10, 132, 12, 132, 3222, 9, 132, 1, 132, 3, 132, 3225, 8, 132, 1,
		132, 5, 132, 3228, 8, 132, 10, 132, 12, 132, 3231, 9, 132, 1, 132, 3, 132,
		3234, 8, 132, 1, 133, 1, 133, 5, 133, 3238, 8, 133, 10, 133, 12, 133, 3241,
		9, 133, 1, 133, 1, 133, 5, 133, 3245, 8, 133, 10, 133, 12, 133, 3248, 9,
		133, 1, 133, 1, 133, 1, 133, 1, 133, 5, 133, 3254, 8, 133, 10, 133, 12,
		133, 3257, 9, 133, 1, 133, 3, 133, 3260, 8, 133, 1, 133, 1, 133, 5, 133,
		3264, 8, 133, 10, 133, 12, 133, 3267, 9, 133, 1, 133, 1, 133, 1, 134, 1,
		134, 5, 134, 3273, 8, 134, 10, 134, 12, 134, 3276, 9, 134, 1, 134, 1, 134,
		1, 135, 1, 135, 5, 135, 3282, 8, 135, 10, 135, 12, 135, 3285, 9, 135, 1,
		135, 1, 135, 1, 135, 3, 135, 3290, 8, 135, 1, 135, 1, 135, 1, 135, 1, 135,
		3, 135, 3296, 8, 135, 1, 136, 3, 136, 3299, 8, 136, 1, 136, 1, 136, 5,
		136, 3303, 8, 136, 10, 136, 12, 136, 3306, 9, 136, 1, 136, 1, 136, 3, 136,
		3310, 8, 136, 1, 137, 1, 137, 1, 138, 1, 138, 1, 139, 1, 139, 1, 140, 1,
		140, 1, 141, 1, 141, 1, 142, 1, 142, 1, 143, 1, 143, 1, 144, 1, 144, 1,
		145, 1, 145, 1, 145, 1, 145, 1, 145, 3, 145, 3333, 8, 145, 1, 146, 1, 146,
		1, 146, 1, 146, 3, 146, 3339, 8, 146, 1, 147, 1, 147, 1, 148, 5, 148, 3344,
		8, 148, 10, 148, 12, 148, 3347, 9, 148, 1, 148, 1, 148, 5, 148, 3351, 8,
		148, 10, 148, 12, 148, 3354, 9, 148, 1, 148, 1, 148, 3, 148, 3358, 8, 148,
		1, 149, 1, 149, 1, 149, 1, 150, 1, 150, 4, 150, 3365, 8, 150, 11, 150,
		12, 150, 3366, 1, 151, 1, 151, 4, 151, 3371, 8, 151, 11, 151, 12, 151,
		3372, 1, 152, 1, 152, 1, 152, 1, 152, 1, 152, 1, 152, 1, 152, 1, 152, 3,
		152, 3383, 8, 152, 1, 152, 5, 152, 3386, 8, 152, 10, 152, 12, 152, 3389,
		9, 152, 1, 153, 4, 153, 3392, 8, 153, 11, 153, 12, 153, 3393, 1, 154, 1,
		154, 1, 154, 5, 154, 3399, 8, 154, 10, 154, 12, 154, 3402, 9, 154, 3, 154,
		3404, 8, 154, 1, 155, 1, 155, 1, 156, 1, 156, 1, 157, 1, 157, 1, 158, 1,
		158, 1, 159, 4, 159, 3415, 8, 159, 11, 159, 12, 159, 3416, 1, 160, 1, 160,
		5, 160, 3421, 8, 160, 10, 160, 12, 160, 3424, 9, 160, 1, 160, 1, 160, 5,
		160, 3428, 8, 160, 10, 160, 12, 160, 3431, 9, 160, 1, 160, 3, 160, 3434,
		8, 160, 1, 161, 1, 161, 1, 162, 1, 162, 1, 163, 1, 163, 1, 164, 1, 164,
		1, 165, 1, 165, 1, 166, 1, 166, 1, 167, 1, 167, 3, 167, 3450, 8, 167, 1,
		167, 5, 167, 3453, 8, 167, 10, 167, 12, 167, 3456, 9, 167, 1, 168, 1, 168,
		5, 168, 3460, 8, 168, 10, 168, 12, 168, 3463, 9, 168, 1, 168, 1, 168, 3,
		168, 3467, 8, 168, 1, 168, 1, 168, 1, 169, 1, 169, 5, 169, 3473, 8, 169,
		10, 169, 12, 169, 3476, 9, 169, 1, 169, 1, 169, 3, 169, 3480, 8, 169, 1,
		169, 1, 169, 4, 169, 3484, 8, 169, 11, 169, 12, 169, 3485, 1, 169, 1, 169,
		1, 170, 1, 170, 1, 170, 5, 170, 3493, 8, 170, 10, 170, 12, 170, 3496, 9,
		170, 1, 170, 1, 170, 1, 171, 1, 171, 3, 171, 3502, 8, 171, 1, 172, 1, 172,
		1, 173, 1, 173, 5, 173, 3508, 8, 173, 10, 173, 12, 173, 3511, 9, 173, 1,
		173, 1, 173, 5, 173, 3515, 8, 173, 10, 173, 12, 173, 3518, 9, 173, 1, 173,
		0, 0, 174, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32,
		34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68,
		70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104,
		106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134,
		136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164,
		166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194,
		196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224,
		226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254,
		256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284,
		286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314,
		316, 318, 320, 322, 324, 326, 328, 330, 332, 334, 336, 338, 340, 342, 344,
		346, 0, 31, 2, 0, 41, 41, 43, 43, 1, 0, 78, 79, 1, 0, 85, 86, 1, 0, 45,
		46, 1, 0, 41, 42, 2, 0, 5, 5, 27, 27, 1, 0, 36, 37, 2, 0, 137, 137, 140,
		147, 1, 0, 161, 163, 1, 0, 166, 168, 2, 0, 61, 61, 85, 85, 2, 0, 58, 58,
		99, 99, 1, 0, 29, 33, 2, 0, 51, 52, 54, 55, 1, 0, 47, 50, 2, 0, 104, 104,
		106, 106, 2, 0, 103, 103, 105, 105, 1, 0, 18, 19, 1, 0, 15, 17, 2, 0, 53,
		53, 102, 102, 1, 0, 24, 25, 1, 0, 113, 118, 2, 0, 125, 125, 130, 130, 1,
		0, 109, 112, 2, 0, 104, 104, 107, 107, 1, 0, 119, 124, 1, 0, 126, 128,
		1, 0, 131, 133, 1, 0, 135, 136, 1, 0, 64, 71, 7, 0, 63, 71, 73, 73, 81,
		84, 88, 88, 93, 94, 107, 136, 148, 148, 3945, 0, 349, 1, 0, 0, 0, 2, 374,
		1, 0, 0, 0, 4, 400, 1, 0, 0, 0, 6, 406, 1, 0, 0, 0, 8, 443, 1, 0, 0, 0,
		10, 448, 1, 0, 0, 0, 12, 451, 1, 0, 0, 0, 14, 461, 1, 0, 0, 0, 16, 464,
		1, 0, 0, 0, 18, 469, 1, 0, 0, 0, 20, 508, 1, 0, 0, 0, 22, 511, 1, 0, 0,
		0, 24, 602, 1, 0, 0, 0, 26, 606, 1, 0, 0, 0, 28, 622, 1, 0, 0, 0, 30, 669,
		1, 0, 0, 0, 32, 705, 1, 0, 0, 0, 34, 737, 1, 0, 0, 0, 36, 739, 1, 0, 0,
		0, 38, 751, 1, 0, 0, 0, 40, 764, 1, 0, 0, 0, 42, 781, 1, 0, 0, 0, 44, 826,
		1, 0, 0, 0, 46, 851, 1, 0, 0, 0, 48, 881, 1, 0, 0, 0, 50, 906, 1, 0, 0,
		0, 52, 913, 1, 0, 0, 0, 54, 915, 1, 0, 0, 0, 56, 925, 1, 0, 0, 0, 58, 978,
		1, 0, 0, 0, 60, 1025, 1, 0, 0, 0, 62, 1045, 1, 0, 0, 0, 64, 1131, 1, 0,
		0, 0, 66, 1136, 1, 0, 0, 0, 68, 1162, 1, 0, 0, 0, 70, 1207, 1, 0, 0, 0,
		72, 1321, 1, 0, 0, 0, 74, 1331, 1, 0, 0, 0, 76, 1374, 1, 0, 0, 0, 78, 1433,
		1, 0, 0, 0, 80, 1480, 1, 0, 0, 0, 82, 1499, 1, 0, 0, 0, 84, 1516, 1, 0,
		0, 0, 86, 1533, 1, 0, 0, 0, 88, 1569, 1, 0, 0, 0, 90, 1604, 1, 0, 0, 0,
		92, 1613, 1, 0, 0, 0, 94, 1647, 1, 0, 0, 0, 96, 1683, 1, 0, 0, 0, 98, 1705,
		1, 0, 0, 0, 100, 1716, 1, 0, 0, 0, 102, 1720, 1, 0, 0, 0, 104, 1733, 1,
		0, 0, 0, 106, 1735, 1, 0, 0, 0, 108, 1755, 1, 0, 0, 0, 110, 1770, 1, 0,
		0, 0, 112, 1773, 1, 0, 0, 0, 114, 1785, 1, 0, 0, 0, 116, 1801, 1, 0, 0,
		0, 118, 1819, 1, 0, 0, 0, 120, 1869, 1, 0, 0, 0, 122, 1886, 1, 0, 0, 0,
		124, 1893, 1, 0, 0, 0, 126, 1913, 1, 0, 0, 0, 128, 1948, 1, 0, 0, 0, 130,
		1957, 1, 0, 0, 0, 132, 1966, 1, 0, 0, 0, 134, 1976, 1, 0, 0, 0, 136, 1978,
		1, 0, 0, 0, 138, 1997, 1, 0, 0, 0, 140, 1999, 1, 0, 0, 0, 142, 2029, 1,
		0, 0, 0, 144, 2049, 1, 0, 0, 0, 146, 2082, 1, 0, 0, 0, 148, 2092, 1, 0,
		0, 0, 150, 2100, 1, 0, 0, 0, 152, 2104, 1, 0, 0, 0, 154, 2106, 1, 0, 0,
		0, 156, 2126, 1, 0, 0, 0, 158, 2146, 1, 0, 0, 0, 160, 2161, 1, 0, 0, 0,
		162, 2176, 1, 0, 0, 0, 164, 2183, 1, 0, 0, 0, 166, 2207, 1, 0, 0, 0, 168,
		2228, 1, 0, 0, 0, 170, 2231, 1, 0, 0, 0, 172, 2246, 1, 0, 0, 0, 174, 2260,
		1, 0, 0, 0, 176, 2275, 1, 0, 0, 0, 178, 2290, 1, 0, 0, 0, 180, 2314, 1,
		0, 0, 0, 182, 2328, 1, 0, 0, 0, 184, 2330, 1, 0, 0, 0, 186, 2342, 1, 0,
		0, 0, 188, 2349, 1, 0, 0, 0, 190, 2351, 1, 0, 0, 0, 192, 2369, 1, 0, 0,
		0, 194, 2371, 1, 0, 0, 0, 196, 2390, 1, 0, 0, 0, 198, 2392, 1, 0, 0, 0,
		200, 2436, 1, 0, 0, 0, 202, 2449, 1, 0, 0, 0, 204, 2461, 1, 0, 0, 0, 206,
		2475, 1, 0, 0, 0, 208, 2519, 1, 0, 0, 0, 210, 2566, 1, 0, 0, 0, 212, 2615,
		1, 0, 0, 0, 214, 2617, 1, 0, 0, 0, 216, 2633, 1, 0, 0, 0, 218, 2679, 1,
		0, 0, 0, 220, 2683, 1, 0, 0, 0, 222, 2685, 1, 0, 0, 0, 224, 2695, 1, 0,
		0, 0, 226, 2706, 1, 0, 0, 0, 228, 2708, 1, 0, 0, 0, 230, 2724, 1, 0, 0,
		0, 232, 2726, 1, 0, 0, 0, 234, 2742, 1, 0, 0, 0, 236, 2776, 1, 0, 0, 0,
		238, 2823, 1, 0, 0, 0, 240, 2826, 1, 0, 0, 0, 242, 2895, 1, 0, 0, 0, 244,
		2898, 1, 0, 0, 0, 246, 2938, 1, 0, 0, 0, 248, 2964, 1, 0, 0, 0, 250, 2966,
		1, 0, 0, 0, 252, 3027, 1, 0, 0, 0, 254, 3066, 1, 0, 0, 0, 256, 3173, 1,
		0, 0, 0, 258, 3178, 1, 0, 0, 0, 260, 3180, 1, 0, 0, 0, 262, 3189, 1, 0,
		0, 0, 264, 3198, 1, 0, 0, 0, 266, 3235, 1, 0, 0, 0, 268, 3270, 1, 0, 0,
		0, 270, 3295, 1, 0, 0, 0, 272, 3298, 1, 0, 0, 0, 274, 3311, 1, 0, 0, 0,
		276, 3313, 1, 0, 0, 0, 278, 3315, 1, 0, 0, 0, 280, 3317, 1, 0, 0, 0, 282,
		3319, 1, 0, 0, 0, 284, 3321, 1, 0, 0, 0, 286, 3323, 1, 0, 0, 0, 288, 3325,
		1, 0, 0, 0, 290, 3332, 1, 0, 0, 0, 292, 3338, 1, 0, 0, 0, 294, 3340, 1,
		0, 0, 0, 296, 3357, 1, 0, 0, 0, 298, 3359, 1, 0, 0, 0, 300, 3364, 1, 0,
		0, 0, 302, 3370, 1, 0, 0, 0, 304, 3382, 1, 0, 0, 0, 306, 3391, 1, 0, 0,
		0, 308, 3403, 1, 0, 0, 0, 310, 3405, 1, 0, 0, 0, 312, 3407, 1, 0, 0, 0,
		314, 3409, 1, 0, 0, 0, 316, 3411, 1, 0, 0, 0, 318, 3414, 1, 0, 0, 0, 320,
		3433, 1, 0, 0, 0, 322, 3435, 1, 0, 0, 0, 324, 3437, 1, 0, 0, 0, 326, 3439,
		1, 0, 0, 0, 328, 3441, 1, 0, 0, 0, 330, 3443, 1, 0, 0, 0, 332, 3445, 1,
		0, 0, 0, 334, 3449, 1, 0, 0, 0, 336, 3466, 1, 0, 0, 0, 338, 3479, 1, 0,
		0, 0, 340, 3489, 1, 0, 0, 0, 342, 3501, 1, 0, 0, 0, 344, 3503, 1, 0, 0,
		0, 346, 3505, 1, 0, 0, 0, 348, 350, 3, 4, 2, 0, 349, 348, 1, 0, 0, 0, 349,
		350, 1, 0, 0, 0, 350, 354, 1, 0, 0, 0, 351, 353, 5, 5, 0, 0, 352, 351,
		1, 0, 0, 0, 353, 356, 1, 0, 0, 0, 354, 352, 1, 0, 0, 0, 354, 355, 1, 0,
		0, 0, 355, 360, 1, 0, 0, 0, 356, 354, 1, 0, 0, 0, 357, 359, 3, 6, 3, 0,
		358, 357, 1, 0, 0, 0, 359, 362, 1, 0, 0, 0, 360, 358, 1, 0, 0, 0, 360,
		361, 1, 0, 0, 0, 361, 363, 1, 0, 0, 0, 362, 360, 1, 0, 0, 0, 363, 364,
		3, 8, 4, 0, 364, 368, 3, 10, 5, 0, 365, 367, 3, 16, 8, 0, 366, 365, 1,
		0, 0, 0, 367, 370, 1, 0, 0, 0, 368, 366, 1, 0, 0, 0, 368, 369, 1, 0, 0,
		0, 369, 371, 1, 0, 0, 0, 370, 368, 1, 0, 0, 0, 371, 372, 5, 0, 0, 1, 372,
		1, 1, 0, 0, 0, 373, 375, 3, 4, 2, 0, 374, 373, 1, 0, 0, 0, 374, 375, 1,
		0, 0, 0, 375, 379, 1, 0, 0, 0, 376, 378, 5, 5, 0, 0, 377, 376, 1, 0, 0,
		0, 378, 381, 1, 0, 0, 0, 379, 377, 1, 0, 0, 0, 379, 380, 1, 0, 0, 0, 380,
		385, 1, 0, 0, 0, 381, 379, 1, 0, 0, 0, 382, 384, 3, 6, 3, 0, 383, 382,
		1, 0, 0, 0, 384, 387, 1, 0, 0, 0, 385, 383, 1, 0, 0, 0, 385, 386, 1, 0,
		0, 0, 386, 388, 1, 0, 0, 0, 387, 385, 1, 0, 0, 0, 388, 389, 3, 8, 4, 0,
		389, 395, 3, 10, 5, 0, 390, 391, 3, 130, 65, 0, 391, 392, 3, 148, 74, 0,
		392, 394, 1, 0, 0, 0, 393, 390, 1, 0, 0, 0, 394, 397, 1, 0, 0, 0, 395,
		393, 1, 0, 0, 0, 395, 396, 1, 0, 0, 0, 396, 398, 1, 0, 0, 0, 397, 395,
		1, 0, 0, 0, 398, 399, 5, 0, 0, 1, 399, 3, 1, 0, 0, 0, 400, 402, 5, 1, 0,
		0, 401, 403, 5, 5, 0, 0, 402, 401, 1, 0, 0, 0, 403, 404, 1, 0, 0, 0, 404,
		402, 1, 0, 0, 0, 404, 405, 1, 0, 0, 0, 405, 5, 1, 0, 0, 0, 406, 407, 7,
		0, 0, 0, 407, 411, 5, 63, 0, 0, 408, 410, 5, 5, 0, 0, 409, 408, 1, 0, 0,
		0, 410, 413, 1, 0, 0, 0, 411, 409, 1, 0, 0, 0, 411, 412, 1, 0, 0, 0, 412,
		414, 1, 0, 0, 0, 413, 411, 1, 0, 0, 0, 414, 418, 5, 26, 0, 0, 415, 417,
		5, 5, 0, 0, 416, 415, 1, 0, 0, 0, 417, 420, 1, 0, 0, 0, 418, 416, 1, 0,
		0, 0, 418, 419, 1, 0, 0, 0, 419, 430, 1, 0, 0, 0, 420, 418, 1, 0, 0, 0,
		421, 423, 5, 11, 0, 0, 422, 424, 3, 342, 171, 0, 423, 422, 1, 0, 0, 0,
		424, 425, 1, 0, 0, 0, 425, 423, 1, 0, 0, 0, 425, 426, 1, 0, 0, 0, 426,
		427, 1, 0, 0, 0, 427, 428, 5, 12, 0, 0, 428, 431, 1, 0, 0, 0, 429, 431,
		3, 342, 171, 0, 430, 421, 1, 0, 0, 0, 430, 429, 1, 0, 0, 0, 431, 435, 1,
		0, 0, 0, 432, 434, 5, 5, 0, 0, 433, 432, 1, 0, 0, 0, 434, 437, 1, 0, 0,
		0, 435, 433, 1, 0, 0, 0, 435, 436, 1, 0, 0, 0, 436, 7, 1, 0, 0, 0, 437,
		435, 1, 0, 0, 0, 438, 439, 5, 72, 0, 0, 439, 441, 3, 346, 173, 0, 440,
		442, 3, 148, 74, 0, 441, 440, 1, 0, 0, 0, 441, 442, 1, 0, 0, 0, 442, 444,
		1, 0, 0, 0, 443, 438, 1, 0, 0, 0, 443, 444, 1, 0, 0, 0, 444, 9, 1, 0, 0,
		0, 445, 447, 3, 12, 6, 0, 446, 445, 1, 0, 0, 0, 447, 450, 1, 0, 0, 0, 448,
		446, 1, 0, 0, 0, 448, 449, 1, 0, 0, 0, 449, 11, 1, 0, 0, 0, 450, 448, 1,
		0, 0, 0, 451, 452, 5, 73, 0, 0, 452, 456, 3, 346, 173, 0, 453, 454, 5,
		7, 0, 0, 454, 457, 5, 15, 0, 0, 455, 457, 3, 14, 7, 0, 456, 453, 1, 0,
		0, 0, 456, 455, 1, 0, 0, 0, 456, 457, 1, 0, 0, 0, 457, 459, 1, 0, 0, 0,
		458, 460, 3, 148, 74, 0, 459, 458, 1, 0, 0, 0, 459, 460, 1, 0, 0, 0, 460,
		13, 1, 0, 0, 0, 461, 462, 5, 102, 0, 0, 462, 463, 3, 344, 172, 0, 463,
		15, 1, 0, 0, 0, 464, 466, 3, 20, 10, 0, 465, 467, 3, 150, 75, 0, 466, 465,
		1, 0, 0, 0, 466, 467, 1, 0, 0, 0, 467, 17, 1, 0, 0, 0, 468, 470, 3, 300,
		150, 0, 469, 468, 1, 0, 0, 0, 469, 470, 1, 0, 0, 0, 470, 471, 1, 0, 0,
		0, 471, 475, 5, 80, 0, 0, 472, 474, 5, 5, 0, 0, 473, 472, 1, 0, 0, 0, 474,
		477, 1, 0, 0, 0, 475, 473, 1, 0, 0, 0, 475, 476, 1, 0, 0, 0, 476, 478,
		1, 0, 0, 0, 477, 475, 1, 0, 0, 0, 478, 486, 3, 344, 172, 0, 479, 481, 5,
		5, 0, 0, 480, 479, 1, 0, 0, 0, 481, 484, 1, 0, 0, 0, 482, 480, 1, 0, 0,
		0, 482, 483, 1, 0, 0, 0, 483, 485, 1, 0, 0, 0, 484, 482, 1, 0, 0, 0, 485,
		487, 3, 42, 21, 0, 486, 482, 1, 0, 0, 0, 486, 487, 1, 0, 0, 0, 487, 491,
		1, 0, 0, 0, 488, 490, 5, 5, 0, 0, 489, 488, 1, 0, 0, 0, 490, 493, 1, 0,
		0, 0, 491, 489, 1, 0, 0, 0, 491, 492, 1, 0, 0, 0, 492, 494, 1, 0, 0, 0,
		493, 491, 1, 0, 0, 0, 494, 498, 5, 28, 0, 0, 495, 497, 5, 5, 0, 0, 496,
		495, 1, 0, 0, 0, 497, 500, 1, 0, 0, 0, 498, 496, 1, 0, 0, 0, 498, 499,
		1, 0, 0, 0, 499, 501, 1, 0, 0, 0, 500, 498, 1, 0, 0, 0, 501, 502, 3, 98,
		49, 0, 502, 19, 1, 0, 0, 0, 503, 509, 3, 22, 11, 0, 504, 509, 3, 86, 43,
		0, 505, 509, 3, 62, 31, 0, 506, 509, 3, 70, 35, 0, 507, 509, 3, 18, 9,
		0, 508, 503, 1, 0, 0, 0, 508, 504, 1, 0, 0, 0, 508, 505, 1, 0, 0, 0, 508,
		506, 1, 0, 0, 0, 508, 507, 1, 0, 0, 0, 509, 21, 1, 0, 0, 0, 510, 512, 3,
		300, 150, 0, 511, 510, 1, 0, 0, 0, 511, 512, 1, 0, 0, 0, 512, 524, 1, 0,
		0, 0, 513, 525, 5, 74, 0, 0, 514, 518, 5, 76, 0, 0, 515, 517, 5, 5, 0,
		0, 516, 515, 1, 0, 0, 0, 517, 520, 1, 0, 0, 0, 518, 516, 1, 0, 0, 0, 518,
		519, 1, 0, 0, 0, 519, 522, 1, 0, 0, 0, 520, 518, 1, 0, 0, 0, 521, 514,
		1, 0, 0, 0, 521, 522, 1, 0, 0, 0, 522, 523, 1, 0, 0, 0, 523, 525, 5, 75,
		0, 0, 524, 513, 1, 0, 0, 0, 524, 521, 1, 0, 0, 0, 525, 529, 1, 0, 0, 0,
		526, 528, 5, 5, 0, 0, 527, 526, 1, 0, 0, 0, 528, 531, 1, 0, 0, 0, 529,
		527, 1, 0, 0, 0, 529, 530, 1, 0, 0, 0, 530, 532, 1, 0, 0, 0, 531, 529,
		1, 0, 0, 0, 532, 540, 3, 344, 172, 0, 533, 535, 5, 5, 0, 0, 534, 533, 1,
		0, 0, 0, 535, 538, 1, 0, 0, 0, 536, 534, 1, 0, 0, 0, 536, 537, 1, 0, 0,
		0, 537, 539, 1, 0, 0, 0, 538, 536, 1, 0, 0, 0, 539, 541, 3, 42, 21, 0,
		540, 536, 1, 0, 0, 0, 540, 541, 1, 0, 0, 0, 541, 549, 1, 0, 0, 0, 542,
		544, 5, 5, 0, 0, 543, 542, 1, 0, 0, 0, 544, 547, 1, 0, 0, 0, 545, 543,
		1, 0, 0, 0, 545, 546, 1, 0, 0, 0, 546, 548, 1, 0, 0, 0, 547, 545, 1, 0,
		0, 0, 548, 550, 3, 24, 12, 0, 549, 545, 1, 0, 0, 0, 549, 550, 1, 0, 0,
		0, 550, 565, 1, 0, 0, 0, 551, 553, 5, 5, 0, 0, 552, 551, 1, 0, 0, 0, 553,
		556, 1, 0, 0, 0, 554, 552, 1, 0, 0, 0, 554, 555, 1, 0, 0, 0, 555, 557,
		1, 0, 0, 0, 556, 554, 1, 0, 0, 0, 557, 561, 5, 26, 0, 0, 558, 560, 5, 5,
		0, 0, 559, 558, 1, 0, 0, 0, 560, 563, 1, 0, 0, 0, 561, 559, 1, 0, 0, 0,
		561, 562, 1, 0, 0, 0, 562, 564, 1, 0, 0, 0, 563, 561, 1, 0, 0, 0, 564,
		566, 3, 32, 16, 0, 565, 554, 1, 0, 0, 0, 565, 566, 1, 0, 0, 0, 566, 574,
		1, 0, 0, 0, 567, 569, 5, 5, 0, 0, 568, 567, 1, 0, 0, 0, 569, 572, 1, 0,
		0, 0, 570, 568, 1, 0, 0, 0, 570, 571, 1, 0, 0, 0, 571, 573, 1, 0, 0, 0,
		572, 570, 1, 0, 0, 0, 573, 575, 3, 46, 23, 0, 574, 570, 1, 0, 0, 0, 574,
		575, 1, 0, 0, 0, 575, 590, 1, 0, 0, 0, 576, 578, 5, 5, 0, 0, 577, 576,
		1, 0, 0, 0, 578, 581, 1, 0, 0, 0, 579, 577, 1, 0, 0, 0, 579, 580, 1, 0,
		0, 0, 580, 582, 1, 0, 0, 0, 581, 579, 1, 0, 0, 0, 582, 591, 3, 26, 13,
		0, 583, 585, 5, 5, 0, 0, 584, 583, 1, 0, 0, 0, 585, 588, 1, 0, 0, 0, 586,
		584, 1, 0, 0, 0, 586, 587, 1, 0, 0, 0, 587, 589, 1, 0, 0, 0, 588, 586,
		1, 0, 0, 0, 589, 591, 3, 92, 46, 0, 590, 579, 1, 0, 0, 0, 590, 586, 1,
		0, 0, 0, 590, 591, 1, 0, 0, 0, 591, 23, 1, 0, 0, 0, 592, 594, 3, 300, 150,
		0, 593, 592, 1, 0, 0, 0, 593, 594, 1, 0, 0, 0, 594, 595, 1, 0, 0, 0, 595,
		599, 5, 81, 0, 0, 596, 598, 5, 5, 0, 0, 597, 596, 1, 0, 0, 0, 598, 601,
		1, 0, 0, 0, 599, 597, 1, 0, 0, 0, 599, 600, 1, 0, 0, 0, 600, 603, 1, 0,
		0, 0, 601, 599, 1, 0, 0, 0, 602, 593, 1, 0, 0, 0, 602, 603, 1, 0, 0, 0,
		603, 604, 1, 0, 0, 0, 604, 605, 3, 28, 14, 0, 605, 25, 1, 0, 0, 0, 606,
		610, 5, 13, 0, 0, 607, 609, 5, 5, 0, 0, 608, 607, 1, 0, 0, 0, 609, 612,
		1, 0, 0, 0, 610, 608, 1, 0, 0, 0, 610, 611, 1, 0, 0, 0, 611, 613, 1, 0,
		0, 0, 612, 610, 1, 0, 0, 0, 613, 617, 3, 50, 25, 0, 614, 616, 5, 5, 0,
		0, 615, 614, 1, 0, 0, 0, 616, 619, 1, 0, 0, 0, 617, 615, 1, 0, 0, 0, 617,
		618, 1, 0, 0, 0, 618, 620, 1, 0, 0, 0, 619, 617, 1, 0, 0, 0, 620, 621,
		5, 14, 0, 0, 621, 27, 1, 0, 0, 0, 622, 626, 5, 9, 0, 0, 623, 625, 5, 5,
		0, 0, 624, 623, 1, 0, 0, 0, 625, 628, 1, 0, 0, 0, 626, 624, 1, 0, 0, 0,
		626, 627, 1, 0, 0, 0, 627, 658, 1, 0, 0, 0, 628, 626, 1, 0, 0, 0, 629,
		646, 3, 30, 15, 0, 630, 632, 5, 5, 0, 0, 631, 630, 1, 0, 0, 0, 632, 635,
		1, 0, 0, 0, 633, 631, 1, 0, 0, 0, 633, 634, 1, 0, 0, 0, 634, 636, 1, 0,
		0, 0, 635, 633, 1, 0, 0, 0, 636, 640, 5, 8, 0, 0, 637, 639, 5, 5, 0, 0,
		638, 637, 1, 0, 0, 0, 639, 642, 1, 0, 0, 0, 640, 638, 1, 0, 0, 0, 640,
		641, 1, 0, 0, 0, 641, 643, 1, 0, 0, 0, 642, 640, 1, 0, 0, 0, 643, 645,
		3, 30, 15, 0, 644, 633, 1, 0, 0, 0, 645, 648, 1, 0, 0, 0, 646, 644, 1,
		0, 0, 0, 646, 647, 1, 0, 0, 0, 647, 656, 1, 0, 0, 0, 648, 646, 1, 0, 0,
		0, 649, 651, 5, 5, 0, 0, 650, 649, 1, 0, 0, 0, 651, 654, 1, 0, 0, 0, 652,
		650, 1, 0, 0, 0, 652, 653, 1, 0, 0, 0, 653, 655, 1, 0, 0, 0, 654, 652,
		1, 0, 0, 0, 655, 657, 5, 8, 0, 0, 656, 652, 1, 0, 0, 0, 656, 657, 1, 0,
		0, 0, 657, 659, 1, 0, 0, 0, 658, 629, 1, 0, 0, 0, 658, 659, 1, 0, 0, 0,
		659, 663, 1, 0, 0, 0, 660, 662, 5, 5, 0, 0, 661, 660, 1, 0, 0, 0, 662,
		665, 1, 0, 0, 0, 663, 661, 1, 0, 0, 0, 663, 664, 1, 0, 0, 0, 664, 666,
		1, 0, 0, 0, 665, 663, 1, 0, 0, 0, 666, 667, 5, 10, 0, 0, 667, 29, 1, 0,
		0, 0, 668, 670, 3, 300, 150, 0, 669, 668, 1, 0, 0, 0, 669, 670, 1, 0, 0,
		0, 670, 672, 1, 0, 0, 0, 671, 673, 7, 1, 0, 0, 672, 671, 1, 0, 0, 0, 672,
		673, 1, 0, 0, 0, 673, 677, 1, 0, 0, 0, 674, 676, 5, 5, 0, 0, 675, 674,
		1, 0, 0, 0, 676, 679, 1, 0, 0, 0, 677, 675, 1, 0, 0, 0, 677, 678, 1, 0,
		0, 0, 678, 680, 1, 0, 0, 0, 679, 677, 1, 0, 0, 0, 680, 681, 3, 344, 172,
		0, 681, 685, 5, 26, 0, 0, 682, 684, 5, 5, 0, 0, 683, 682, 1, 0, 0, 0, 684,
		687, 1, 0, 0, 0, 685, 683, 1, 0, 0, 0, 685, 686, 1, 0, 0, 0, 686, 688,
		1, 0, 0, 0, 687, 685, 1, 0, 0, 0, 688, 703, 3, 98, 49, 0, 689, 691, 5,
		5, 0, 0, 690, 689, 1, 0, 0, 0, 691, 694, 1, 0, 0, 0, 692, 690, 1, 0, 0,
		0, 692, 693, 1, 0, 0, 0, 693, 695, 1, 0, 0, 0, 694, 692, 1, 0, 0, 0, 695,
		699, 5, 28, 0, 0, 696, 698, 5, 5, 0, 0, 697, 696, 1, 0, 0, 0, 698, 701,
		1, 0, 0, 0, 699, 697, 1, 0, 0, 0, 699, 700, 1, 0, 0, 0, 700, 702, 1, 0,
		0, 0, 701, 699, 1, 0, 0, 0, 702, 704, 3, 152, 76, 0, 703, 692, 1, 0, 0,
		0, 703, 704, 1, 0, 0, 0, 704, 31, 1, 0, 0, 0, 705, 722, 3, 38, 19, 0, 706,
		708, 5, 5, 0, 0, 707, 706, 1, 0, 0, 0, 708, 711, 1, 0, 0, 0, 709, 707,
		1, 0, 0, 0, 709, 710, 1, 0, 0, 0, 710, 712, 1, 0, 0, 0, 711, 709, 1, 0,
		0, 0, 712, 716, 5, 8, 0, 0, 713, 715, 5, 5, 0, 0, 714, 713, 1, 0, 0, 0,
		715, 718, 1, 0, 0, 0, 716, 714, 1, 0, 0, 0, 716, 717, 1, 0, 0, 0, 717,
		719, 1, 0, 0, 0, 718, 716, 1, 0, 0, 0, 719, 721, 3, 38, 19, 0, 720, 709,
		1, 0, 0, 0, 721, 724, 1, 0, 0, 0, 722, 720, 1, 0, 0, 0, 722, 723, 1, 0,
		0, 0, 723, 33, 1, 0, 0, 0, 724, 722, 1, 0, 0, 0, 725, 738, 3, 36, 18, 0,
		726, 738, 3, 40, 20, 0, 727, 738, 3, 106, 53, 0, 728, 738, 3, 116, 58,
		0, 729, 733, 5, 124, 0, 0, 730, 732, 5, 5, 0, 0, 731, 730, 1, 0, 0, 0,
		732, 735, 1, 0, 0, 0, 733, 731, 1, 0, 0, 0, 733, 734, 1, 0, 0, 0, 734,
		736, 1, 0, 0, 0, 735, 733, 1, 0, 0, 0, 736, 738, 3, 116, 58, 0, 737, 725,
		1, 0, 0, 0, 737, 726, 1, 0, 0, 0, 737, 727, 1, 0, 0, 0, 737, 728, 1, 0,
		0, 0, 737, 729, 1, 0, 0, 0, 738, 35, 1, 0, 0, 0, 739, 743, 3, 106, 53,
		0, 740, 742, 5, 5, 0, 0, 741, 740, 1, 0, 0, 0, 742, 745, 1, 0, 0, 0, 743,
		741, 1, 0, 0, 0, 743, 744, 1, 0, 0, 0, 744, 746, 1, 0, 0, 0, 745, 743,
		1, 0, 0, 0, 746, 747, 3, 208, 104, 0, 747, 37, 1, 0, 0, 0, 748, 750, 3,
		334, 167, 0, 749, 748, 1, 0, 0, 0, 750, 753, 1, 0, 0, 0, 751, 749, 1, 0,
		0, 0, 751, 752, 1, 0, 0, 0, 752, 757, 1, 0, 0, 0, 753, 751, 1, 0, 0, 0,
		754, 756, 5, 5, 0, 0, 755, 754, 1, 0, 0, 0, 756, 759, 1, 0, 0, 0, 757,
		755, 1, 0, 0, 0, 757, 758, 1, 0, 0, 0, 758, 760, 1, 0, 0, 0, 759, 757,
		1, 0, 0, 0, 760, 761, 3, 34, 17, 0, 761, 39, 1, 0, 0, 0, 762, 765, 3, 106,
		53, 0, 763, 765, 3, 116, 58, 0, 764, 762, 1, 0, 0, 0, 764, 763, 1, 0, 0,
		0, 765, 769, 1, 0, 0, 0, 766, 768, 5, 5, 0, 0, 767, 766, 1, 0, 0, 0, 768,
		771, 1, 0, 0, 0, 769, 767, 1, 0, 0, 0, 769, 770, 1, 0, 0, 0, 770, 772,
		1, 0, 0, 0, 771, 769, 1, 0, 0, 0, 772, 776, 5, 82, 0, 0, 773, 775, 5, 5,
		0, 0, 774, 773, 1, 0, 0, 0, 775, 778, 1, 0, 0, 0, 776, 774, 1, 0, 0, 0,
		776, 777, 1, 0, 0, 0, 777, 779, 1, 0, 0, 0, 778, 776, 1, 0, 0, 0, 779,
		780, 3, 152, 76, 0, 780, 41, 1, 0, 0, 0, 781, 785, 5, 47, 0, 0, 782, 784,
		5, 5, 0, 0, 783, 782, 1, 0, 0, 0, 784, 787, 1, 0, 0, 0, 785, 783, 1, 0,
		0, 0, 785, 786, 1, 0, 0, 0, 786, 788, 1, 0, 0, 0, 787, 785, 1, 0, 0, 0,
		788, 805, 3, 44, 22, 0, 789, 791, 5, 5, 0, 0, 790, 789, 1, 0, 0, 0, 791,
		794, 1, 0, 0, 0, 792, 790, 1, 0, 0, 0, 792, 793, 1, 0, 0, 0, 793, 795,
		1, 0, 0, 0, 794, 792, 1, 0, 0, 0, 795, 799, 5, 8, 0, 0, 796, 798, 5, 5,
		0, 0, 797, 796, 1, 0, 0, 0, 798, 801, 1, 0, 0, 0, 799, 797, 1, 0, 0, 0,
		799, 800, 1, 0, 0, 0, 800, 802, 1, 0, 0, 0, 801, 799, 1, 0, 0, 0, 802,
		804, 3, 44, 22, 0, 803, 792, 1, 0, 0, 0, 804, 807, 1, 0, 0, 0, 805, 803,
		1, 0, 0, 0, 805, 806, 1, 0, 0, 0, 806, 815, 1, 0, 0, 0, 807, 805, 1, 0,
		0, 0, 808, 810, 5, 5, 0, 0, 809, 808, 1, 0, 0, 0, 810, 813, 1, 0, 0, 0,
		811, 809, 1, 0, 0, 0, 811, 812, 1, 0, 0, 0, 812, 814, 1, 0, 0, 0, 813,
		811, 1, 0, 0, 0, 814, 816, 5, 8, 0, 0, 815, 811, 1, 0, 0, 0, 815, 816,
		1, 0, 0, 0, 816, 820, 1, 0, 0, 0, 817, 819, 5, 5, 0, 0, 818, 817, 1, 0,
		0, 0, 819, 822, 1, 0, 0, 0, 820, 818, 1, 0, 0, 0, 820, 821, 1, 0, 0, 0,
		821, 823, 1, 0, 0, 0, 822, 820, 1, 0, 0, 0, 823, 824, 5, 48, 0, 0, 824,
		43, 1, 0, 0, 0, 825, 827, 3, 318, 159, 0, 826, 825, 1, 0, 0, 0, 826, 827,
		1, 0, 0, 0, 827, 831, 1, 0, 0, 0, 828, 830, 5, 5, 0, 0, 829, 828, 1, 0,
		0, 0, 830, 833, 1, 0, 0, 0, 831, 829, 1, 0, 0, 0, 831, 832, 1, 0, 0, 0,
		832, 834, 1, 0, 0, 0, 833, 831, 1, 0, 0, 0, 834, 849, 3, 344, 172, 0, 835,
		837, 5, 5, 0, 0, 836, 835, 1, 0, 0, 0, 837, 840, 1, 0, 0, 0, 838, 836,
		1, 0, 0, 0, 838, 839, 1, 0, 0, 0, 839, 841, 1, 0, 0, 0, 840, 838, 1, 0,
		0, 0, 841, 845, 5, 26, 0, 0, 842, 844, 5, 5, 0, 0, 843, 842, 1, 0, 0, 0,
		844, 847, 1, 0, 0, 0, 845, 843, 1, 0, 0, 0, 845, 846, 1, 0, 0, 0, 846,
		848, 1, 0, 0, 0, 847, 845, 1, 0, 0, 0, 848, 850, 3, 98, 49, 0, 849, 838,
		1, 0, 0, 0, 849, 850, 1, 0, 0, 0, 850, 45, 1, 0, 0, 0, 851, 855, 5, 88,
		0, 0, 852, 854, 5, 5, 0, 0, 853, 852, 1, 0, 0, 0, 854, 857, 1, 0, 0, 0,
		855, 853, 1, 0, 0, 0, 855, 856, 1, 0, 0, 0, 856, 858, 1, 0, 0, 0, 857,
		855, 1, 0, 0, 0, 858, 875, 3, 48, 24, 0, 859, 861, 5, 5, 0, 0, 860, 859,
		1, 0, 0, 0, 861, 864, 1, 0, 0, 0, 862, 860, 1, 0, 0, 0, 862, 863, 1, 0,
		0, 0, 863, 865, 1, 0, 0, 0, 864, 862, 1, 0, 0, 0, 865, 869, 5, 8, 0, 0,
		866, 868, 5, 5, 0, 0, 867, 866, 1, 0, 0, 0, 868, 871, 1, 0, 0, 0, 869,
		867, 1, 0, 0, 0, 869, 870, 1, 0, 0, 0, 870, 872, 1, 0, 0, 0, 871, 869,
		1, 0, 0, 0, 872, 874, 3, 48, 24, 0, 873, 862, 1, 0, 0, 0, 874, 877, 1,
		0, 0, 0, 875, 873, 1, 0, 0, 0, 875, 876, 1, 0, 0, 0, 876, 47, 1, 0, 0,
		0, 877, 875, 1, 0, 0, 0, 878, 880, 3, 334, 167, 0, 879, 878, 1, 0, 0, 0,
		880, 883, 1, 0, 0, 0, 881, 879, 1, 0, 0, 0, 881, 882, 1, 0, 0, 0, 882,
		884, 1, 0, 0, 0, 883, 881, 1, 0, 0, 0, 884, 888, 3, 344, 172, 0, 885, 887,
		5, 5, 0, 0, 886, 885, 1, 0, 0, 0, 887, 890, 1, 0, 0, 0, 888, 886, 1, 0,
		0, 0, 888, 889, 1, 0, 0, 0, 889, 891, 1, 0, 0, 0, 890, 888, 1, 0, 0, 0,
		891, 895, 5, 26, 0, 0, 892, 894, 5, 5, 0, 0, 893, 892, 1, 0, 0, 0, 894,
		897, 1, 0, 0, 0, 895, 893, 1, 0, 0, 0, 895, 896, 1, 0, 0, 0, 896, 898,
		1, 0, 0, 0, 897, 895, 1, 0, 0, 0, 898, 899, 3, 98, 49, 0, 899, 49, 1, 0,
		0, 0, 900, 902, 3, 52, 26, 0, 901, 903, 3, 150, 75, 0, 902, 901, 1, 0,
		0, 0, 902, 903, 1, 0, 0, 0, 903, 905, 1, 0, 0, 0, 904, 900, 1, 0, 0, 0,
		905, 908, 1, 0, 0, 0, 906, 904, 1, 0, 0, 0, 906, 907, 1, 0, 0, 0, 907,
		51, 1, 0, 0, 0, 908, 906, 1, 0, 0, 0, 909, 914, 3, 20, 10, 0, 910, 914,
		3, 56, 28, 0, 911, 914, 3, 54, 27, 0, 912, 914, 3, 88, 44, 0, 913, 909,
		1, 0, 0, 0, 913, 910, 1, 0, 0, 0, 913, 911, 1, 0, 0, 0, 913, 912, 1, 0,
		0, 0, 914, 53, 1, 0, 0, 0, 915, 919, 5, 84, 0, 0, 916, 918, 5, 5, 0, 0,
		917, 916, 1, 0, 0, 0, 918, 921, 1, 0, 0, 0, 919, 917, 1, 0, 0, 0, 919,
		920, 1, 0, 0, 0, 920, 922, 1, 0, 0, 0, 921, 919, 1, 0, 0, 0, 922, 923,
		3, 136, 68, 0, 923, 55, 1, 0, 0, 0, 924, 926, 3, 300, 150, 0, 925, 924,
		1, 0, 0, 0, 925, 926, 1, 0, 0, 0, 926, 927, 1, 0, 0, 0, 927, 931, 5, 83,
		0, 0, 928, 930, 5, 5, 0, 0, 929, 928, 1, 0, 0, 0, 930, 933, 1, 0, 0, 0,
		931, 929, 1, 0, 0, 0, 931, 932, 1, 0, 0, 0, 932, 935, 1, 0, 0, 0, 933,
		931, 1, 0, 0, 0, 934, 936, 5, 116, 0, 0, 935, 934, 1, 0, 0, 0, 935, 936,
		1, 0, 0, 0, 936, 940, 1, 0, 0, 0, 937, 939, 5, 5, 0, 0, 938, 937, 1, 0,
		0, 0, 939, 942, 1, 0, 0, 0, 940, 938, 1, 0, 0, 0, 940, 941, 1, 0, 0, 0,
		941, 943, 1, 0, 0, 0, 942, 940, 1, 0, 0, 0, 943, 951, 5, 77, 0, 0, 944,
		946, 5, 5, 0, 0, 945, 944, 1, 0, 0, 0, 946, 949, 1, 0, 0, 0, 947, 945,
		1, 0, 0, 0, 947, 948, 1, 0, 0, 0, 948, 950, 1, 0, 0, 0, 949, 947, 1, 0,
		0, 0, 950, 952, 3, 344, 172, 0, 951, 947, 1, 0, 0, 0, 951, 952, 1, 0, 0,
		0, 952, 967, 1, 0, 0, 0, 953, 955, 5, 5, 0, 0, 954, 953, 1, 0, 0, 0, 955,
		958, 1, 0, 0, 0, 956, 954, 1, 0, 0, 0, 956, 957, 1, 0, 0, 0, 957, 959,
		1, 0, 0, 0, 958, 956, 1, 0, 0, 0, 959, 963, 5, 26, 0, 0, 960, 962, 5, 5,
		0, 0, 961, 960, 1, 0, 0, 0, 962, 965, 1, 0, 0, 0, 963, 961, 1, 0, 0, 0,
		963, 964, 1, 0, 0, 0, 964, 966, 1, 0, 0, 0, 965, 963, 1, 0, 0, 0, 966,
		968, 3, 32, 16, 0, 967, 956, 1, 0, 0, 0, 967, 968, 1, 0, 0, 0, 968, 976,
		1, 0, 0, 0, 969, 971, 5, 5, 0, 0, 970, 969, 1, 0, 0, 0, 971, 974, 1, 0,
		0, 0, 972, 970, 1, 0, 0, 0, 972, 973, 1, 0, 0, 0, 973, 975, 1, 0, 0, 0,
		974, 972, 1, 0, 0, 0, 975, 977, 3, 26, 13, 0, 976, 972, 1, 0, 0, 0, 976,
		977, 1, 0, 0, 0, 977, 57, 1, 0, 0, 0, 978, 982, 5, 9, 0, 0, 979, 981, 5,
		5, 0, 0, 980, 979, 1, 0, 0, 0, 981, 984, 1, 0, 0, 0, 982, 980, 1, 0, 0,
		0, 982, 983, 1, 0, 0, 0, 983, 1014, 1, 0, 0, 0, 984, 982, 1, 0, 0, 0, 985,
		1002, 3, 60, 30, 0, 986, 988, 5, 5, 0, 0, 987, 986, 1, 0, 0, 0, 988, 991,
		1, 0, 0, 0, 989, 987, 1, 0, 0, 0, 989, 990, 1, 0, 0, 0, 990, 992, 1, 0,
		0, 0, 991, 989, 1, 0, 0, 0, 992, 996, 5, 8, 0, 0, 993, 995, 5, 5, 0, 0,
		994, 993, 1, 0, 0, 0, 995, 998, 1, 0, 0, 0, 996, 994, 1, 0, 0, 0, 996,
		997, 1, 0, 0, 0, 997, 999, 1, 0, 0, 0, 998, 996, 1, 0, 0, 0, 999, 1001,
		3, 60, 30, 0, 1000, 989, 1, 0, 0, 0, 1001, 1004, 1, 0, 0, 0, 1002, 1000,
		1, 0, 0, 0, 1002, 1003, 1, 0, 0, 0, 1003, 1012, 1, 0, 0, 0, 1004, 1002,
		1, 0, 0, 0, 1005, 1007, 5, 5, 0, 0, 1006, 1005, 1, 0, 0, 0, 1007, 1010,
		1, 0, 0, 0, 1008, 1006, 1, 0, 0, 0, 1008, 1009, 1, 0, 0, 0, 1009, 1011,
		1, 0, 0, 0, 1010, 1008, 1, 0, 0, 0, 1011, 1013, 5, 8, 0, 0, 1012, 1008,
		1, 0, 0, 0, 1012, 1013, 1, 0, 0, 0, 1013, 1015, 1, 0, 0, 0, 1014, 985,
		1, 0, 0, 0, 1014, 1015, 1, 0, 0, 0, 1015, 1019, 1, 0, 0, 0, 1016, 1018,
		5, 5, 0, 0, 1017, 1016, 1, 0, 0, 0, 1018, 1021, 1, 0, 0, 0, 1019, 1017,
		1, 0, 0, 0, 1019, 1020, 1, 0, 0, 0, 1020, 1022, 1, 0, 0, 0, 1021, 1019,
		1, 0, 0, 0, 1022, 1023, 5, 10, 0, 0, 1023, 59, 1, 0, 0, 0, 1024, 1026,
		3, 302, 151, 0, 1025, 1024, 1, 0, 0, 0, 1025, 1026, 1, 0, 0, 0, 1026, 1027,
		1, 0, 0, 0, 1027, 1042, 3, 84, 42, 0, 1028, 1030, 5, 5, 0, 0, 1029, 1028,
		1, 0, 0, 0, 1030, 1033, 1, 0, 0, 0, 1031, 1029, 1, 0, 0, 0, 1031, 1032,
		1, 0, 0, 0, 1032, 1034, 1, 0, 0, 0, 1033, 1031, 1, 0, 0, 0, 1034, 1038,
		5, 28, 0, 0, 1035, 1037, 5, 5, 0, 0, 1036, 1035, 1, 0, 0, 0, 1037, 1040,
		1, 0, 0, 0, 1038, 1036, 1, 0, 0, 0, 1038, 1039, 1, 0, 0, 0, 1039, 1041,
		1, 0, 0, 0, 1040, 1038, 1, 0, 0, 0, 1041, 1043, 3, 152, 76, 0, 1042, 1031,
		1, 0, 0, 0, 1042, 1043, 1, 0, 0, 0, 1043, 61, 1, 0, 0, 0, 1044, 1046, 3,
		300, 150, 0, 1045, 1044, 1, 0, 0, 0, 1045, 1046, 1, 0, 0, 0, 1046, 1047,
		1, 0, 0, 0, 1047, 1055, 5, 76, 0, 0, 1048, 1050, 5, 5, 0, 0, 1049, 1048,
		1, 0, 0, 0, 1050, 1053, 1, 0, 0, 0, 1051, 1049, 1, 0, 0, 0, 1051, 1052,
		1, 0, 0, 0, 1052, 1054, 1, 0, 0, 0, 1053, 1051, 1, 0, 0, 0, 1054, 1056,
		3, 42, 21, 0, 1055, 1051, 1, 0, 0, 0, 1055, 1056, 1, 0, 0, 0, 1056, 1072,
		1, 0, 0, 0, 1057, 1059, 5, 5, 0, 0, 1058, 1057, 1, 0, 0, 0, 1059, 1062,
		1, 0, 0, 0, 1060, 1058, 1, 0, 0, 0, 1060, 1061, 1, 0, 0, 0, 1061, 1063,
		1, 0, 0, 0, 1062, 1060, 1, 0, 0, 0, 1063, 1067, 3, 122, 61, 0, 1064, 1066,
		5, 5, 0, 0, 1065, 1064, 1, 0, 0, 0, 1066, 1069, 1, 0, 0, 0, 1067, 1065,
		1, 0, 0, 0, 1067, 1068, 1, 0, 0, 0, 1068, 1070, 1, 0, 0, 0, 1069, 1067,
		1, 0, 0, 0, 1070, 1071, 5, 7, 0, 0, 1071, 1073, 1, 0, 0, 0, 1072, 1060,
		1, 0, 0, 0, 1072, 1073, 1, 0, 0, 0, 1073, 1077, 1, 0, 0, 0, 1074, 1076,
		5, 5, 0, 0, 1075, 1074, 1, 0, 0, 0, 1076, 1079, 1, 0, 0, 0, 1077, 1075,
		1, 0, 0, 0, 1077, 1078, 1, 0, 0, 0, 1078, 1080, 1, 0, 0, 0, 1079, 1077,
		1, 0, 0, 0, 1080, 1084, 3, 344, 172, 0, 1081, 1083, 5, 5, 0, 0, 1082, 1081,
		1, 0, 0, 0, 1083, 1086, 1, 0, 0, 0, 1084, 1082, 1, 0, 0, 0, 1084, 1085,
		1, 0, 0, 0, 1085, 1087, 1, 0, 0, 0, 1086, 1084, 1, 0, 0, 0, 1087, 1102,
		3, 58, 29, 0, 1088, 1090, 5, 5, 0, 0, 1089, 1088, 1, 0, 0, 0, 1090, 1093,
		1, 0, 0, 0, 1091, 1089, 1, 0, 0, 0, 1091, 1092, 1, 0, 0, 0, 1092, 1094,
		1, 0, 0, 0, 1093, 1091, 1, 0, 0, 0, 1094, 1098, 5, 26, 0, 0, 1095, 1097,
		5, 5, 0, 0, 1096, 1095, 1, 0, 0, 0, 1097, 1100, 1, 0, 0, 0, 1098, 1096,
		1, 0, 0, 0, 1098, 1099, 1, 0, 0, 0, 1099, 1101, 1, 0, 0, 0, 1100, 1098,
		1, 0, 0, 0, 1101, 1103, 3, 98, 49, 0, 1102, 1091, 1, 0, 0, 0, 1102, 1103,
		1, 0, 0, 0, 1103, 1111, 1, 0, 0, 0, 1104, 1106, 5, 5, 0, 0, 1105, 1104,
		1, 0, 0, 0, 1106, 1109, 1, 0, 0, 0, 1107, 1105, 1, 0, 0, 0, 1107, 1108,
		1, 0, 0, 0, 1108, 1110, 1, 0, 0, 0, 1109, 1107, 1, 0, 0, 0, 1110, 1112,
		3, 46, 23, 0, 1111, 1107, 1, 0, 0, 0, 1111, 1112, 1, 0, 0, 0, 1112, 1120,
		1, 0, 0, 0, 1113, 1115, 5, 5, 0, 0, 1114, 1113, 1, 0, 0, 0, 1115, 1118,
		1, 0, 0, 0, 1116, 1114, 1, 0, 0, 0, 1116, 1117, 1, 0, 0, 0, 1117, 1119,
		1, 0, 0, 0, 1118, 1116, 1, 0, 0, 0, 1119, 1121, 3, 64, 32, 0, 1120, 1116,
		1, 0, 0, 0, 1120, 1121, 1, 0, 0, 0, 1121, 63, 1, 0, 0, 0, 1122, 1132, 3,
		136, 68, 0, 1123, 1127, 5, 28, 0, 0, 1124, 1126, 5, 5, 0, 0, 1125, 1124,
		1, 0, 0, 0, 1126, 1129, 1, 0, 0, 0, 1127, 1125, 1, 0, 0, 0, 1127, 1128,
		1, 0, 0, 0, 1128, 1130, 1, 0, 0, 0, 1129, 1127, 1, 0, 0, 0, 1130, 1132,
		3, 152, 76, 0, 1131, 1122, 1, 0, 0, 0, 1131, 1123, 1, 0, 0, 0, 1132, 65,
		1, 0, 0, 0, 1133, 1135, 3, 334, 167, 0, 1134, 1133, 1, 0, 0, 0, 1135, 1138,
		1, 0, 0, 0, 1136, 1134, 1, 0, 0, 0, 1136, 1137, 1, 0, 0, 0, 1137, 1142,
		1, 0, 0, 0, 1138, 1136, 1, 0, 0, 0, 1139, 1141, 5, 5, 0, 0, 1140, 1139,
		1, 0, 0, 0, 1141, 1144, 1, 0, 0, 0, 1142, 1140, 1, 0, 0, 0, 1142, 1143,
		1, 0, 0, 0, 1143, 1145, 1, 0, 0, 0, 1144, 1142, 1, 0, 0, 0, 1145, 1160,
		3, 344, 172, 0, 1146, 1148, 5, 5, 0, 0, 1147, 1146, 1, 0, 0, 0, 1148, 1151,
		1, 0, 0, 0, 1149, 1147, 1, 0, 0, 0, 1149, 1150, 1, 0, 0, 0, 1150, 1152,
		1, 0, 0, 0, 1151, 1149, 1, 0, 0, 0, 1152, 1156, 5, 26, 0, 0, 1153, 1155,
		5, 5, 0, 0, 1154, 1153, 1, 0, 0, 0, 1155, 1158, 1, 0, 0, 0, 1156, 1154,
		1, 0, 0, 0, 1156, 1157, 1, 0, 0, 0, 1157, 1159, 1, 0, 0, 0, 1158, 1156,
		1, 0, 0, 0, 1159, 1161, 3, 98, 49, 0, 1160, 1149, 1, 0, 0, 0, 1160, 1161,
		1, 0, 0, 0, 1161, 67, 1, 0, 0, 0, 1162, 1166, 5, 9, 0, 0, 1163, 1165, 5,
		5, 0, 0, 1164, 1163, 1, 0, 0, 0, 1165, 1168, 1, 0, 0, 0, 1166, 1164, 1,
		0, 0, 0, 1166, 1167, 1, 0, 0, 0, 1167, 1169, 1, 0, 0, 0, 1168, 1166, 1,
		0, 0, 0, 1169, 1186, 3, 66, 33, 0, 1170, 1172, 5, 5, 0, 0, 1171, 1170,
		1, 0, 0, 0, 1172, 1175, 1, 0, 0, 0, 1173, 1171, 1, 0, 0, 0, 1173, 1174,
		1, 0, 0, 0, 1174, 1176, 1, 0, 0, 0, 1175, 1173, 1, 0, 0, 0, 1176, 1180,
		5, 8, 0, 0, 1177, 1179, 5, 5, 0, 0, 1178, 1177, 1, 0, 0, 0, 1179, 1182,
		1, 0, 0, 0, 1180, 1178, 1, 0, 0, 0, 1180, 1181, 1, 0, 0, 0, 1181, 1183,
		1, 0, 0, 0, 1182, 1180, 1, 0, 0, 0, 1183, 1185, 3, 66, 33, 0, 1184, 1173,
		1, 0, 0, 0, 1185, 1188, 1, 0, 0, 0, 1186, 1184, 1, 0, 0, 0, 1186, 1187,
		1, 0, 0, 0, 1187, 1196, 1, 0, 0, 0, 1188, 1186, 1, 0, 0, 0, 1189, 1191,
		5, 5, 0, 0, 1190, 1189, 1, 0, 0, 0, 1191, 1194, 1, 0, 0, 0, 1192, 1190,
		1, 0, 0, 0, 1192, 1193, 1, 0, 0, 0, 1193, 1195, 1, 0, 0, 0, 1194, 1192,
		1, 0, 0, 0, 1195, 1197, 5, 8, 0, 0, 1196, 1192, 1, 0, 0, 0, 1196, 1197,
		1, 0, 0, 0, 1197, 1201, 1, 0, 0, 0, 1198, 1200, 5, 5, 0, 0, 1199, 1198,
		1, 0, 0, 0, 1200, 1203, 1, 0, 0, 0, 1201, 1199, 1, 0, 0, 0, 1201, 1202,
		1, 0, 0, 0, 1202, 1204, 1, 0, 0, 0, 1203, 1201, 1, 0, 0, 0, 1204, 1205,
		5, 10, 0, 0, 1205, 69, 1, 0, 0, 0, 1206, 1208, 3, 300, 150, 0, 1207, 1206,
		1, 0, 0, 0, 1207, 1208, 1, 0, 0, 0, 1208, 1209, 1, 0, 0, 0, 1209, 1217,
		7, 1, 0, 0, 1210, 1212, 5, 5, 0, 0, 1211, 1210, 1, 0, 0, 0, 1212, 1215,
		1, 0, 0, 0, 1213, 1211, 1, 0, 0, 0, 1213, 1214, 1, 0, 0, 0, 1214, 1216,
		1, 0, 0, 0, 1215, 1213, 1, 0, 0, 0, 1216, 1218, 3, 42, 21, 0, 1217, 1213,
		1, 0, 0, 0, 1217, 1218, 1, 0, 0, 0, 1218, 1234, 1, 0, 0, 0, 1219, 1221,
		5, 5, 0, 0, 1220, 1219, 1, 0, 0, 0, 1221, 1224, 1, 0, 0, 0, 1222, 1220,
		1, 0, 0, 0, 1222, 1223, 1, 0, 0, 0, 1223, 1225, 1, 0, 0, 0, 1224, 1222,
		1, 0, 0, 0, 1225, 1229, 3, 122, 61, 0, 1226, 1228, 5, 5, 0, 0, 1227, 1226,
		1, 0, 0, 0, 1228, 1231, 1, 0, 0, 0, 1229, 1227, 1, 0, 0, 0, 1229, 1230,
		1, 0, 0, 0, 1230, 1232, 1, 0, 0, 0, 1231, 1229, 1, 0, 0, 0, 1232, 1233,
		5, 7, 0, 0, 1233, 1235, 1, 0, 0, 0, 1234, 1222, 1, 0, 0, 0, 1234, 1235,
		1, 0, 0, 0, 1235, 1239, 1, 0, 0, 0, 1236, 1238, 5, 5, 0, 0, 1237, 1236,
		1, 0, 0, 0, 1238, 1241, 1, 0, 0, 0, 1239, 1237, 1, 0, 0, 0, 1239, 1240,
		1, 0, 0, 0, 1240, 1244, 1, 0, 0, 0, 1241, 1239, 1, 0, 0, 0, 1242, 1245,
		3, 68, 34, 0, 1243, 1245, 3, 66, 33, 0, 1244, 1242, 1, 0, 0, 0, 1244, 1243,
		1, 0, 0, 0, 1245, 1253, 1, 0, 0, 0, 1246, 1248, 5, 5, 0, 0, 1247, 1246,
		1, 0, 0, 0, 1248, 1251, 1, 0, 0, 0, 1249, 1247, 1, 0, 0, 0, 1249, 1250,
		1, 0, 0, 0, 1250, 1252, 1, 0, 0, 0, 1251, 1249, 1, 0, 0, 0, 1252, 1254,
		3, 46, 23, 0, 1253, 1249, 1, 0, 0, 0, 1253, 1254, 1, 0, 0, 0, 1254, 1272,
		1, 0, 0, 0, 1255, 1257, 5, 5, 0, 0, 1256, 1255, 1, 0, 0, 0, 1257, 1260,
		1, 0, 0, 0, 1258, 1256, 1, 0, 0, 0, 1258, 1259, 1, 0, 0, 0, 1259, 1270,
		1, 0, 0, 0, 1260, 1258, 1, 0, 0, 0, 1261, 1265, 5, 28, 0, 0, 1262, 1264,
		5, 5, 0, 0, 1263, 1262, 1, 0, 0, 0, 1264, 1267, 1, 0, 0, 0, 1265, 1263,
		1, 0, 0, 0, 1265, 1266, 1, 0, 0, 0, 1266, 1268, 1, 0, 0, 0, 1267, 1265,
		1, 0, 0, 0, 1268, 1271, 3, 152, 76, 0, 1269, 1271, 3, 72, 36, 0, 1270,
		1261, 1, 0, 0, 0, 1270, 1269, 1, 0, 0, 0, 1271, 1273, 1, 0, 0, 0, 1272,
		1258, 1, 0, 0, 0, 1272, 1273, 1, 0, 0, 0, 1273, 1281, 1, 0, 0, 0, 1274,
		1276, 5, 5, 0, 0, 1275, 1274, 1, 0, 0, 0, 1276, 1279, 1, 0, 0, 0, 1277,
		1275, 1, 0, 0, 0, 1277, 1278, 1, 0, 0, 0, 1278, 1280, 1, 0, 0, 0, 1279,
		1277, 1, 0, 0, 0, 1280, 1282, 5, 27, 0, 0, 1281, 1277, 1, 0, 0, 0, 1281,
		1282, 1, 0, 0, 0, 1282, 1286, 1, 0, 0, 0, 1283, 1285, 5, 5, 0, 0, 1284,
		1283, 1, 0, 0, 0, 1285, 1288, 1, 0, 0, 0, 1286, 1284, 1, 0, 0, 0, 1286,
		1287, 1, 0, 0, 0, 1287, 1319, 1, 0, 0, 0, 1288, 1286, 1, 0, 0, 0, 1289,
		1291, 3, 74, 37, 0, 1290, 1289, 1, 0, 0, 0, 1290, 1291, 1, 0, 0, 0, 1291,
		1302, 1, 0, 0, 0, 1292, 1294, 5, 5, 0, 0, 1293, 1292, 1, 0, 0, 0, 1294,
		1297, 1, 0, 0, 0, 1295, 1293, 1, 0, 0, 0, 1295, 1296, 1, 0, 0, 0, 1296,
		1299, 1, 0, 0, 0, 1297, 1295, 1, 0, 0, 0, 1298, 1300, 3, 148, 74, 0, 1299,
		1298, 1, 0, 0, 0, 1299, 1300, 1, 0, 0, 0, 1300, 1301, 1, 0, 0, 0, 1301,
		1303, 3, 76, 38, 0, 1302, 1295, 1, 0, 0, 0, 1302, 1303, 1, 0, 0, 0, 1303,
		1320, 1, 0, 0, 0, 1304, 1306, 3, 76, 38, 0, 1305, 1304, 1, 0, 0, 0, 1305,
		1306, 1, 0, 0, 0, 1306, 1317, 1, 0, 0, 0, 1307, 1309, 5, 5, 0, 0, 1308,
		1307, 1, 0, 0, 0, 1309, 1312, 1, 0, 0, 0, 1310, 1308, 1, 0, 0, 0, 1310,
		1311, 1, 0, 0, 0, 1311, 1314, 1, 0, 0, 0, 1312, 1310, 1, 0, 0, 0, 1313,
		1315, 3, 148, 74, 0, 1314, 1313, 1, 0, 0, 0, 1314, 1315, 1, 0, 0, 0, 1315,
		1316, 1, 0, 0, 0, 1316, 1318, 3, 74, 37, 0, 1317, 1310, 1, 0, 0, 0, 1317,
		1318, 1, 0, 0, 0, 1318, 1320, 1, 0, 0, 0, 1319, 1290, 1, 0, 0, 0, 1319,
		1305, 1, 0, 0, 0, 1320, 71, 1, 0, 0, 0, 1321, 1325, 5, 82, 0, 0, 1322,
		1324, 5, 5, 0, 0, 1323, 1322, 1, 0, 0, 0, 1324, 1327, 1, 0, 0, 0, 1325,
		1323, 1, 0, 0, 0, 1325, 1326, 1, 0, 0, 0, 1326, 1328, 1, 0, 0, 0, 1327,
		1325, 1, 0, 0, 0, 1328, 1329, 3, 152, 76, 0, 1329, 73, 1, 0, 0, 0, 1330,
		1332, 3, 300, 150, 0, 1331, 1330, 1, 0, 0, 0, 1331, 1332, 1, 0, 0, 0, 1332,
		1333, 1, 0, 0, 0, 1333, 1371, 5, 66, 0, 0, 1334, 1336, 5, 5, 0, 0, 1335,
		1334, 1, 0, 0, 0, 1336, 1339, 1, 0, 0, 0, 1337, 1335, 1, 0, 0, 0, 1337,
		1338, 1, 0, 0, 0, 1338, 1340, 1, 0, 0, 0, 1339, 1337, 1, 0, 0, 0, 1340,
		1344, 5, 9, 0, 0, 1341, 1343, 5, 5, 0, 0, 1342, 1341, 1, 0, 0, 0, 1343,
		1346, 1, 0, 0, 0, 1344, 1342, 1, 0, 0, 0, 1344, 1345, 1, 0, 0, 0, 1345,
		1347, 1, 0, 0, 0, 1346, 1344, 1, 0, 0, 0, 1347, 1362, 5, 10, 0, 0, 1348,
		1350, 5, 5, 0, 0, 1349, 1348, 1, 0, 0, 0, 1350, 1353, 1, 0, 0, 0, 1351,
		1349, 1, 0, 0, 0, 1351, 1352, 1, 0, 0, 0, 1352, 1354, 1, 0, 0, 0, 1353,
		1351, 1, 0, 0, 0, 1354, 1358, 5, 26, 0, 0, 1355, 1357, 5, 5, 0, 0, 1356,
		1355, 1, 0, 0, 0, 1357, 1360, 1, 0, 0, 0, 1358, 1356, 1, 0, 0, 0, 1358,
		1359, 1, 0, 0, 0, 1359, 1361, 1, 0, 0, 0, 1360, 1358, 1, 0, 0, 0, 1361,
		1363, 3, 98, 49, 0, 1362, 1351, 1, 0, 0, 0, 1362, 1363, 1, 0, 0, 0, 1363,
		1367, 1, 0, 0, 0, 1364, 1366, 5, 5, 0, 0, 1365, 1364, 1, 0, 0, 0, 1366,
		1369, 1, 0, 0, 0, 1367, 1365, 1, 0, 0, 0, 1367, 1368, 1, 0, 0, 0, 1368,
		1370, 1, 0, 0, 0, 1369, 1367, 1, 0, 0, 0, 1370, 1372, 3, 64, 32, 0, 1371,
		1337, 1, 0, 0, 0, 1371, 1372, 1, 0, 0, 0, 1372, 75, 1, 0, 0, 0, 1373, 1375,
		3, 300, 150, 0, 1374, 1373, 1, 0, 0, 0, 1374, 1375, 1, 0, 0, 0, 1375, 1376,
		1, 0, 0, 0, 1376, 1431, 5, 67, 0, 0, 1377, 1379, 5, 5, 0, 0, 1378, 1377,
		1, 0, 0, 0, 1379, 1382, 1, 0, 0, 0, 1380, 1378, 1, 0, 0, 0, 1380, 1381,
		1, 0, 0, 0, 1381, 1383, 1, 0, 0, 0, 1382, 1380, 1, 0, 0, 0, 1383, 1387,
		5, 9, 0, 0, 1384, 1386, 5, 5, 0, 0, 1385, 1384, 1, 0, 0, 0, 1386, 1389,
		1, 0, 0, 0, 1387, 1385, 1, 0, 0, 0, 1387, 1388, 1, 0, 0, 0, 1388, 1390,
		1, 0, 0, 0, 1389, 1387, 1, 0, 0, 0, 1390, 1398, 3, 80, 40, 0, 1391, 1393,
		5, 5, 0, 0, 1392, 1391, 1, 0, 0, 0, 1393, 1396, 1, 0, 0, 0, 1394, 1392,
		1, 0, 0, 0, 1394, 1395, 1, 0, 0, 0, 1395, 1397, 1, 0, 0, 0, 1396, 1394,
		1, 0, 0, 0, 1397, 1399, 5, 8, 0, 0, 1398, 1394, 1, 0, 0, 0, 1398, 1399,
		1, 0, 0, 0, 1399, 1403, 1, 0, 0, 0, 1400, 1402, 5, 5, 0, 0, 1401, 1400,
		1, 0, 0, 0, 1402, 1405, 1, 0, 0, 0, 1403, 1401, 1, 0, 0, 0, 1403, 1404,
		1, 0, 0, 0, 1404, 1406, 1, 0, 0, 0, 1405, 1403, 1, 0, 0, 0, 1406, 1421,
		5, 10, 0, 0, 1407, 1409, 5, 5, 0, 0, 1408, 1407, 1, 0, 0, 0, 1409, 1412,
		1, 0, 0, 0, 1410, 1408, 1, 0, 0, 0, 1410, 1411, 1, 0, 0, 0, 1411, 1413,
		1, 0, 0, 0, 1412, 1410, 1, 0, 0, 0, 1413, 1417, 5, 26, 0, 0, 1414, 1416,
		5, 5, 0, 0, 1415, 1414, 1, 0, 0, 0, 1416, 1419, 1, 0, 0, 0, 1417, 1415,
		1, 0, 0, 0, 1417, 1418, 1, 0, 0, 0, 1418, 1420, 1, 0, 0, 0, 1419, 1417,
		1, 0, 0, 0, 1420, 1422, 3, 98, 49, 0, 1421, 1410, 1, 0, 0, 0, 1421, 1422,
		1, 0, 0, 0, 1422, 1426, 1, 0, 0, 0, 1423, 1425, 5, 5, 0, 0, 1424, 1423,
		1, 0, 0, 0, 1425, 1428, 1, 0, 0, 0, 1426, 1424, 1, 0, 0, 0, 1426, 1427,
		1, 0, 0, 0, 1427, 1429, 1, 0, 0, 0, 1428, 1426, 1, 0, 0, 0, 1429, 1430,
		3, 64, 32, 0, 1430, 1432, 1, 0, 0, 0, 1431, 1380, 1, 0, 0, 0, 1431, 1432,
		1, 0, 0, 0, 1432, 77, 1, 0, 0, 0, 1433, 1437, 5, 9, 0, 0, 1434, 1436, 5,
		5, 0, 0, 1435, 1434, 1, 0, 0, 0, 1436, 1439, 1, 0, 0, 0, 1437, 1435, 1,
		0, 0, 0, 1437, 1438, 1, 0, 0, 0, 1438, 1469, 1, 0, 0, 0, 1439, 1437, 1,
		0, 0, 0, 1440, 1457, 3, 80, 40, 0, 1441, 1443, 5, 5, 0, 0, 1442, 1441,
		1, 0, 0, 0, 1443, 1446, 1, 0, 0, 0, 1444, 1442, 1, 0, 0, 0, 1444, 1445,
		1, 0, 0, 0, 1445, 1447, 1, 0, 0, 0, 1446, 1444, 1, 0, 0, 0, 1447, 1451,
		5, 8, 0, 0, 1448, 1450, 5, 5, 0, 0, 1449, 1448, 1, 0, 0, 0, 1450, 1453,
		1, 0, 0, 0, 1451, 1449, 1, 0, 0, 0, 1451, 1452, 1, 0, 0, 0, 1452, 1454,
		1, 0, 0, 0, 1453, 1451, 1, 0, 0, 0, 1454, 1456, 3, 80, 40, 0, 1455, 1444,
		1, 0, 0, 0, 1456, 1459, 1, 0, 0, 0, 1457, 1455, 1, 0, 0, 0, 1457, 1458,
		1, 0, 0, 0, 1458, 1467, 1, 0, 0, 0, 1459, 1457, 1, 0, 0, 0, 1460, 1462,
		5, 5, 0, 0, 1461, 1460, 1, 0, 0, 0, 1462, 1465, 1, 0, 0, 0, 1463, 1461,
		1, 0, 0, 0, 1463, 1464, 1, 0, 0, 0, 1464, 1466, 1, 0, 0, 0, 1465, 1463,
		1, 0, 0, 0, 1466, 1468, 5, 8, 0, 0, 1467, 1463, 1, 0, 0, 0, 1467, 1468,
		1, 0, 0, 0, 1468, 1470, 1, 0, 0, 0, 1469, 1440, 1, 0, 0, 0, 1469, 1470,
		1, 0, 0, 0, 1470, 1474, 1, 0, 0, 0, 1471, 1473, 5, 5, 0, 0, 1472, 1471,
		1, 0, 0, 0, 1473, 1476, 1, 0, 0, 0, 1474, 1472, 1, 0, 0, 0, 1474, 1475,
		1, 0, 0, 0, 1475, 1477, 1, 0, 0, 0, 1476, 1474, 1, 0, 0, 0, 1477, 1478,
		5, 10, 0, 0, 1478, 79, 1, 0, 0, 0, 1479, 1481, 3, 302, 151, 0, 1480, 1479,
		1, 0, 0, 0, 1480, 1481, 1, 0, 0, 0, 1481, 1482, 1, 0, 0, 0, 1482, 1497,
		3, 82, 41, 0, 1483, 1485, 5, 5, 0, 0, 1484, 1483, 1, 0, 0, 0, 1485, 1488,
		1, 0, 0, 0, 1486, 1484, 1, 0, 0, 0, 1486, 1487, 1, 0, 0, 0, 1487, 1489,
		1, 0, 0, 0, 1488, 1486, 1, 0, 0, 0, 1489, 1493, 5, 28, 0, 0, 1490, 1492,
		5, 5, 0, 0, 1491, 1490, 1, 0, 0, 0, 1492, 1495, 1, 0, 0, 0, 1493, 1491,
		1, 0, 0, 0, 1493, 1494, 1, 0, 0, 0, 1494, 1496, 1, 0, 0, 0, 1495, 1493,
		1, 0, 0, 0, 1496, 1498, 3, 152, 76, 0, 1497, 1486, 1, 0, 0, 0, 1497, 1498,
		1, 0, 0, 0, 1498, 81, 1, 0, 0, 0, 1499, 1503, 3, 344, 172, 0, 1500, 1502,
		5, 5, 0, 0, 1501, 1500, 1, 0, 0, 0, 1502, 1505, 1, 0, 0, 0, 1503, 1501,
		1, 0, 0, 0, 1503, 1504, 1, 0, 0, 0, 1504, 1514, 1, 0, 0, 0, 1505, 1503,
		1, 0, 0, 0, 1506, 1510, 5, 26, 0, 0, 1507, 1509, 5, 5, 0, 0, 1508, 1507,
		1, 0, 0, 0, 1509, 1512, 1, 0, 0, 0, 1510, 1508, 1, 0, 0, 0, 1510, 1511,
		1, 0, 0, 0, 1511, 1513, 1, 0, 0, 0, 1512, 1510, 1, 0, 0, 0, 1513, 1515,
		3, 98, 49, 0, 1514, 1506, 1, 0, 0, 0, 1514, 1515, 1, 0, 0, 0, 1515, 83,
		1, 0, 0, 0, 1516, 1520, 3, 344, 172, 0, 1517, 1519, 5, 5, 0, 0, 1518, 1517,
		1, 0, 0, 0, 1519, 1522, 1, 0, 0, 0, 1520, 1518, 1, 0, 0, 0, 1520, 1521,
		1, 0, 0, 0, 1521, 1523, 1, 0, 0, 0, 1522, 1520, 1, 0, 0, 0, 1523, 1527,
		5, 26, 0, 0, 1524, 1526, 5, 5, 0, 0, 1525, 1524, 1, 0, 0, 0, 1526, 1529,
		1, 0, 0, 0, 1527, 1525, 1, 0, 0, 0, 1527, 1528, 1, 0, 0, 0, 1528, 1530,
		1, 0, 0, 0, 1529, 1527, 1, 0, 0, 0, 1530, 1531, 3, 98, 49, 0, 1531, 85,
		1, 0, 0, 0, 1532, 1534, 3, 300, 150, 0, 1533, 1532, 1, 0, 0, 0, 1533, 1534,
		1, 0, 0, 0, 1534, 1535, 1, 0, 0, 0, 1535, 1539, 5, 77, 0, 0, 1536, 1538,
		5, 5, 0, 0, 1537, 1536, 1, 0, 0, 0, 1538, 1541, 1, 0, 0, 0, 1539, 1537,
		1, 0, 0, 0, 1539, 1540, 1, 0, 0, 0, 1540, 1542, 1, 0, 0, 0, 1541, 1539,
		1, 0, 0, 0, 1542, 1557, 3, 344, 172, 0, 1543, 1545, 5, 5, 0, 0, 1544, 1543,
		1, 0, 0, 0, 1545, 1548, 1, 0, 0, 0, 1546, 1544, 1, 0, 0, 0, 1546, 1547,
		1, 0, 0, 0, 1547, 1549, 1, 0, 0, 0, 1548, 1546, 1, 0, 0, 0, 1549, 1553,
		5, 26, 0, 0, 1550, 1552, 5, 5, 0, 0, 1551, 1550, 1, 0, 0, 0, 1552, 1555,
		1, 0, 0, 0, 1553, 1551, 1, 0, 0, 0, 1553, 1554, 1, 0, 0, 0, 1554, 1556,
		1, 0, 0, 0, 1555, 1553, 1, 0, 0, 0, 1556, 1558, 3, 32, 16, 0, 1557, 1546,
		1, 0, 0, 0, 1557, 1558, 1, 0, 0, 0, 1558, 1566, 1, 0, 0, 0, 1559, 1561,
		5, 5, 0, 0, 1560, 1559, 1, 0, 0, 0, 1561, 1564, 1, 0, 0, 0, 1562, 1560,
		1, 0, 0, 0, 1562, 1563, 1, 0, 0, 0, 1563, 1565, 1, 0, 0, 0, 1564, 1562,
		1, 0, 0, 0, 1565, 1567, 3, 26, 13, 0, 1566, 1562, 1, 0, 0, 0, 1566, 1567,
		1, 0, 0, 0, 1567, 87, 1, 0, 0, 0, 1568, 1570, 3, 300, 150, 0, 1569, 1568,
		1, 0, 0, 0, 1569, 1570, 1, 0, 0, 0, 1570, 1571, 1, 0, 0, 0, 1571, 1575,
		5, 81, 0, 0, 1572, 1574, 5, 5, 0, 0, 1573, 1572, 1, 0, 0, 0, 1574, 1577,
		1, 0, 0, 0, 1575, 1573, 1, 0, 0, 0, 1575, 1576, 1, 0, 0, 0, 1576, 1578,
		1, 0, 0, 0, 1577, 1575, 1, 0, 0, 0, 1578, 1593, 3, 58, 29, 0, 1579, 1581,
		5, 5, 0, 0, 1580, 1579, 1, 0, 0, 0, 1581, 1584, 1, 0, 0, 0, 1582, 1580,
		1, 0, 0, 0, 1582, 1583, 1, 0, 0, 0, 1583, 1585, 1, 0, 0, 0, 1584, 1582,
		1, 0, 0, 0, 1585, 1589, 5, 26, 0, 0, 1586, 1588, 5, 5, 0, 0, 1587, 1586,
		1, 0, 0, 0, 1588, 1591, 1, 0, 0, 0, 1589, 1587, 1, 0, 0, 0, 1589, 1590,
		1, 0, 0, 0, 1590, 1592, 1, 0, 0, 0, 1591, 1589, 1, 0, 0, 0, 1592, 1594,
		3, 90, 45, 0, 1593, 1582, 1, 0, 0, 0, 1593, 1594, 1, 0, 0, 0, 1594, 1598,
		1, 0, 0, 0, 1595, 1597, 5, 5, 0, 0, 1596, 1595, 1, 0, 0, 0, 1597, 1600,
		1, 0, 0, 0, 1598, 1596, 1, 0, 0, 0, 1598, 1599, 1, 0, 0, 0, 1599, 1602,
		1, 0, 0, 0, 1600, 1598, 1, 0, 0, 0, 1601, 1603, 3, 136, 68, 0, 1602, 1601,
		1, 0, 0, 0, 1602, 1603, 1, 0, 0, 0, 1603, 89, 1, 0, 0, 0, 1604, 1608, 7,
		2, 0, 0, 1605, 1607, 5, 5, 0, 0, 1606, 1605, 1, 0, 0, 0, 1607, 1610, 1,
		0, 0, 0, 1608, 1606, 1, 0, 0, 0, 1608, 1609, 1, 0, 0, 0, 1609, 1611, 1,
		0, 0, 0, 1610, 1608, 1, 0, 0, 0, 1611, 1612, 3, 208, 104, 0, 1612, 91,
		1, 0, 0, 0, 1613, 1617, 5, 13, 0, 0, 1614, 1616, 5, 5, 0, 0, 1615, 1614,
		1, 0, 0, 0, 1616, 1619, 1, 0, 0, 0, 1617, 1615, 1, 0, 0, 0, 1617, 1618,
		1, 0, 0, 0, 1618, 1621, 1, 0, 0, 0, 1619, 1617, 1, 0, 0, 0, 1620, 1622,
		3, 94, 47, 0, 1621, 1620, 1, 0, 0, 0, 1621, 1622, 1, 0, 0, 0, 1622, 1637,
		1, 0, 0, 0, 1623, 1625, 5, 5, 0, 0, 1624, 1623, 1, 0, 0, 0, 1625, 1628,
		1, 0, 0, 0, 1626, 1624, 1, 0, 0, 0, 1626, 1627, 1, 0, 0, 0, 1627, 1629,
		1, 0, 0, 0, 1628, 1626, 1, 0, 0, 0, 1629, 1633, 5, 27, 0, 0, 1630, 1632,
		5, 5, 0, 0, 1631, 1630, 1, 0, 0, 0, 1632, 1635, 1, 0, 0, 0, 1633, 1631,
		1, 0, 0, 0, 1633, 1634, 1, 0, 0, 0, 1634, 1636, 1, 0, 0, 0, 1635, 1633,
		1, 0, 0, 0, 1636, 1638, 3, 50, 25, 0, 1637, 1626, 1, 0, 0, 0, 1637, 1638,
		1, 0, 0, 0, 1638, 1642, 1, 0, 0, 0, 1639, 1641, 5, 5, 0, 0, 1640, 1639,
		1, 0, 0, 0, 1641, 1644, 1, 0, 0, 0, 1642, 1640, 1, 0, 0, 0, 1642, 1643,
		1, 0, 0, 0, 1643, 1645, 1, 0, 0, 0, 1644, 1642, 1, 0, 0, 0, 1645, 1646,
		5, 14, 0, 0, 1646, 93, 1, 0, 0, 0, 1647, 1664, 3, 96, 48, 0, 1648, 1650,
		5, 5, 0, 0, 1649, 1648, 1, 0, 0, 0, 1650, 1653, 1, 0, 0, 0, 1651, 1649,
		1, 0, 0, 0, 1651, 1652, 1, 0, 0, 0, 1652, 1654, 1, 0, 0, 0, 1653, 1651,
		1, 0, 0, 0, 1654, 1658, 5, 8, 0, 0, 1655, 1657, 5, 5, 0, 0, 1656, 1655,
		1, 0, 0, 0, 1657, 1660, 1, 0, 0, 0, 1658, 1656, 1, 0, 0, 0, 1658, 1659,
		1, 0, 0, 0, 1659, 1661, 1, 0, 0, 0, 1660, 1658, 1, 0, 0, 0, 1661, 1663,
		3, 96, 48, 0, 1662, 1651, 1, 0, 0, 0, 1663, 1666, 1, 0, 0, 0, 1664, 1662,
		1, 0, 0, 0, 1664, 1665, 1, 0, 0, 0, 1665, 1670, 1, 0, 0, 0, 1666, 1664,
		1, 0, 0, 0, 1667, 1669, 5, 5, 0, 0, 1668, 1667, 1, 0, 0, 0, 1669, 1672,
		1, 0, 0, 0, 1670, 1668, 1, 0, 0, 0, 1670, 1671, 1, 0, 0, 0, 1671, 1674,
		1, 0, 0, 0, 1672, 1670, 1, 0, 0, 0, 1673, 1675, 5, 8, 0, 0, 1674, 1673,
		1, 0, 0, 0, 1674, 1675, 1, 0, 0, 0, 1675, 95, 1, 0, 0, 0, 1676, 1680, 3,
		300, 150, 0, 1677, 1679, 5, 5, 0, 0, 1678, 1677, 1, 0, 0, 0, 1679, 1682,
		1, 0, 0, 0, 1680, 1678, 1, 0, 0, 0, 1680, 1681, 1, 0, 0, 0, 1681, 1684,
		1, 0, 0, 0, 1682, 1680, 1, 0, 0, 0, 1683, 1676, 1, 0, 0, 0, 1683, 1684,
		1, 0, 0, 0, 1684, 1685, 1, 0, 0, 0, 1685, 1693, 3, 344, 172, 0, 1686, 1688,
		5, 5, 0, 0, 1687, 1686, 1, 0, 0, 0, 1688, 1691, 1, 0, 0, 0, 1689, 1687,
		1, 0, 0, 0, 1689, 1690, 1, 0, 0, 0, 1690, 1692, 1, 0, 0, 0, 1691, 1689,
		1, 0, 0, 0, 1692, 1694, 3, 208, 104, 0, 1693, 1689, 1, 0, 0, 0, 1693, 1694,
		1, 0, 0, 0, 1694, 1702, 1, 0, 0, 0, 1695, 1697, 5, 5, 0, 0, 1696, 1695,
		1, 0, 0, 0, 1697, 1700, 1, 0, 0, 0, 1698, 1696, 1, 0, 0, 0, 1698, 1699,
		1, 0, 0, 0, 1699, 1701, 1, 0, 0, 0, 1700, 1698, 1, 0, 0, 0, 1701, 1703,
		3, 26, 13, 0, 1702, 1698, 1, 0, 0, 0, 1702, 1703, 1, 0, 0, 0, 1703, 97,
		1, 0, 0, 0, 1704, 1706, 3, 306, 153, 0, 1705, 1704, 1, 0, 0, 0, 1705, 1706,
		1, 0, 0, 0, 1706, 1712, 1, 0, 0, 0, 1707, 1713, 3, 116, 58, 0, 1708, 1713,
		3, 120, 60, 0, 1709, 1713, 3, 102, 51, 0, 1710, 1713, 3, 100, 50, 0, 1711,
		1713, 3, 126, 63, 0, 1712, 1707, 1, 0, 0, 0, 1712, 1708, 1, 0, 0, 0, 1712,
		1709, 1, 0, 0, 0, 1712, 1710, 1, 0, 0, 0, 1712, 1711, 1, 0, 0, 0, 1713,
		99, 1, 0, 0, 0, 1714, 1717, 3, 106, 53, 0, 1715, 1717, 5, 108, 0, 0, 1716,
		1714, 1, 0, 0, 0, 1716, 1715, 1, 0, 0, 0, 1717, 101, 1, 0, 0, 0, 1718,
		1721, 3, 100, 50, 0, 1719, 1721, 3, 120, 60, 0, 1720, 1718, 1, 0, 0, 0,
		1720, 1719, 1, 0, 0, 0, 1721, 1725, 1, 0, 0, 0, 1722, 1724, 5, 5, 0, 0,
		1723, 1722, 1, 0, 0, 0, 1724, 1727, 1, 0, 0, 0, 1725, 1723, 1, 0, 0, 0,
		1725, 1726, 1, 0, 0, 0, 1726, 1729, 1, 0, 0, 0, 1727, 1725, 1, 0, 0, 0,
		1728, 1730, 3, 104, 52, 0, 1729, 1728, 1, 0, 0, 0, 1730, 1731, 1, 0, 0,
		0, 1731, 1729, 1, 0, 0, 0, 1731, 1732, 1, 0, 0, 0, 1732, 103, 1, 0, 0,
		0, 1733, 1734, 7, 3, 0, 0, 1734, 105, 1, 0, 0, 0, 1735, 1752, 3, 108, 54,
		0, 1736, 1738, 5, 5, 0, 0, 1737, 1736, 1, 0, 0, 0, 1738, 1741, 1, 0, 0,
		0, 1739, 1737, 1, 0, 0, 0, 1739, 1740, 1, 0, 0, 0, 1740, 1742, 1, 0, 0,
		0, 1741, 1739, 1, 0, 0, 0, 1742, 1746, 5, 7, 0, 0, 1743, 1745, 5, 5, 0,
		0, 1744, 1743, 1, 0, 0, 0, 1745, 1748, 1, 0, 0, 0, 1746, 1744, 1, 0, 0,
		0, 1746, 1747, 1, 0, 0, 0, 1747, 1749, 1, 0, 0, 0, 1748, 1746, 1, 0, 0,
		0, 1749, 1751, 3, 108, 54, 0, 1750, 1739, 1, 0, 0, 0, 1751, 1754, 1, 0,
		0, 0, 1752, 1750, 1, 0, 0, 0, 1752, 1753, 1, 0, 0, 0, 1753, 107, 1, 0,
		0, 0, 1754, 1752, 1, 0, 0, 0, 1755, 1763, 3, 344, 172, 0, 1756, 1758, 5,
		5, 0, 0, 1757, 1756, 1, 0, 0, 0, 1758, 1761, 1, 0, 0, 0, 1759, 1757, 1,
		0, 0, 0, 1759, 1760, 1, 0, 0, 0, 1760, 1762, 1, 0, 0, 0, 1761, 1759, 1,
		0, 0, 0, 1762, 1764, 3, 206, 103, 0, 1763, 1759, 1, 0, 0, 0, 1763, 1764,
		1, 0, 0, 0, 1764, 109, 1, 0, 0, 0, 1765, 1767, 3, 112, 56, 0, 1766, 1765,
		1, 0, 0, 0, 1766, 1767, 1, 0, 0, 0, 1767, 1768, 1, 0, 0, 0, 1768, 1771,
		3, 98, 49, 0, 1769, 1771, 5, 15, 0, 0, 1770, 1766, 1, 0, 0, 0, 1770, 1769,
		1, 0, 0, 0, 1771, 111, 1, 0, 0, 0, 1772, 1774, 3, 114, 57, 0, 1773, 1772,
		1, 0, 0, 0, 1774, 1775, 1, 0, 0, 0, 1775, 1773, 1, 0, 0, 0, 1775, 1776,
		1, 0, 0, 0, 1776, 113, 1, 0, 0, 0, 1777, 1781, 3, 316, 158, 0, 1778, 1780,
		5, 5, 0, 0, 1779, 1778, 1, 0, 0, 0, 1780, 1783, 1, 0, 0, 0, 1781, 1779,
		1, 0, 0, 0, 1781, 1782, 1, 0, 0, 0, 1782, 1786, 1, 0, 0, 0, 1783, 1781,
		1, 0, 0, 0, 1784, 1786, 3, 334, 167, 0, 1785, 1777, 1, 0, 0, 0, 1785, 1784,
		1, 0, 0, 0, 1786, 115, 1, 0, 0, 0, 1787, 1791, 3, 122, 61, 0, 1788, 1790,
		5, 5, 0, 0, 1789, 1788, 1, 0, 0, 0, 1790, 1793, 1, 0, 0, 0, 1791, 1789,
		1, 0, 0, 0, 1791, 1792, 1, 0, 0, 0, 1792, 1794, 1, 0, 0, 0, 1793, 1791,
		1, 0, 0, 0, 1794, 1798, 5, 7, 0, 0, 1795, 1797, 5, 5, 0, 0, 1796, 1795,
		1, 0, 0, 0, 1797, 1800, 1, 0, 0, 0, 1798, 1796, 1, 0, 0, 0, 1798, 1799,
		1, 0, 0, 0, 1799, 1802, 1, 0, 0, 0, 1800, 1798, 1, 0, 0, 0, 1801, 1787,
		1, 0, 0, 0, 1801, 1802, 1, 0, 0, 0, 1802, 1803, 1, 0, 0, 0, 1803, 1807,
		3, 118, 59, 0, 1804, 1806, 5, 5, 0, 0, 1805, 1804, 1, 0, 0, 0, 1806, 1809,
		1, 0, 0, 0, 1807, 1805, 1, 0, 0, 0, 1807, 1808, 1, 0, 0, 0, 1808, 1810,
		1, 0, 0, 0, 1809, 1807, 1, 0, 0, 0, 1810, 1814, 5, 34, 0, 0, 1811, 1813,
		5, 5, 0, 0, 1812, 1811, 1, 0, 0, 0, 1813, 1816, 1, 0, 0, 0, 1814, 1812,
		1, 0, 0, 0, 1814, 1815, 1, 0, 0, 0, 1815, 1817, 1, 0, 0, 0, 1816, 1814,
		1, 0, 0, 0, 1817, 1818, 3, 98, 49, 0, 1818, 117, 1, 0, 0, 0, 1819, 1823,
		5, 9, 0, 0, 1820, 1822, 5, 5, 0, 0, 1821, 1820, 1, 0, 0, 0, 1822, 1825,
		1, 0, 0, 0, 1823, 1821, 1, 0, 0, 0, 1823, 1824, 1, 0, 0, 0, 1824, 1828,
		1, 0, 0, 0, 1825, 1823, 1, 0, 0, 0, 1826, 1829, 3, 84, 42, 0, 1827, 1829,
		3, 98, 49, 0, 1828, 1826, 1, 0, 0, 0, 1828, 1827, 1, 0, 0, 0, 1828, 1829,
		1, 0, 0, 0, 1829, 1849, 1, 0, 0, 0, 1830, 1832, 5, 5, 0, 0, 1831, 1830,
		1, 0, 0, 0, 1832, 1835, 1, 0, 0, 0, 1833, 1831, 1, 0, 0, 0, 1833, 1834,
		1, 0, 0, 0, 1834, 1836, 1, 0, 0, 0, 1835, 1833, 1, 0, 0, 0, 1836, 1840,
		5, 8, 0, 0, 1837, 1839, 5, 5, 0, 0, 1838, 1837, 1, 0, 0, 0, 1839, 1842,
		1, 0, 0, 0, 1840, 1838, 1, 0, 0, 0, 1840, 1841, 1, 0, 0, 0, 1841, 1845,
		1, 0, 0, 0, 1842, 1840, 1, 0, 0, 0, 1843, 1846, 3, 84, 42, 0, 1844, 1846,
		3, 98, 49, 0, 1845, 1843, 1, 0, 0, 0, 1845, 1844, 1, 0, 0, 0, 1846, 1848,
		1, 0, 0, 0, 1847, 1833, 1, 0, 0, 0, 1848, 1851, 1, 0, 0, 0, 1849, 1847,
		1, 0, 0, 0, 1849, 1850, 1, 0, 0, 0, 1850, 1859, 1, 0, 0, 0, 1851, 1849,
		1, 0, 0, 0, 1852, 1854, 5, 5, 0, 0, 1853, 1852, 1, 0, 0, 0, 1854, 1857,
		1, 0, 0, 0, 1855, 1853, 1, 0, 0, 0, 1855, 1856, 1, 0, 0, 0, 1856, 1858,
		1, 0, 0, 0, 1857, 1855, 1, 0, 0, 0, 1858, 1860, 5, 8, 0, 0, 1859, 1855,
		1, 0, 0, 0, 1859, 1860, 1, 0, 0, 0, 1860, 1864, 1, 0, 0, 0, 1861, 1863,
		5, 5, 0, 0, 1862, 1861, 1, 0, 0, 0, 1863, 1866, 1, 0, 0, 0, 1864, 1862,
		1, 0, 0, 0, 1864, 1865, 1, 0, 0, 0, 1865, 1867, 1, 0, 0, 0, 1866, 1864,
		1, 0, 0, 0, 1867, 1868, 5, 10, 0, 0, 1868, 119, 1, 0, 0, 0, 1869, 1873,
		5, 9, 0, 0, 1870, 1872, 5, 5, 0, 0, 1871, 1870, 1, 0, 0, 0, 1872, 1875,
		1, 0, 0, 0, 1873, 1871, 1, 0, 0, 0, 1873, 1874, 1, 0, 0, 0, 1874, 1876,
		1, 0, 0, 0, 1875, 1873, 1, 0, 0, 0, 1876, 1880, 3, 98, 49, 0, 1877, 1879,
		5, 5, 0, 0, 1878, 1877, 1, 0, 0, 0, 1879, 1882, 1, 0, 0, 0, 1880, 1878,
		1, 0, 0, 0, 1880, 1881, 1, 0, 0, 0, 1881, 1883, 1, 0, 0, 0, 1882, 1880,
		1, 0, 0, 0, 1883, 1884, 5, 10, 0, 0, 1884, 121, 1, 0, 0, 0, 1885, 1887,
		3, 306, 153, 0, 1886, 1885, 1, 0, 0, 0, 1886, 1887, 1, 0, 0, 0, 1887, 1891,
		1, 0, 0, 0, 1888, 1892, 3, 120, 60, 0, 1889, 1892, 3, 102, 51, 0, 1890,
		1892, 3, 100, 50, 0, 1891, 1888, 1, 0, 0, 0, 1891, 1889, 1, 0, 0, 0, 1891,
		1890, 1, 0, 0, 0, 1892, 123, 1, 0, 0, 0, 1893, 1897, 5, 9, 0, 0, 1894,
		1896, 5, 5, 0, 0, 1895, 1894, 1, 0, 0, 0, 1896, 1899, 1, 0, 0, 0, 1897,
		1895, 1, 0, 0, 0, 1897, 1898, 1, 0, 0, 0, 1898, 1902, 1, 0, 0, 0, 1899,
		1897, 1, 0, 0, 0, 1900, 1903, 3, 106, 53, 0, 1901, 1903, 3, 124, 62, 0,
		1902, 1900, 1, 0, 0, 0, 1902, 1901, 1, 0, 0, 0, 1903, 1907, 1, 0, 0, 0,
		1904, 1906, 5, 5, 0, 0, 1905, 1904, 1, 0, 0, 0, 1906, 1909, 1, 0, 0, 0,
		1907, 1905, 1, 0, 0, 0, 1907, 1908, 1, 0, 0, 0, 1908, 1910, 1, 0, 0, 0,
		1909, 1907, 1, 0, 0, 0, 1910, 1911, 5, 10, 0, 0, 1911, 125, 1, 0, 0, 0,
		1912, 1914, 3, 306, 153, 0, 1913, 1912, 1, 0, 0, 0, 1913, 1914, 1, 0, 0,
		0, 1914, 1917, 1, 0, 0, 0, 1915, 1918, 3, 106, 53, 0, 1916, 1918, 3, 124,
		62, 0, 1917, 1915, 1, 0, 0, 0, 1917, 1916, 1, 0, 0, 0, 1918, 1922, 1, 0,
		0, 0, 1919, 1921, 5, 5, 0, 0, 1920, 1919, 1, 0, 0, 0, 1921, 1924, 1, 0,
		0, 0, 1922, 1920, 1, 0, 0, 0, 1922, 1923, 1, 0, 0, 0, 1923, 1925, 1, 0,
		0, 0, 1924, 1922, 1, 0, 0, 0, 1925, 1929, 5, 57, 0, 0, 1926, 1928, 5, 5,
		0, 0, 1927, 1926, 1, 0, 0, 0, 1928, 1931, 1, 0, 0, 0, 1929, 1927, 1, 0,
		0, 0, 1929, 1930, 1, 0, 0, 0, 1930, 1933, 1, 0, 0, 0, 1931, 1929, 1, 0,
		0, 0, 1932, 1934, 3, 306, 153, 0, 1933, 1932, 1, 0, 0, 0, 1933, 1934, 1,
		0, 0, 0, 1934, 1937, 1, 0, 0, 0, 1935, 1938, 3, 106, 53, 0, 1936, 1938,
		3, 124, 62, 0, 1937, 1935, 1, 0, 0, 0, 1937, 1936, 1, 0, 0, 0, 1938, 127,
		1, 0, 0, 0, 1939, 1945, 3, 130, 65, 0, 1940, 1941, 3, 150, 75, 0, 1941,
		1942, 3, 130, 65, 0, 1942, 1944, 1, 0, 0, 0, 1943, 1940, 1, 0, 0, 0, 1944,
		1947, 1, 0, 0, 0, 1945, 1943, 1, 0, 0, 0, 1945, 1946, 1, 0, 0, 0, 1946,
		1949, 1, 0, 0, 0, 1947, 1945, 1, 0, 0, 0, 1948, 1939, 1, 0, 0, 0, 1948,
		1949, 1, 0, 0, 0, 1949, 1951, 1, 0, 0, 0, 1950, 1952, 3, 150, 75, 0, 1951,
		1950, 1, 0, 0, 0, 1951, 1952, 1, 0, 0, 0, 1952, 129, 1, 0, 0, 0, 1953,
		1956, 3, 132, 66, 0, 1954, 1956, 3, 334, 167, 0, 1955, 1953, 1, 0, 0, 0,
		1955, 1954, 1, 0, 0, 0, 1956, 1959, 1, 0, 0, 0, 1957, 1955, 1, 0, 0, 0,
		1957, 1958, 1, 0, 0, 0, 1958, 1964, 1, 0, 0, 0, 1959, 1957, 1, 0, 0, 0,
		1960, 1965, 3, 20, 10, 0, 1961, 1965, 3, 146, 73, 0, 1962, 1965, 3, 138,
		69, 0, 1963, 1965, 3, 152, 76, 0, 1964, 1960, 1, 0, 0, 0, 1964, 1961, 1,
		0, 0, 0, 1964, 1962, 1, 0, 0, 0, 1964, 1963, 1, 0, 0, 0, 1965, 131, 1,
		0, 0, 0, 1966, 1967, 3, 344, 172, 0, 1967, 1971, 7, 4, 0, 0, 1968, 1970,
		5, 5, 0, 0, 1969, 1968, 1, 0, 0, 0, 1970, 1973, 1, 0, 0, 0, 1971, 1969,
		1, 0, 0, 0, 1971, 1972, 1, 0, 0, 0, 1972, 133, 1, 0, 0, 0, 1973, 1971,
		1, 0, 0, 0, 1974, 1977, 3, 136, 68, 0, 1975, 1977, 3, 130, 65, 0, 1976,
		1974, 1, 0, 0, 0, 1976, 1975, 1, 0, 0, 0, 1977, 135, 1, 0, 0, 0, 1978,
		1982, 5, 13, 0, 0, 1979, 1981, 5, 5, 0, 0, 1980, 1979, 1, 0, 0, 0, 1981,
		1984, 1, 0, 0, 0, 1982, 1980, 1, 0, 0, 0, 1982, 1983, 1, 0, 0, 0, 1983,
		1985, 1, 0, 0, 0, 1984, 1982, 1, 0, 0, 0, 1985, 1989, 3, 128, 64, 0, 1986,
		1988, 5, 5, 0, 0, 1987, 1986, 1, 0, 0, 0, 1988, 1991, 1, 0, 0, 0, 1989,
		1987, 1, 0, 0, 0, 1989, 1990, 1, 0, 0, 0, 1990, 1992, 1, 0, 0, 0, 1991,
		1989, 1, 0, 0, 0, 1992, 1993, 5, 14, 0, 0, 1993, 137, 1, 0, 0, 0, 1994,
		1998, 3, 140, 70, 0, 1995, 1998, 3, 142, 71, 0, 1996, 1998, 3, 144, 72,
		0, 1997, 1994, 1, 0, 0, 0, 1997, 1995, 1, 0, 0, 0, 1997, 1996, 1, 0, 0,
		0, 1998, 139, 1, 0, 0, 0, 1999, 2003, 5, 95, 0, 0, 2000, 2002, 5, 5, 0,
		0, 2001, 2000, 1, 0, 0, 0, 2002, 2005, 1, 0, 0, 0, 2003, 2001, 1, 0, 0,
		0, 2003, 2004, 1, 0, 0, 0, 2004, 2006, 1, 0, 0, 0, 2005, 2003, 1, 0, 0,
		0, 2006, 2010, 5, 9, 0, 0, 2007, 2009, 3, 334, 167, 0, 2008, 2007, 1, 0,
		0, 0, 2009, 2012, 1, 0, 0, 0, 2010, 2008, 1, 0, 0, 0, 2010, 2011, 1, 0,
		0, 0, 2011, 2015, 1, 0, 0, 0, 2012, 2010, 1, 0, 0, 0, 2013, 2016, 3, 66,
		33, 0, 2014, 2016, 3, 68, 34, 0, 2015, 2013, 1, 0, 0, 0, 2015, 2014, 1,
		0, 0, 0, 2016, 2017, 1, 0, 0, 0, 2017, 2018, 5, 104, 0, 0, 2018, 2019,
		3, 152, 76, 0, 2019, 2023, 5, 10, 0, 0, 2020, 2022, 5, 5, 0, 0, 2021, 2020,
		1, 0, 0, 0, 2022, 2025, 1, 0, 0, 0, 2023, 2021, 1, 0, 0, 0, 2023, 2024,
		1, 0, 0, 0, 2024, 2027, 1, 0, 0, 0, 2025, 2023, 1, 0, 0, 0, 2026, 2028,
		3, 134, 67, 0, 2027, 2026, 1, 0, 0, 0, 2027, 2028, 1, 0, 0, 0, 2028, 141,
		1, 0, 0, 0, 2029, 2033, 5, 97, 0, 0, 2030, 2032, 5, 5, 0, 0, 2031, 2030,
		1, 0, 0, 0, 2032, 2035, 1, 0, 0, 0, 2033, 2031, 1, 0, 0, 0, 2033, 2034,
		1, 0, 0, 0, 2034, 2036, 1, 0, 0, 0, 2035, 2033, 1, 0, 0, 0, 2036, 2037,
		5, 9, 0, 0, 2037, 2038, 3, 152, 76, 0, 2038, 2042, 5, 10, 0, 0, 2039, 2041,
		5, 5, 0, 0, 2040, 2039, 1, 0, 0, 0, 2041, 2044, 1, 0, 0, 0, 2042, 2040,
		1, 0, 0, 0, 2042, 2043, 1, 0, 0, 0, 2043, 2047, 1, 0, 0, 0, 2044, 2042,
		1, 0, 0, 0, 2045, 2048, 3, 134, 67, 0, 2046, 2048, 5, 27, 0, 0, 2047, 2045,
		1, 0, 0, 0, 2047, 2046, 1, 0, 0, 0, 2048, 143, 1, 0, 0, 0, 2049, 2053,
		5, 96, 0, 0, 2050, 2052, 5, 5, 0, 0, 2051, 2050, 1, 0, 0, 0, 2052, 2055,
		1, 0, 0, 0, 2053, 2051, 1, 0, 0, 0, 2053, 2054, 1, 0, 0, 0, 2054, 2057,
		1, 0, 0, 0, 2055, 2053, 1, 0, 0, 0, 2056, 2058, 3, 134, 67, 0, 2057, 2056,
		1, 0, 0, 0, 2057, 2058, 1, 0, 0, 0, 2058, 2062, 1, 0, 0, 0, 2059, 2061,
		5, 5, 0, 0, 2060, 2059, 1, 0, 0, 0, 2061, 2064, 1, 0, 0, 0, 2062, 2060,
		1, 0, 0, 0, 2062, 2063, 1, 0, 0, 0, 2063, 2065, 1, 0, 0, 0, 2064, 2062,
		1, 0, 0, 0, 2065, 2069, 5, 97, 0, 0, 2066, 2068, 5, 5, 0, 0, 2067, 2066,
		1, 0, 0, 0, 2068, 2071, 1, 0, 0, 0, 2069, 2067, 1, 0, 0, 0, 2069, 2070,
		1, 0, 0, 0, 2070, 2072, 1, 0, 0, 0, 2071, 2069, 1, 0, 0, 0, 2072, 2073,
		5, 9, 0, 0, 2073, 2074, 3, 152, 76, 0, 2074, 2075, 5, 10, 0, 0, 2075, 145,
		1, 0, 0, 0, 2076, 2077, 3, 188, 94, 0, 2077, 2078, 5, 28, 0, 0, 2078, 2083,
		1, 0, 0, 0, 2079, 2080, 3, 192, 96, 0, 2080, 2081, 3, 274, 137, 0, 2081,
		2083, 1, 0, 0, 0, 2082, 2076, 1, 0, 0, 0, 2082, 2079, 1, 0, 0, 0, 2083,
		2087, 1, 0, 0, 0, 2084, 2086, 5, 5, 0, 0, 2085, 2084, 1, 0, 0, 0, 2086,
		2089, 1, 0, 0, 0, 2087, 2085, 1, 0, 0, 0, 2087, 2088, 1, 0, 0, 0, 2088,
		2090, 1, 0, 0, 0, 2089, 2087, 1, 0, 0, 0, 2090, 2091, 3, 152, 76, 0, 2091,
		147, 1, 0, 0, 0, 2092, 2096, 7, 5, 0, 0, 2093, 2095, 5, 5, 0, 0, 2094,
		2093, 1, 0, 0, 0, 2095, 2098, 1, 0, 0, 0, 2096, 2094, 1, 0, 0, 0, 2096,
		2097, 1, 0, 0, 0, 2097, 149, 1, 0, 0, 0, 2098, 2096, 1, 0, 0, 0, 2099,
		2101, 7, 5, 0, 0, 2100, 2099, 1, 0, 0, 0, 2101, 2102, 1, 0, 0, 0, 2102,
		2100, 1, 0, 0, 0, 2102, 2103, 1, 0, 0, 0, 2103, 151, 1, 0, 0, 0, 2104,
		2105, 3, 154, 77, 0, 2105, 153, 1, 0, 0, 0, 2106, 2123, 3, 156, 78, 0,
		2107, 2109, 5, 5, 0, 0, 2108, 2107, 1, 0, 0, 0, 2109, 2112, 1, 0, 0, 0,
		2110, 2108, 1, 0, 0, 0, 2110, 2111, 1, 0, 0, 0, 2111, 2113, 1, 0, 0, 0,
		2112, 2110, 1, 0, 0, 0, 2113, 2117, 5, 23, 0, 0, 2114, 2116, 5, 5, 0, 0,
		2115, 2114, 1, 0, 0, 0, 2116, 2119, 1, 0, 0, 0, 2117, 2115, 1, 0, 0, 0,
		2117, 2118, 1, 0, 0, 0, 2118, 2120, 1, 0, 0, 0, 2119, 2117, 1, 0, 0, 0,
		2120, 2122, 3, 156, 78, 0, 2121, 2110, 1, 0, 0, 0, 2122, 2125, 1, 0, 0,
		0, 2123, 2121, 1, 0, 0, 0, 2123, 2124, 1, 0, 0, 0, 2124, 155, 1, 0, 0,
		0, 2125, 2123, 1, 0, 0, 0, 2126, 2143, 3, 158, 79, 0, 2127, 2129, 5, 5,
		0, 0, 2128, 2127, 1, 0, 0, 0, 2129, 2132, 1, 0, 0, 0, 2130, 2128, 1, 0,
		0, 0, 2130, 2131, 1, 0, 0, 0, 2131, 2133, 1, 0, 0, 0, 2132, 2130, 1, 0,
		0, 0, 2133, 2137, 5, 22, 0, 0, 2134, 2136, 5, 5, 0, 0, 2135, 2134, 1, 0,
		0, 0, 2136, 2139, 1, 0, 0, 0, 2137, 2135, 1, 0, 0, 0, 2137, 2138, 1, 0,
		0, 0, 2138, 2140, 1, 0, 0, 0, 2139, 2137, 1, 0, 0, 0, 2140, 2142, 3, 158,
		79, 0, 2141, 2130, 1, 0, 0, 0, 2142, 2145, 1, 0, 0, 0, 2143, 2141, 1, 0,
		0, 0, 2143, 2144, 1, 0, 0, 0, 2144, 157, 1, 0, 0, 0, 2145, 2143, 1, 0,
		0, 0, 2146, 2158, 3, 160, 80, 0, 2147, 2151, 3, 276, 138, 0, 2148, 2150,
		5, 5, 0, 0, 2149, 2148, 1, 0, 0, 0, 2150, 2153, 1, 0, 0, 0, 2151, 2149,
		1, 0, 0, 0, 2151, 2152, 1, 0, 0, 0, 2152, 2154, 1, 0, 0, 0, 2153, 2151,
		1, 0, 0, 0, 2154, 2155, 3, 160, 80, 0, 2155, 2157, 1, 0, 0, 0, 2156, 2147,
		1, 0, 0, 0, 2157, 2160, 1, 0, 0, 0, 2158, 2156, 1, 0, 0, 0, 2158, 2159,
		1, 0, 0, 0, 2159, 159, 1, 0, 0, 0, 2160, 2158, 1, 0, 0, 0, 2161, 2173,
		3, 162, 81, 0, 2162, 2166, 3, 278, 139, 0, 2163, 2165, 5, 5, 0, 0, 2164,
		2163, 1, 0, 0, 0, 2165, 2168, 1, 0, 0, 0, 2166, 2164, 1, 0, 0, 0, 2166,
		2167, 1, 0, 0, 0, 2167, 2169, 1, 0, 0, 0, 2168, 2166, 1, 0, 0, 0, 2169,
		2170, 3, 162, 81, 0, 2170, 2172, 1, 0, 0, 0, 2171, 2162, 1, 0, 0, 0, 2172,
		2175, 1, 0, 0, 0, 2173, 2171, 1, 0, 0, 0, 2173, 2174, 1, 0, 0, 0, 2174,
		161, 1, 0, 0, 0, 2175, 2173, 1, 0, 0, 0, 2176, 2180, 3, 164, 82, 0, 2177,
		2179, 3, 202, 101, 0, 2178, 2177, 1, 0, 0, 0, 2179, 2182, 1, 0, 0, 0, 2180,
		2178, 1, 0, 0, 0, 2180, 2181, 1, 0, 0, 0, 2181, 163, 1, 0, 0, 0, 2182,
		2180, 1, 0, 0, 0, 2183, 2204, 3, 166, 83, 0, 2184, 2188, 3, 280, 140, 0,
		2185, 2187, 5, 5, 0, 0, 2186, 2185, 1, 0, 0, 0, 2187, 2190, 1, 0, 0, 0,
		2188, 2186, 1, 0, 0, 0, 2188, 2189, 1, 0, 0, 0, 2189, 2191, 1, 0, 0, 0,
		2190, 2188, 1, 0, 0, 0, 2191, 2192, 3, 166, 83, 0, 2192, 2203, 1, 0, 0,
		0, 2193, 2197, 3, 282, 141, 0, 2194, 2196, 5, 5, 0, 0, 2195, 2194, 1, 0,
		0, 0, 2196, 2199, 1, 0, 0, 0, 2197, 2195, 1, 0, 0, 0, 2197, 2198, 1, 0,
		0, 0, 2198, 2200, 1, 0, 0, 0, 2199, 2197, 1, 0, 0, 0, 2200, 2201, 3, 98,
		49, 0, 2201, 2203, 1, 0, 0, 0, 2202, 2184, 1, 0, 0, 0, 2202, 2193, 1, 0,
		0, 0, 2203, 2206, 1, 0, 0, 0, 2204, 2202, 1, 0, 0, 0, 2204, 2205, 1, 0,
		0, 0, 2205, 165, 1, 0, 0, 0, 2206, 2204, 1, 0, 0, 0, 2207, 2225, 3, 170,
		85, 0, 2208, 2210, 5, 5, 0, 0, 2209, 2208, 1, 0, 0, 0, 2210, 2213, 1, 0,
		0, 0, 2211, 2209, 1, 0, 0, 0, 2211, 2212, 1, 0, 0, 0, 2212, 2214, 1, 0,
		0, 0, 2213, 2211, 1, 0, 0, 0, 2214, 2218, 3, 168, 84, 0, 2215, 2217, 5,
		5, 0, 0, 2216, 2215, 1, 0, 0, 0, 2217, 2220, 1, 0, 0, 0, 2218, 2216, 1,
		0, 0, 0, 2218, 2219, 1, 0, 0, 0, 2219, 2221, 1, 0, 0, 0, 2220, 2218, 1,
		0, 0, 0, 2221, 2222, 3, 170, 85, 0, 2222, 2224, 1, 0, 0, 0, 2223, 2211,
		1, 0, 0, 0, 2224, 2227, 1, 0, 0, 0, 2225, 2223, 1, 0, 0, 0, 2225, 2226,
		1, 0, 0, 0, 2226, 167, 1, 0, 0, 0, 2227, 2225, 1, 0, 0, 0, 2228, 2229,
		5, 46, 0, 0, 2229, 2230, 5, 26, 0, 0, 2230, 169, 1, 0, 0, 0, 2231, 2243,
		3, 172, 86, 0, 2232, 2236, 3, 344, 172, 0, 2233, 2235, 5, 5, 0, 0, 2234,
		2233, 1, 0, 0, 0, 2235, 2238, 1, 0, 0, 0, 2236, 2234, 1, 0, 0, 0, 2236,
		2237, 1, 0, 0, 0, 2237, 2239, 1, 0, 0, 0, 2238, 2236, 1, 0, 0, 0, 2239,
		2240, 3, 172, 86, 0, 2240, 2242, 1, 0, 0, 0, 2241, 2232, 1, 0, 0, 0, 2242,
		2245, 1, 0, 0, 0, 2243, 2241, 1, 0, 0, 0, 2243, 2244, 1, 0, 0, 0, 2244,
		171, 1, 0, 0, 0, 2245, 2243, 1, 0, 0, 0, 2246, 2257, 3, 174, 87, 0, 2247,
		2251, 7, 6, 0, 0, 2248, 2250, 5, 5, 0, 0, 2249, 2248, 1, 0, 0, 0, 2250,
		2253, 1, 0, 0, 0, 2251, 2249, 1, 0, 0, 0, 2251, 2252, 1, 0, 0, 0, 2252,
		2254, 1, 0, 0, 0, 2253, 2251, 1, 0, 0, 0, 2254, 2256, 3, 174, 87, 0, 2255,
		2247, 1, 0, 0, 0, 2256, 2259, 1, 0, 0, 0, 2257, 2255, 1, 0, 0, 0, 2257,
		2258, 1, 0, 0, 0, 2258, 173, 1, 0, 0, 0, 2259, 2257, 1, 0, 0, 0, 2260,
		2272, 3, 176, 88, 0, 2261, 2265, 3, 284, 142, 0, 2262, 2264, 5, 5, 0, 0,
		2263, 2262, 1, 0, 0, 0, 2264, 2267, 1, 0, 0, 0, 2265, 2263, 1, 0, 0, 0,
		2265, 2266, 1, 0, 0, 0, 2266, 2268, 1, 0, 0, 0, 2267, 2265, 1, 0, 0, 0,
		2268, 2269, 3, 176, 88, 0, 2269, 2271, 1, 0, 0, 0, 2270, 2261, 1, 0, 0,
		0, 2271, 2274, 1, 0, 0, 0, 2272, 2270, 1, 0, 0, 0, 2272, 2273, 1, 0, 0,
		0, 2273, 175, 1, 0, 0, 0, 2274, 2272, 1, 0, 0, 0, 2275, 2287, 3, 178, 89,
		0, 2276, 2280, 3, 286, 143, 0, 2277, 2279, 5, 5, 0, 0, 2278, 2277, 1, 0,
		0, 0, 2279, 2282, 1, 0, 0, 0, 2280, 2278, 1, 0, 0, 0, 2280, 2281, 1, 0,
		0, 0, 2281, 2283, 1, 0, 0, 0, 2282, 2280, 1, 0, 0, 0, 2283, 2284, 3, 178,
		89, 0, 2284, 2286, 1, 0, 0, 0, 2285, 2276, 1, 0, 0, 0, 2286, 2289, 1, 0,
		0, 0, 2287, 2285, 1, 0, 0, 0, 2287, 2288, 1, 0, 0, 0, 2288, 177, 1, 0,
		0, 0, 2289, 2287, 1, 0, 0, 0, 2290, 2308, 3, 180, 90, 0, 2291, 2293, 5,
		5, 0, 0, 2292, 2291, 1, 0, 0, 0, 2293, 2296, 1, 0, 0, 0, 2294, 2292, 1,
		0, 0, 0, 2294, 2295, 1, 0, 0, 0, 2295, 2297, 1, 0, 0, 0, 2296, 2294, 1,
		0, 0, 0, 2297, 2301, 3, 288, 144, 0, 2298, 2300, 5, 5, 0, 0, 2299, 2298,
		1, 0, 0, 0, 2300, 2303, 1, 0, 0, 0, 2301, 2299, 1, 0, 0, 0, 2301, 2302,
		1, 0, 0, 0, 2302, 2304, 1, 0, 0, 0, 2303, 2301, 1, 0, 0, 0, 2304, 2305,
		3, 98, 49, 0, 2305, 2307, 1, 0, 0, 0, 2306, 2294, 1, 0, 0, 0, 2307, 2310,
		1, 0, 0, 0, 2308, 2306, 1, 0, 0, 0, 2308, 2309, 1, 0, 0, 0, 2309, 179,
		1, 0, 0, 0, 2310, 2308, 1, 0, 0, 0, 2311, 2313, 3, 182, 91, 0, 2312, 2311,
		1, 0, 0, 0, 2313, 2316, 1, 0, 0, 0, 2314, 2312, 1, 0, 0, 0, 2314, 2315,
		1, 0, 0, 0, 2315, 2317, 1, 0, 0, 0, 2316, 2314, 1, 0, 0, 0, 2317, 2318,
		3, 184, 92, 0, 2318, 181, 1, 0, 0, 0, 2319, 2329, 3, 334, 167, 0, 2320,
		2329, 3, 132, 66, 0, 2321, 2325, 3, 290, 145, 0, 2322, 2324, 5, 5, 0, 0,
		2323, 2322, 1, 0, 0, 0, 2324, 2327, 1, 0, 0, 0, 2325, 2323, 1, 0, 0, 0,
		2325, 2326, 1, 0, 0, 0, 2326, 2329, 1, 0, 0, 0, 2327, 2325, 1, 0, 0, 0,
		2328, 2319, 1, 0, 0, 0, 2328, 2320, 1, 0, 0, 0, 2328, 2321, 1, 0, 0, 0,
		2329, 183, 1, 0, 0, 0, 2330, 2334, 3, 212, 106, 0, 2331, 2333, 3, 186,
		93, 0, 2332, 2331, 1, 0, 0, 0, 2333, 2336, 1, 0, 0, 0, 2334, 2332, 1, 0,
		0, 0, 2334, 2335, 1, 0, 0, 0, 2335, 185, 1, 0, 0, 0, 2336, 2334, 1, 0,
		0, 0, 2337, 2343, 3, 292, 146, 0, 2338, 2343, 3, 206, 103, 0, 2339, 2343,
		3, 202, 101, 0, 2340, 2343, 3, 198, 99, 0, 2341, 2343, 3, 200, 100, 0,
		2342, 2337, 1, 0, 0, 0, 2342, 2338, 1, 0, 0, 0, 2342, 2339, 1, 0, 0, 0,
		2342, 2340, 1, 0, 0, 0, 2342, 2341, 1, 0, 0, 0, 2343, 187, 1, 0, 0, 0,
		2344, 2345, 3, 184, 92, 0, 2345, 2346, 3, 196, 98, 0, 2346, 2350, 1, 0,
		0, 0, 2347, 2350, 3, 344, 172, 0, 2348, 2350, 3, 190, 95, 0, 2349, 2344,
		1, 0, 0, 0, 2349, 2347, 1, 0, 0, 0, 2349, 2348, 1, 0, 0, 0, 2350, 189,
		1, 0, 0, 0, 2351, 2355, 5, 9, 0, 0, 2352, 2354, 5, 5, 0, 0, 2353, 2352,
		1, 0, 0, 0, 2354, 2357, 1, 0, 0, 0, 2355, 2353, 1, 0, 0, 0, 2355, 2356,
		1, 0, 0, 0, 2356, 2358, 1, 0, 0, 0, 2357, 2355, 1, 0, 0, 0, 2358, 2362,
		3, 188, 94, 0, 2359, 2361, 5, 5, 0, 0, 2360, 2359, 1, 0, 0, 0, 2361, 2364,
		1, 0, 0, 0, 2362, 2360, 1, 0, 0, 0, 2362, 2363, 1, 0, 0, 0, 2363, 2365,
		1, 0, 0, 0, 2364, 2362, 1, 0, 0, 0, 2365, 2366, 5, 10, 0, 0, 2366, 191,
		1, 0, 0, 0, 2367, 2370, 3, 180, 90, 0, 2368, 2370, 3, 194, 97, 0, 2369,
		2367, 1, 0, 0, 0, 2369, 2368, 1, 0, 0, 0, 2370, 193, 1, 0, 0, 0, 2371,
		2375, 5, 9, 0, 0, 2372, 2374, 5, 5, 0, 0, 2373, 2372, 1, 0, 0, 0, 2374,
		2377, 1, 0, 0, 0, 2375, 2373, 1, 0, 0, 0, 2375, 2376, 1, 0, 0, 0, 2376,
		2378, 1, 0, 0, 0, 2377, 2375, 1, 0, 0, 0, 2378, 2382, 3, 192, 96, 0, 2379,
		2381, 5, 5, 0, 0, 2380, 2379, 1, 0, 0, 0, 2381, 2384, 1, 0, 0, 0, 2382,
		2380, 1, 0, 0, 0, 2382, 2383, 1, 0, 0, 0, 2383, 2385, 1, 0, 0, 0, 2384,
		2382, 1, 0, 0, 0, 2385, 2386, 5, 10, 0, 0, 2386, 195, 1, 0, 0, 0, 2387,
		2391, 3, 206, 103, 0, 2388, 2391, 3, 198, 99, 0, 2389, 2391, 3, 200, 100,
		0, 2390, 2387, 1, 0, 0, 0, 2390, 2388, 1, 0, 0, 0, 2390, 2389, 1, 0, 0,
		0, 2391, 197, 1, 0, 0, 0, 2392, 2396, 5, 11, 0, 0, 2393, 2395, 5, 5, 0,
		0, 2394, 2393, 1, 0, 0, 0, 2395, 2398, 1, 0, 0, 0, 2396, 2394, 1, 0, 0,
		0, 2396, 2397, 1, 0, 0, 0, 2397, 2399, 1, 0, 0, 0, 2398, 2396, 1, 0, 0,
		0, 2399, 2416, 3, 152, 76, 0, 2400, 2402, 5, 5, 0, 0, 2401, 2400, 1, 0,
		0, 0, 2402, 2405, 1, 0, 0, 0, 2403, 2401, 1, 0, 0, 0, 2403, 2404, 1, 0,
		0, 0, 2404, 2406, 1, 0, 0, 0, 2405, 2403, 1, 0, 0, 0, 2406, 2410, 5, 8,
		0, 0, 2407, 2409, 5, 5, 0, 0, 2408, 2407, 1, 0, 0, 0, 2409, 2412, 1, 0,
		0, 0, 2410, 2408, 1, 0, 0, 0, 2410, 2411, 1, 0, 0, 0, 2411, 2413, 1, 0,
		0, 0, 2412, 2410, 1, 0, 0, 0, 2413, 2415, 3, 152, 76, 0, 2414, 2403, 1,
		0, 0, 0, 2415, 2418, 1, 0, 0, 0, 2416, 2414, 1, 0, 0, 0, 2416, 2417, 1,
		0, 0, 0, 2417, 2426, 1, 0, 0, 0, 2418, 2416, 1, 0, 0, 0, 2419, 2421, 5,
		5, 0, 0, 2420, 2419, 1, 0, 0, 0, 2421, 2424, 1, 0, 0, 0, 2422, 2420, 1,
		0, 0, 0, 2422, 2423, 1, 0, 0, 0, 2423, 2425, 1, 0, 0, 0, 2424, 2422, 1,
		0, 0, 0, 2425, 2427, 5, 8, 0, 0, 2426, 2422, 1, 0, 0, 0, 2426, 2427, 1,
		0, 0, 0, 2427, 2431, 1, 0, 0, 0, 2428, 2430, 5, 5, 0, 0, 2429, 2428, 1,
		0, 0, 0, 2430, 2433, 1, 0, 0, 0, 2431, 2429, 1, 0, 0, 0, 2431, 2432, 1,
		0, 0, 0, 2432, 2434, 1, 0, 0, 0, 2433, 2431, 1, 0, 0, 0, 2434, 2435, 5,
		12, 0, 0, 2435, 199, 1, 0, 0, 0, 2436, 2440, 3, 296, 148, 0, 2437, 2439,
		5, 5, 0, 0, 2438, 2437, 1, 0, 0, 0, 2439, 2442, 1, 0, 0, 0, 2440, 2438,
		1, 0, 0, 0, 2440, 2441, 1, 0, 0, 0, 2441, 2446, 1, 0, 0, 0, 2442, 2440,
		1, 0, 0, 0, 2443, 2447, 3, 344, 172, 0, 2444, 2447, 3, 214, 107, 0, 2445,
		2447, 5, 74, 0, 0, 2446, 2443, 1, 0, 0, 0, 2446, 2444, 1, 0, 0, 0, 2446,
		2445, 1, 0, 0, 0, 2447, 201, 1, 0, 0, 0, 2448, 2450, 3, 206, 103, 0, 2449,
		2448, 1, 0, 0, 0, 2449, 2450, 1, 0, 0, 0, 2450, 2456, 1, 0, 0, 0, 2451,
		2453, 3, 208, 104, 0, 2452, 2451, 1, 0, 0, 0, 2452, 2453, 1, 0, 0, 0, 2453,
		2454, 1, 0, 0, 0, 2454, 2457, 3, 204, 102, 0, 2455, 2457, 3, 208, 104,
		0, 2456, 2452, 1, 0, 0, 0, 2456, 2455, 1, 0, 0, 0, 2457, 203, 1, 0, 0,
		0, 2458, 2460, 3, 334, 167, 0, 2459, 2458, 1, 0, 0, 0, 2460, 2463, 1, 0,
		0, 0, 2461, 2459, 1, 0, 0, 0, 2461, 2462, 1, 0, 0, 0, 2462, 2465, 1, 0,
		0, 0, 2463, 2461, 1, 0, 0, 0, 2464, 2466, 3, 132, 66, 0, 2465, 2464, 1,
		0, 0, 0, 2465, 2466, 1, 0, 0, 0, 2466, 2470, 1, 0, 0, 0, 2467, 2469, 5,
		5, 0, 0, 2468, 2467, 1, 0, 0, 0, 2469, 2472, 1, 0, 0, 0, 2470, 2468, 1,
		0, 0, 0, 2470, 2471, 1, 0, 0, 0, 2471, 2473, 1, 0, 0, 0, 2472, 2470, 1,
		0, 0, 0, 2473, 2474, 3, 234, 117, 0, 2474, 205, 1, 0, 0, 0, 2475, 2479,
		5, 47, 0, 0, 2476, 2478, 5, 5, 0, 0, 2477, 2476, 1, 0, 0, 0, 2478, 2481,
		1, 0, 0, 0, 2479, 2477, 1, 0, 0, 0, 2479, 2480, 1, 0, 0, 0, 2480, 2482,
		1, 0, 0, 0, 2481, 2479, 1, 0, 0, 0, 2482, 2499, 3, 110, 55, 0, 2483, 2485,
		5, 5, 0, 0, 2484, 2483, 1, 0, 0, 0, 2485, 2488, 1, 0, 0, 0, 2486, 2484,
		1, 0, 0, 0, 2486, 2487, 1, 0, 0, 0, 2487, 2489, 1, 0, 0, 0, 2488, 2486,
		1, 0, 0, 0, 2489, 2493, 5, 8, 0, 0, 2490, 2492, 5, 5, 0, 0, 2491, 2490,
		1, 0, 0, 0, 2492, 2495, 1, 0, 0, 0, 2493, 2491, 1, 0, 0, 0, 2493, 2494,
		1, 0, 0, 0, 2494, 2496, 1, 0, 0, 0, 2495, 2493, 1, 0, 0, 0, 2496, 2498,
		3, 110, 55, 0, 2497, 2486, 1, 0, 0, 0, 2498, 2501, 1, 0, 0, 0, 2499, 2497,
		1, 0, 0, 0, 2499, 2500, 1, 0, 0, 0, 2500, 2509, 1, 0, 0, 0, 2501, 2499,
		1, 0, 0, 0, 2502, 2504, 5, 5, 0, 0, 2503, 2502, 1, 0, 0, 0, 2504, 2507,
		1, 0, 0, 0, 2505, 2503, 1, 0, 0, 0, 2505, 2506, 1, 0, 0, 0, 2506, 2508,
		1, 0, 0, 0, 2507, 2505, 1, 0, 0, 0, 2508, 2510, 5, 8, 0, 0, 2509, 2505,
		1, 0, 0, 0, 2509, 2510, 1, 0, 0, 0, 2510, 2514, 1, 0, 0, 0, 2511, 2513,
		5, 5, 0, 0, 2512, 2511, 1, 0, 0, 0, 2513, 2516, 1, 0, 0, 0, 2514, 2512,
		1, 0, 0, 0, 2514, 2515, 1, 0, 0, 0, 2515, 2517, 1, 0, 0, 0, 2516, 2514,
		1, 0, 0, 0, 2517, 2518, 5, 48, 0, 0, 2518, 207, 1, 0, 0, 0, 2519, 2523,
		5, 9, 0, 0, 2520, 2522, 5, 5, 0, 0, 2521, 2520, 1, 0, 0, 0, 2522, 2525,
		1, 0, 0, 0, 2523, 2521, 1, 0, 0, 0, 2523, 2524, 1, 0, 0, 0, 2524, 2561,
		1, 0, 0, 0, 2525, 2523, 1, 0, 0, 0, 2526, 2543, 3, 210, 105, 0, 2527, 2529,
		5, 5, 0, 0, 2528, 2527, 1, 0, 0, 0, 2529, 2532, 1, 0, 0, 0, 2530, 2528,
		1, 0, 0, 0, 2530, 2531, 1, 0, 0, 0, 2531, 2533, 1, 0, 0, 0, 2532, 2530,
		1, 0, 0, 0, 2533, 2537, 5, 8, 0, 0, 2534, 2536, 5, 5, 0, 0, 2535, 2534,
		1, 0, 0, 0, 2536, 2539, 1, 0, 0, 0, 2537, 2535, 1, 0, 0, 0, 2537, 2538,
		1, 0, 0, 0, 2538, 2540, 1, 0, 0, 0, 2539, 2537, 1, 0, 0, 0, 2540, 2542,
		3, 210, 105, 0, 2541, 2530, 1, 0, 0, 0, 2542, 2545, 1, 0, 0, 0, 2543, 2541,
		1, 0, 0, 0, 2543, 2544, 1, 0, 0, 0, 2544, 2553, 1, 0, 0, 0, 2545, 2543,
		1, 0, 0, 0, 2546, 2548, 5, 5, 0, 0, 2547, 2546, 1, 0, 0, 0, 2548, 2551,
		1, 0, 0, 0, 2549, 2547, 1, 0, 0, 0, 2549, 2550, 1, 0, 0, 0, 2550, 2552,
		1, 0, 0, 0, 2551, 2549, 1, 0, 0, 0, 2552, 2554, 5, 8, 0, 0, 2553, 2549,
		1, 0, 0, 0, 2553, 2554, 1, 0, 0, 0, 2554, 2558, 1, 0, 0, 0, 2555, 2557,
		5, 5, 0, 0, 2556, 2555, 1, 0, 0, 0, 2557, 2560, 1, 0, 0, 0, 2558, 2556,
		1, 0, 0, 0, 2558, 2559, 1, 0, 0, 0, 2559, 2562, 1, 0, 0, 0, 2560, 2558,
		1, 0, 0, 0, 2561, 2526, 1, 0, 0, 0, 2561, 2562, 1, 0, 0, 0, 2562, 2563,
		1, 0, 0, 0, 2563, 2564, 5, 10, 0, 0, 2564, 209, 1, 0, 0, 0, 2565, 2567,
		3, 334, 167, 0, 2566, 2565, 1, 0, 0, 0, 2566, 2567, 1, 0, 0, 0, 2567, 2571,
		1, 0, 0, 0, 2568, 2570, 5, 5, 0, 0, 2569, 2568, 1, 0, 0, 0, 2570, 2573,
		1, 0, 0, 0, 2571, 2569, 1, 0, 0, 0, 2571, 2572, 1, 0, 0, 0, 2572, 2588,
		1, 0, 0, 0, 2573, 2571, 1, 0, 0, 0, 2574, 2578, 3, 344, 172, 0, 2575, 2577,
		5, 5, 0, 0, 2576, 2575, 1, 0, 0, 0, 2577, 2580, 1, 0, 0, 0, 2578, 2576,
		1, 0, 0, 0, 2578, 2579, 1, 0, 0, 0, 2579, 2581, 1, 0, 0, 0, 2580, 2578,
		1, 0, 0, 0, 2581, 2585, 5, 28, 0, 0, 2582, 2584, 5, 5, 0, 0, 2583, 2582,
		1, 0, 0, 0, 2584, 2587, 1, 0, 0, 0, 2585, 2583, 1, 0, 0, 0, 2585, 2586,
		1, 0, 0, 0, 2586, 2589, 1, 0, 0, 0, 2587, 2585, 1, 0, 0, 0, 2588, 2574,
		1, 0, 0, 0, 2588, 2589, 1, 0, 0, 0, 2589, 2591, 1, 0, 0, 0, 2590, 2592,
		5, 15, 0, 0, 2591, 2590, 1, 0, 0, 0, 2591, 2592, 1, 0, 0, 0, 2592, 2596,
		1, 0, 0, 0, 2593, 2595, 5, 5, 0, 0, 2594, 2593, 1, 0, 0, 0, 2595, 2598,
		1, 0, 0, 0, 2596, 2594, 1, 0, 0, 0, 2596, 2597, 1, 0, 0, 0, 2597, 2599,
		1, 0, 0, 0, 2598, 2596, 1, 0, 0, 0, 2599, 2600, 3, 152, 76, 0, 2600, 211,
		1, 0, 0, 0, 2601, 2616, 3, 214, 107, 0, 2602, 2616, 3, 344, 172, 0, 2603,
		2616, 3, 218, 109, 0, 2604, 2616, 3, 220, 110, 0, 2605, 2616, 3, 272, 136,
		0, 2606, 2616, 3, 242, 121, 0, 2607, 2616, 3, 244, 122, 0, 2608, 2616,
		3, 216, 108, 0, 2609, 2616, 3, 246, 123, 0, 2610, 2616, 3, 248, 124, 0,
		2611, 2616, 3, 250, 125, 0, 2612, 2616, 3, 254, 127, 0, 2613, 2616, 3,
		264, 132, 0, 2614, 2616, 3, 270, 135, 0, 2615, 2601, 1, 0, 0, 0, 2615,
		2602, 1, 0, 0, 0, 2615, 2603, 1, 0, 0, 0, 2615, 2604, 1, 0, 0, 0, 2615,
		2605, 1, 0, 0, 0, 2615, 2606, 1, 0, 0, 0, 2615, 2607, 1, 0, 0, 0, 2615,
		2608, 1, 0, 0, 0, 2615, 2609, 1, 0, 0, 0, 2615, 2610, 1, 0, 0, 0, 2615,
		2611, 1, 0, 0, 0, 2615, 2612, 1, 0, 0, 0, 2615, 2613, 1, 0, 0, 0, 2615,
		2614, 1, 0, 0, 0, 2616, 213, 1, 0, 0, 0, 2617, 2621, 5, 9, 0, 0, 2618,
		2620, 5, 5, 0, 0, 2619, 2618, 1, 0, 0, 0, 2620, 2623, 1, 0, 0, 0, 2621,
		2619, 1, 0, 0, 0, 2621, 2622, 1, 0, 0, 0, 2622, 2624, 1, 0, 0, 0, 2623,
		2621, 1, 0, 0, 0, 2624, 2628, 3, 152, 76, 0, 2625, 2627, 5, 5, 0, 0, 2626,
		2625, 1, 0, 0, 0, 2627, 2630, 1, 0, 0, 0, 2628, 2626, 1, 0, 0, 0, 2628,
		2629, 1, 0, 0, 0, 2629, 2631, 1, 0, 0, 0, 2630, 2628, 1, 0, 0, 0, 2631,
		2632, 5, 10, 0, 0, 2632, 215, 1, 0, 0, 0, 2633, 2637, 5, 11, 0, 0, 2634,
		2636, 5, 5, 0, 0, 2635, 2634, 1, 0, 0, 0, 2636, 2639, 1, 0, 0, 0, 2637,
		2635, 1, 0, 0, 0, 2637, 2638, 1, 0, 0, 0, 2638, 2675, 1, 0, 0, 0, 2639,
		2637, 1, 0, 0, 0, 2640, 2657, 3, 152, 76, 0, 2641, 2643, 5, 5, 0, 0, 2642,
		2641, 1, 0, 0, 0, 2643, 2646, 1, 0, 0, 0, 2644, 2642, 1, 0, 0, 0, 2644,
		2645, 1, 0, 0, 0, 2645, 2647, 1, 0, 0, 0, 2646, 2644, 1, 0, 0, 0, 2647,
		2651, 5, 8, 0, 0, 2648, 2650, 5, 5, 0, 0, 2649, 2648, 1, 0, 0, 0, 2650,
		2653, 1, 0, 0, 0, 2651, 2649, 1, 0, 0, 0, 2651, 2652, 1, 0, 0, 0, 2652,
		2654, 1, 0, 0, 0, 2653, 2651, 1, 0, 0, 0, 2654, 2656, 3, 152, 76, 0, 2655,
		2644, 1, 0, 0, 0, 2656, 2659, 1, 0, 0, 0, 2657, 2655, 1, 0, 0, 0, 2657,
		2658, 1, 0, 0, 0, 2658, 2667, 1, 0, 0, 0, 2659, 2657, 1, 0, 0, 0, 2660,
		2662, 5, 5, 0, 0, 2661, 2660, 1, 0, 0, 0, 2662, 2665, 1, 0, 0, 0, 2663,
		2661, 1, 0, 0, 0, 2663, 2664, 1, 0, 0, 0, 2664, 2666, 1, 0, 0, 0, 2665,
		2663, 1, 0, 0, 0, 2666, 2668, 5, 8, 0, 0, 2667, 2663, 1, 0, 0, 0, 2667,
		2668, 1, 0, 0, 0, 2668, 2672, 1, 0, 0, 0, 2669, 2671, 5, 5, 0, 0, 2670,
		2669, 1, 0, 0, 0, 2671, 2674, 1, 0, 0, 0, 2672, 2670, 1, 0, 0, 0, 2672,
		2673, 1, 0, 0, 0, 2673, 2676, 1, 0, 0, 0, 2674, 2672, 1, 0, 0, 0, 2675,
		2640, 1, 0, 0, 0, 2675, 2676, 1, 0, 0, 0, 2676, 2677, 1, 0, 0, 0, 2677,
		2678, 5, 12, 0, 0, 2678, 217, 1, 0, 0, 0, 2679, 2680, 7, 7, 0, 0, 2680,
		219, 1, 0, 0, 0, 2681, 2684, 3, 222, 111, 0, 2682, 2684, 3, 224, 112, 0,
		2683, 2681, 1, 0, 0, 0, 2683, 2682, 1, 0, 0, 0, 2684, 221, 1, 0, 0, 0,
		2685, 2690, 5, 151, 0, 0, 2686, 2689, 3, 226, 113, 0, 2687, 2689, 3, 228,
		114, 0, 2688, 2686, 1, 0, 0, 0, 2688, 2687, 1, 0, 0, 0, 2689, 2692, 1,
		0, 0, 0, 2690, 2688, 1, 0, 0, 0, 2690, 2691, 1, 0, 0, 0, 2691, 2693, 1,
		0, 0, 0, 2692, 2690, 1, 0, 0, 0, 2693, 2694, 5, 160, 0, 0, 2694, 223, 1,
		0, 0, 0, 2695, 2701, 5, 152, 0, 0, 2696, 2700, 3, 230, 115, 0, 2697, 2700,
		3, 232, 116, 0, 2698, 2700, 5, 166, 0, 0, 2699, 2696, 1, 0, 0, 0, 2699,
		2697, 1, 0, 0, 0, 2699, 2698, 1, 0, 0, 0, 2700, 2703, 1, 0, 0, 0, 2701,
		2699, 1, 0, 0, 0, 2701, 2702, 1, 0, 0, 0, 2702, 2704, 1, 0, 0, 0, 2703,
		2701, 1, 0, 0, 0, 2704, 2705, 5, 165, 0, 0, 2705, 225, 1, 0, 0, 0, 2706,
		2707, 7, 8, 0, 0, 2707, 227, 1, 0, 0, 0, 2708, 2712, 5, 164, 0, 0, 2709,
		2711, 5, 5, 0, 0, 2710, 2709, 1, 0, 0, 0, 2711, 2714, 1, 0, 0, 0, 2712,
		2710, 1, 0, 0, 0, 2712, 2713, 1, 0, 0, 0, 2713, 2715, 1, 0, 0, 0, 2714,
		2712, 1, 0, 0, 0, 2715, 2719, 3, 152, 76, 0, 2716, 2718, 5, 5, 0, 0, 2717,
		2716, 1, 0, 0, 0, 2718, 2721, 1, 0, 0, 0, 2719, 2717, 1, 0, 0, 0, 2719,
		2720, 1, 0, 0, 0, 2720, 2722, 1, 0, 0, 0, 2721, 2719, 1, 0, 0, 0, 2722,
		2723, 5, 14, 0, 0, 2723, 229, 1, 0, 0, 0, 2724, 2725, 7, 9, 0, 0, 2725,
		231, 1, 0, 0, 0, 2726, 2730, 5, 169, 0, 0, 2727, 2729, 5, 5, 0, 0, 2728,
		2727, 1, 0, 0, 0, 2729, 2732, 1, 0, 0, 0, 2730, 2728, 1, 0, 0, 0, 2730,
		2731, 1, 0, 0, 0, 2731, 2733, 1, 0, 0, 0, 2732, 2730, 1, 0, 0, 0, 2733,
		2737, 3, 152, 76, 0, 2734, 2736, 5, 5, 0, 0, 2735, 2734, 1, 0, 0, 0, 2736,
		2739, 1, 0, 0, 0, 2737, 2735, 1, 0, 0, 0, 2737, 2738, 1, 0, 0, 0, 2738,
		2740, 1, 0, 0, 0, 2739, 2737, 1, 0, 0, 0, 2740, 2741, 5, 14, 0, 0, 2741,
		233, 1, 0, 0, 0, 2742, 2746, 5, 13, 0, 0, 2743, 2745, 5, 5, 0, 0, 2744,
		2743, 1, 0, 0, 0, 2745, 2748, 1, 0, 0, 0, 2746, 2744, 1, 0, 0, 0, 2746,
		2747, 1, 0, 0, 0, 2747, 2765, 1, 0, 0, 0, 2748, 2746, 1, 0, 0, 0, 2749,
		2751, 3, 236, 118, 0, 2750, 2749, 1, 0, 0, 0, 2750, 2751, 1, 0, 0, 0, 2751,
		2755, 1, 0, 0, 0, 2752, 2754, 5, 5, 0, 0, 2753, 2752, 1, 0, 0, 0, 2754,
		2757, 1, 0, 0, 0, 2755, 2753, 1, 0, 0, 0, 2755, 2756, 1, 0, 0, 0, 2756,
		2758, 1, 0, 0, 0, 2757, 2755, 1, 0, 0, 0, 2758, 2762, 5, 34, 0, 0, 2759,
		2761, 5, 5, 0, 0, 2760, 2759, 1, 0, 0, 0, 2761, 2764, 1, 0, 0, 0, 2762,
		2760, 1, 0, 0, 0, 2762, 2763, 1, 0, 0, 0, 2763, 2766, 1, 0, 0, 0, 2764,
		2762, 1, 0, 0, 0, 2765, 2750, 1, 0, 0, 0, 2765, 2766, 1, 0, 0, 0, 2766,
		2767, 1, 0, 0, 0, 2767, 2771, 3, 128, 64, 0, 2768, 2770, 5, 5, 0, 0, 2769,
		2768, 1, 0, 0, 0, 2770, 2773, 1, 0, 0, 0, 2771, 2769, 1, 0, 0, 0, 2771,
		2772, 1, 0, 0, 0, 2772, 2774, 1, 0, 0, 0, 2773, 2771, 1, 0, 0, 0, 2774,
		2775, 5, 14, 0, 0, 2775, 235, 1, 0, 0, 0, 2776, 2793, 3, 238, 119, 0, 2777,
		2779, 5, 5, 0, 0, 2778, 2777, 1, 0, 0, 0, 2779, 2782, 1, 0, 0, 0, 2780,
		2778, 1, 0, 0, 0, 2780, 2781, 1, 0, 0, 0, 2781, 2783, 1, 0, 0, 0, 2782,
		2780, 1, 0, 0, 0, 2783, 2787, 5, 8, 0, 0, 2784, 2786, 5, 5, 0, 0, 2785,
		2784, 1, 0, 0, 0, 2786, 2789, 1, 0, 0, 0, 2787, 2785, 1, 0, 0, 0, 2787,
		2788, 1, 0, 0, 0, 2788, 2790, 1, 0, 0, 0, 2789, 2787, 1, 0, 0, 0, 2790,
		2792, 3, 238, 119, 0, 2791, 2780, 1, 0, 0, 0, 2792, 2795, 1, 0, 0, 0, 2793,
		2791, 1, 0, 0, 0, 2793, 2794, 1, 0, 0, 0, 2794, 2803, 1, 0, 0, 0, 2795,
		2793, 1, 0, 0, 0, 2796, 2798, 5, 5, 0, 0, 2797, 2796, 1, 0, 0, 0, 2798,
		2801, 1, 0, 0, 0, 2799, 2797, 1, 0, 0, 0, 2799, 2800, 1, 0, 0, 0, 2800,
		2802, 1, 0, 0, 0, 2801, 2799, 1, 0, 0, 0, 2802, 2804, 5, 8, 0, 0, 2803,
		2799, 1, 0, 0, 0, 2803, 2804, 1, 0, 0, 0, 2804, 237, 1, 0, 0, 0, 2805,
		2824, 3, 66, 33, 0, 2806, 2821, 3, 68, 34, 0, 2807, 2809, 5, 5, 0, 0, 2808,
		2807, 1, 0, 0, 0, 2809, 2812, 1, 0, 0, 0, 2810, 2808, 1, 0, 0, 0, 2810,
		2811, 1, 0, 0, 0, 2811, 2813, 1, 0, 0, 0, 2812, 2810, 1, 0, 0, 0, 2813,
		2817, 5, 26, 0, 0, 2814, 2816, 5, 5, 0, 0, 2815, 2814, 1, 0, 0, 0, 2816,
		2819, 1, 0, 0, 0, 2817, 2815, 1, 0, 0, 0, 2817, 2818, 1, 0, 0, 0, 2818,
		2820, 1, 0, 0, 0, 2819, 2817, 1, 0, 0, 0, 2820, 2822, 3, 98, 49, 0, 2821,
		2810, 1, 0, 0, 0, 2821, 2822, 1, 0, 0, 0, 2822, 2824, 1, 0, 0, 0, 2823,
		2805, 1, 0, 0, 0, 2823, 2806, 1, 0, 0, 0, 2824, 239, 1, 0, 0, 0, 2825,
		2827, 5, 124, 0, 0, 2826, 2825, 1, 0, 0, 0, 2826, 2827, 1, 0, 0, 0, 2827,
		2831, 1, 0, 0, 0, 2828, 2830, 5, 5, 0, 0, 2829, 2828, 1, 0, 0, 0, 2830,
		2833, 1, 0, 0, 0, 2831, 2829, 1, 0, 0, 0, 2831, 2832, 1, 0, 0, 0, 2832,
		2834, 1, 0, 0, 0, 2833, 2831, 1, 0, 0, 0, 2834, 2850, 5, 76, 0, 0, 2835,
		2837, 5, 5, 0, 0, 2836, 2835, 1, 0, 0, 0, 2837, 2840, 1, 0, 0, 0, 2838,
		2836, 1, 0, 0, 0, 2838, 2839, 1, 0, 0, 0, 2839, 2841, 1, 0, 0, 0, 2840,
		2838, 1, 0, 0, 0, 2841, 2845, 3, 98, 49, 0, 2842, 2844, 5, 5, 0, 0, 2843,
		2842, 1, 0, 0, 0, 2844, 2847, 1, 0, 0, 0, 2845, 2843, 1, 0, 0, 0, 2845,
		2846, 1, 0, 0, 0, 2846, 2848, 1, 0, 0, 0, 2847, 2845, 1, 0, 0, 0, 2848,
		2849, 5, 7, 0, 0, 2849, 2851, 1, 0, 0, 0, 2850, 2838, 1, 0, 0, 0, 2850,
		2851, 1, 0, 0, 0, 2851, 2855, 1, 0, 0, 0, 2852, 2854, 5, 5, 0, 0, 2853,
		2852, 1, 0, 0, 0, 2854, 2857, 1, 0, 0, 0, 2855, 2853, 1, 0, 0, 0, 2855,
		2856, 1, 0, 0, 0, 2856, 2858, 1, 0, 0, 0, 2857, 2855, 1, 0, 0, 0, 2858,
		2873, 3, 78, 39, 0, 2859, 2861, 5, 5, 0, 0, 2860, 2859, 1, 0, 0, 0, 2861,
		2864, 1, 0, 0, 0, 2862, 2860, 1, 0, 0, 0, 2862, 2863, 1, 0, 0, 0, 2863,
		2865, 1, 0, 0, 0, 2864, 2862, 1, 0, 0, 0, 2865, 2869, 5, 26, 0, 0, 2866,
		2868, 5, 5, 0, 0, 2867, 2866, 1, 0, 0, 0, 2868, 2871, 1, 0, 0, 0, 2869,
		2867, 1, 0, 0, 0, 2869, 2870, 1, 0, 0, 0, 2870, 2872, 1, 0, 0, 0, 2871,
		2869, 1, 0, 0, 0, 2872, 2874, 3, 98, 49, 0, 2873, 2862, 1, 0, 0, 0, 2873,
		2874, 1, 0, 0, 0, 2874, 2882, 1, 0, 0, 0, 2875, 2877, 5, 5, 0, 0, 2876,
		2875, 1, 0, 0, 0, 2877, 2880, 1, 0, 0, 0, 2878, 2876, 1, 0, 0, 0, 2878,
		2879, 1, 0, 0, 0, 2879, 2881, 1, 0, 0, 0, 2880, 2878, 1, 0, 0, 0, 2881,
		2883, 3, 46, 23, 0, 2882, 2878, 1, 0, 0, 0, 2882, 2883, 1, 0, 0, 0, 2883,
		2891, 1, 0, 0, 0, 2884, 2886, 5, 5, 0, 0, 2885, 2884, 1, 0, 0, 0, 2886,
		2889, 1, 0, 0, 0, 2887, 2885, 1, 0, 0, 0, 2887, 2888, 1, 0, 0, 0, 2888,
		2890, 1, 0, 0, 0, 2889, 2887, 1, 0, 0, 0, 2890, 2892, 3, 64, 32, 0, 2891,
		2887, 1, 0, 0, 0, 2891, 2892, 1, 0, 0, 0, 2892, 241, 1, 0, 0, 0, 2893,
		2896, 3, 234, 117, 0, 2894, 2896, 3, 240, 120, 0, 2895, 2893, 1, 0, 0,
		0, 2895, 2894, 1, 0, 0, 0, 2896, 243, 1, 0, 0, 0, 2897, 2899, 5, 116, 0,
		0, 2898, 2897, 1, 0, 0, 0, 2898, 2899, 1, 0, 0, 0, 2899, 2903, 1, 0, 0,
		0, 2900, 2902, 5, 5, 0, 0, 2901, 2900, 1, 0, 0, 0, 2902, 2905, 1, 0, 0,
		0, 2903, 2901, 1, 0, 0, 0, 2903, 2904, 1, 0, 0, 0, 2904, 2906, 1, 0, 0,
		0, 2905, 2903, 1, 0, 0, 0, 2906, 2927, 5, 77, 0, 0, 2907, 2909, 5, 5, 0,
		0, 2908, 2907, 1, 0, 0, 0, 2909, 2912, 1, 0, 0, 0, 2910, 2908, 1, 0, 0,
		0, 2910, 2911, 1, 0, 0, 0, 2911, 2913, 1, 0, 0, 0, 2912, 2910, 1, 0, 0,
		0, 2913, 2917, 5, 26, 0, 0, 2914, 2916, 5, 5, 0, 0, 2915, 2914, 1, 0, 0,
		0, 2916, 2919, 1, 0, 0, 0, 2917, 2915, 1, 0, 0, 0, 2917, 2918, 1, 0, 0,
		0, 2918, 2920, 1, 0, 0, 0, 2919, 2917, 1, 0, 0, 0, 2920, 2924, 3, 32, 16,
		0, 2921, 2923, 5, 5, 0, 0, 2922, 2921, 1, 0, 0, 0, 2923, 2926, 1, 0, 0,
		0, 2924, 2922, 1, 0, 0, 0, 2924, 2925, 1, 0, 0, 0, 2925, 2928, 1, 0, 0,
		0, 2926, 2924, 1, 0, 0, 0, 2927, 2910, 1, 0, 0, 0, 2927, 2928, 1, 0, 0,
		0, 2928, 2936, 1, 0, 0, 0, 2929, 2931, 5, 5, 0, 0, 2930, 2929, 1, 0, 0,
		0, 2931, 2934, 1, 0, 0, 0, 2932, 2930, 1, 0, 0, 0, 2932, 2933, 1, 0, 0,
		0, 2933, 2935, 1, 0, 0, 0, 2934, 2932, 1, 0, 0, 0, 2935, 2937, 3, 26, 13,
		0, 2936, 2932, 1, 0, 0, 0, 2936, 2937, 1, 0, 0, 0, 2937, 245, 1, 0, 0,
		0, 2938, 2939, 7, 10, 0, 0, 2939, 247, 1, 0, 0, 0, 2940, 2957, 5, 86, 0,
		0, 2941, 2945, 5, 47, 0, 0, 2942, 2944, 5, 5, 0, 0, 2943, 2942, 1, 0, 0,
		0, 2944, 2947, 1, 0, 0, 0, 2945, 2943, 1, 0, 0, 0, 2945, 2946, 1, 0, 0,
		0, 2946, 2948, 1, 0, 0, 0, 2947, 2945, 1, 0, 0, 0, 2948, 2952, 3, 98, 49,
		0, 2949, 2951, 5, 5, 0, 0, 2950, 2949, 1, 0, 0, 0, 2951, 2954, 1, 0, 0,
		0, 2952, 2950, 1, 0, 0, 0, 2952, 2953, 1, 0, 0, 0, 2953, 2955, 1, 0, 0,
		0, 2954, 2952, 1, 0, 0, 0, 2955, 2956, 5, 48, 0, 0, 2956, 2958, 1, 0, 0,
		0, 2957, 2941, 1, 0, 0, 0, 2957, 2958, 1, 0, 0, 0, 2958, 2961, 1, 0, 0,
		0, 2959, 2960, 5, 41, 0, 0, 2960, 2962, 3, 344, 172, 0, 2961, 2959, 1,
		0, 0, 0, 2961, 2962, 1, 0, 0, 0, 2962, 2965, 1, 0, 0, 0, 2963, 2965, 5,
		62, 0, 0, 2964, 2940, 1, 0, 0, 0, 2964, 2963, 1, 0, 0, 0, 2965, 249, 1,
		0, 0, 0, 2966, 2970, 5, 89, 0, 0, 2967, 2969, 5, 5, 0, 0, 2968, 2967, 1,
		0, 0, 0, 2969, 2972, 1, 0, 0, 0, 2970, 2968, 1, 0, 0, 0, 2970, 2971, 1,
		0, 0, 0, 2971, 2973, 1, 0, 0, 0, 2972, 2970, 1, 0, 0, 0, 2973, 2977, 5,
		9, 0, 0, 2974, 2976, 5, 5, 0, 0, 2975, 2974, 1, 0, 0, 0, 2976, 2979, 1,
		0, 0, 0, 2977, 2975, 1, 0, 0, 0, 2977, 2978, 1, 0, 0, 0, 2978, 2980, 1,
		0, 0, 0, 2979, 2977, 1, 0, 0, 0, 2980, 2984, 3, 152, 76, 0, 2981, 2983,
		5, 5, 0, 0, 2982, 2981, 1, 0, 0, 0, 2983, 2986, 1, 0, 0, 0, 2984, 2982,
		1, 0, 0, 0, 2984, 2985, 1, 0, 0, 0, 2985, 2987, 1, 0, 0, 0, 2986, 2984,
		1, 0, 0, 0, 2987, 2991, 5, 10, 0, 0, 2988, 2990, 5, 5, 0, 0, 2989, 2988,
		1, 0, 0, 0, 2990, 2993, 1, 0, 0, 0, 2991, 2989, 1, 0, 0, 0, 2991, 2992,
		1, 0, 0, 0, 2992, 3025, 1, 0, 0, 0, 2993, 2991, 1, 0, 0, 0, 2994, 3026,
		3, 134, 67, 0, 2995, 2997, 3, 134, 67, 0, 2996, 2995, 1, 0, 0, 0, 2996,
		2997, 1, 0, 0, 0, 2997, 3001, 1, 0, 0, 0, 2998, 3000, 5, 5, 0, 0, 2999,
		2998, 1, 0, 0, 0, 3000, 3003, 1, 0, 0, 0, 3001, 2999, 1, 0, 0, 0, 3001,
		3002, 1, 0, 0, 0, 3002, 3005, 1, 0, 0, 0, 3003, 3001, 1, 0, 0, 0, 3004,
		3006, 5, 27, 0, 0, 3005, 3004, 1, 0, 0, 0, 3005, 3006, 1, 0, 0, 0, 3006,
		3010, 1, 0, 0, 0, 3007, 3009, 5, 5, 0, 0, 3008, 3007, 1, 0, 0, 0, 3009,
		3012, 1, 0, 0, 0, 3010, 3008, 1, 0, 0, 0, 3010, 3011, 1, 0, 0, 0, 3011,
		3013, 1, 0, 0, 0, 3012, 3010, 1, 0, 0, 0, 3013, 3017, 5, 90, 0, 0, 3014,
		3016, 5, 5, 0, 0, 3015, 3014, 1, 0, 0, 0, 3016, 3019, 1, 0, 0, 0, 3017,
		3015, 1, 0, 0, 0, 3017, 3018, 1, 0, 0, 0, 3018, 3022, 1, 0, 0, 0, 3019,
		3017, 1, 0, 0, 0, 3020, 3023, 3, 134, 67, 0, 3021, 3023, 5, 27, 0, 0, 3022,
		3020, 1, 0, 0, 0, 3022, 3021, 1, 0, 0, 0, 3023, 3026, 1, 0, 0, 0, 3024,
		3026, 5, 27, 0, 0, 3025, 2994, 1, 0, 0, 0, 3025, 2996, 1, 0, 0, 0, 3025,
		3024, 1, 0, 0, 0, 3026, 251, 1, 0, 0, 0, 3027, 3061, 5, 9, 0, 0, 3028,
		3030, 3, 334, 167, 0, 3029, 3028, 1, 0, 0, 0, 3030, 3033, 1, 0, 0, 0, 3031,
		3029, 1, 0, 0, 0, 3031, 3032, 1, 0, 0, 0, 3032, 3037, 1, 0, 0, 0, 3033,
		3031, 1, 0, 0, 0, 3034, 3036, 5, 5, 0, 0, 3035, 3034, 1, 0, 0, 0, 3036,
		3039, 1, 0, 0, 0, 3037, 3035, 1, 0, 0, 0, 3037, 3038, 1, 0, 0, 0, 3038,
		3040, 1, 0, 0, 0, 3039, 3037, 1, 0, 0, 0, 3040, 3044, 5, 78, 0, 0, 3041,
		3043, 5, 5, 0, 0, 3042, 3041, 1, 0, 0, 0, 3043, 3046, 1, 0, 0, 0, 3044,
		3042, 1, 0, 0, 0, 3044, 3045, 1, 0, 0, 0, 3045, 3047, 1, 0, 0, 0, 3046,
		3044, 1, 0, 0, 0, 3047, 3051, 3, 66, 33, 0, 3048, 3050, 5, 5, 0, 0, 3049,
		3048, 1, 0, 0, 0, 3050, 3053, 1, 0, 0, 0, 3051, 3049, 1, 0, 0, 0, 3051,
		3052, 1, 0, 0, 0, 3052, 3054, 1, 0, 0, 0, 3053, 3051, 1, 0, 0, 0, 3054,
		3058, 5, 28, 0, 0, 3055, 3057, 5, 5, 0, 0, 3056, 3055, 1, 0, 0, 0, 3057,
		3060, 1, 0, 0, 0, 3058, 3056, 1, 0, 0, 0, 3058, 3059, 1, 0, 0, 0, 3059,
		3062, 1, 0, 0, 0, 3060, 3058, 1, 0, 0, 0, 3061, 3031, 1, 0, 0, 0, 3061,
		3062, 1, 0, 0, 0, 3062, 3063, 1, 0, 0, 0, 3063, 3064, 3, 152, 76, 0, 3064,
		3065, 5, 10, 0, 0, 3065, 253, 1, 0, 0, 0, 3066, 3070, 5, 91, 0, 0, 3067,
		3069, 5, 5, 0, 0, 3068, 3067, 1, 0, 0, 0, 3069, 3072, 1, 0, 0, 0, 3070,
		3068, 1, 0, 0, 0, 3070, 3071, 1, 0, 0, 0, 3071, 3074, 1, 0, 0, 0, 3072,
		3070, 1, 0, 0, 0, 3073, 3075, 3, 252, 126, 0, 3074, 3073, 1, 0, 0, 0, 3074,
		3075, 1, 0, 0, 0, 3075, 3079, 1, 0, 0, 0, 3076, 3078, 5, 5, 0, 0, 3077,
		3076, 1, 0, 0, 0, 3078, 3081, 1, 0, 0, 0, 3079, 3077, 1, 0, 0, 0, 3079,
		3080, 1, 0, 0, 0, 3080, 3082, 1, 0, 0, 0, 3081, 3079, 1, 0, 0, 0, 3082,
		3086, 5, 13, 0, 0, 3083, 3085, 5, 5, 0, 0, 3084, 3083, 1, 0, 0, 0, 3085,
		3088, 1, 0, 0, 0, 3086, 3084, 1, 0, 0, 0, 3086, 3087, 1, 0, 0, 0, 3087,
		3098, 1, 0, 0, 0, 3088, 3086, 1, 0, 0, 0, 3089, 3093, 3, 256, 128, 0, 3090,
		3092, 5, 5, 0, 0, 3091, 3090, 1, 0, 0, 0, 3092, 3095, 1, 0, 0, 0, 3093,
		3091, 1, 0, 0, 0, 3093, 3094, 1, 0, 0, 0, 3094, 3097, 1, 0, 0, 0, 3095,
		3093, 1, 0, 0, 0, 3096, 3089, 1, 0, 0, 0, 3097, 3100, 1, 0, 0, 0, 3098,
		3096, 1, 0, 0, 0, 3098, 3099, 1, 0, 0, 0, 3099, 3104, 1, 0, 0, 0, 3100,
		3098, 1, 0, 0, 0, 3101, 3103, 5, 5, 0, 0, 3102, 3101, 1, 0, 0, 0, 3103,
		3106, 1, 0, 0, 0, 3104, 3102, 1, 0, 0, 0, 3104, 3105, 1, 0, 0, 0, 3105,
		3107, 1, 0, 0, 0, 3106, 3104, 1, 0, 0, 0, 3107, 3108, 5, 14, 0, 0, 3108,
		255, 1, 0, 0, 0, 3109, 3126, 3, 258, 129, 0, 3110, 3112, 5, 5, 0, 0, 3111,
		3110, 1, 0, 0, 0, 3112, 3115, 1, 0, 0, 0, 3113, 3111, 1, 0, 0, 0, 3113,
		3114, 1, 0, 0, 0, 3114, 3116, 1, 0, 0, 0, 3115, 3113, 1, 0, 0, 0, 3116,
		3120, 5, 8, 0, 0, 3117, 3119, 5, 5, 0, 0, 3118, 3117, 1, 0, 0, 0, 3119,
		3122, 1, 0, 0, 0, 3120, 3118, 1, 0, 0, 0, 3120, 3121, 1, 0, 0, 0, 3121,
		3123, 1, 0, 0, 0, 3122, 3120, 1, 0, 0, 0, 3123, 3125, 3, 258, 129, 0, 3124,
		3113, 1, 0, 0, 0, 3125, 3128, 1, 0, 0, 0, 3126, 3124, 1, 0, 0, 0, 3126,
		3127, 1, 0, 0, 0, 3127, 3136, 1, 0, 0, 0, 3128, 3126, 1, 0, 0, 0, 3129,
		3131, 5, 5, 0, 0, 3130, 3129, 1, 0, 0, 0, 3131, 3134, 1, 0, 0, 0, 3132,
		3130, 1, 0, 0, 0, 3132, 3133, 1, 0, 0, 0, 3133, 3135, 1, 0, 0, 0, 3134,
		3132, 1, 0, 0, 0, 3135, 3137, 5, 8, 0, 0, 3136, 3132, 1, 0, 0, 0, 3136,
		3137, 1, 0, 0, 0, 3137, 3141, 1, 0, 0, 0, 3138, 3140, 5, 5, 0, 0, 3139,
		3138, 1, 0, 0, 0, 3140, 3143, 1, 0, 0, 0, 3141, 3139, 1, 0, 0, 0, 3141,
		3142, 1, 0, 0, 0, 3142, 3144, 1, 0, 0, 0, 3143, 3141, 1, 0, 0, 0, 3144,
		3148, 5, 34, 0, 0, 3145, 3147, 5, 5, 0, 0, 3146, 3145, 1, 0, 0, 0, 3147,
		3150, 1, 0, 0, 0, 3148, 3146, 1, 0, 0, 0, 3148, 3149, 1, 0, 0, 0, 3149,
		3151, 1, 0, 0, 0, 3150, 3148, 1, 0, 0, 0, 3151, 3153, 3, 134, 67, 0, 3152,
		3154, 3, 148, 74, 0, 3153, 3152, 1, 0, 0, 0, 3153, 3154, 1, 0, 0, 0, 3154,
		3174, 1, 0, 0, 0, 3155, 3159, 5, 90, 0, 0, 3156, 3158, 5, 5, 0, 0, 3157,
		3156, 1, 0, 0, 0, 3158, 3161, 1, 0, 0, 0, 3159, 3157, 1, 0, 0, 0, 3159,
		3160, 1, 0, 0, 0, 3160, 3162, 1, 0, 0, 0, 3161, 3159, 1, 0, 0, 0, 3162,
		3166, 5, 34, 0, 0, 3163, 3165, 5, 5, 0, 0, 3164, 3163, 1, 0, 0, 0, 3165,
		3168, 1, 0, 0, 0, 3166, 3164, 1, 0, 0, 0, 3166, 3167, 1, 0, 0, 0, 3167,
		3169, 1, 0, 0, 0, 3168, 3166, 1, 0, 0, 0, 3169, 3171, 3, 134, 67, 0, 3170,
		3172, 3, 148, 74, 0, 3171, 3170, 1, 0, 0, 0, 3171, 3172, 1, 0, 0, 0, 3172,
		3174, 1, 0, 0, 0, 3173, 3109, 1, 0, 0, 0, 3173, 3155, 1, 0, 0, 0, 3174,
		257, 1, 0, 0, 0, 3175, 3179, 3, 152, 76, 0, 3176, 3179, 3, 260, 130, 0,
		3177, 3179, 3, 262, 131, 0, 3178, 3175, 1, 0, 0, 0, 3178, 3176, 1, 0, 0,
		0, 3178, 3177, 1, 0, 0, 0, 3179, 259, 1, 0, 0, 0, 3180, 3184, 3, 280, 140,
		0, 3181, 3183, 5, 5, 0, 0, 3182, 3181, 1, 0, 0, 0, 3183, 3186, 1, 0, 0,
		0, 3184, 3182, 1, 0, 0, 0, 3184, 3185, 1, 0, 0, 0, 3185, 3187, 1, 0, 0,
		0, 3186, 3184, 1, 0, 0, 0, 3187, 3188, 3, 152, 76, 0, 3188, 261, 1, 0,
		0, 0, 3189, 3193, 3, 282, 141, 0, 3190, 3192, 5, 5, 0, 0, 3191, 3190, 1,
		0, 0, 0, 3192, 3195, 1, 0, 0, 0, 3193, 3191, 1, 0, 0, 0, 3193, 3194, 1,
		0, 0, 0, 3194, 3196, 1, 0, 0, 0, 3195, 3193, 1, 0, 0, 0, 3196, 3197, 3,
		98, 49, 0, 3197, 263, 1, 0, 0, 0, 3198, 3202, 5, 92, 0, 0, 3199, 3201,
		5, 5, 0, 0, 3200, 3199, 1, 0, 0, 0, 3201, 3204, 1, 0, 0, 0, 3202, 3200,
		1, 0, 0, 0, 3202, 3203, 1, 0, 0, 0, 3203, 3205, 1, 0, 0, 0, 3204, 3202,
		1, 0, 0, 0, 3205, 3233, 3, 136, 68, 0, 3206, 3208, 5, 5, 0, 0, 3207, 3206,
		1, 0, 0, 0, 3208, 3211, 1, 0, 0, 0, 3209, 3207, 1, 0, 0, 0, 3209, 3210,
		1, 0, 0, 0, 3210, 3212, 1, 0, 0, 0, 3211, 3209, 1, 0, 0, 0, 3212, 3214,
		3, 266, 133, 0, 3213, 3209, 1, 0, 0, 0, 3214, 3215, 1, 0, 0, 0, 3215, 3213,
		1, 0, 0, 0, 3215, 3216, 1, 0, 0, 0, 3216, 3224, 1, 0, 0, 0, 3217, 3219,
		5, 5, 0, 0, 3218, 3217, 1, 0, 0, 0, 3219, 3222, 1, 0, 0, 0, 3220, 3218,
		1, 0, 0, 0, 3220, 3221, 1, 0, 0, 0, 3221, 3223, 1, 0, 0, 0, 3222, 3220,
		1, 0, 0, 0, 3223, 3225, 3, 268, 134, 0, 3224, 3220, 1, 0, 0, 0, 3224, 3225,
		1, 0, 0, 0, 3225, 3234, 1, 0, 0, 0, 3226, 3228, 5, 5, 0, 0, 3227, 3226,
		1, 0, 0, 0, 3228, 3231, 1, 0, 0, 0, 3229, 3227, 1, 0, 0, 0, 3229, 3230,
		1, 0, 0, 0, 3230, 3232, 1, 0, 0, 0, 3231, 3229, 1, 0, 0, 0, 3232, 3234,
		3, 268, 134, 0, 3233, 3213, 1, 0, 0, 0, 3233, 3229, 1, 0, 0, 0, 3234, 265,
		1, 0, 0, 0, 3235, 3239, 5, 93, 0, 0, 3236, 3238, 5, 5, 0, 0, 3237, 3236,
		1, 0, 0, 0, 3238, 3241, 1, 0, 0, 0, 3239, 3237, 1, 0, 0, 0, 3239, 3240,
		1, 0, 0, 0, 3240, 3242, 1, 0, 0, 0, 3241, 3239, 1, 0, 0, 0, 3242, 3246,
		5, 9, 0, 0, 3243, 3245, 3, 334, 167, 0, 3244, 3243, 1, 0, 0, 0, 3245, 3248,
		1, 0, 0, 0, 3246, 3244, 1, 0, 0, 0, 3246, 3247, 1, 0, 0, 0, 3247, 3249,
		1, 0, 0, 0, 3248, 3246, 1, 0, 0, 0, 3249, 3250, 3, 344, 172, 0, 3250, 3251,
		5, 26, 0, 0, 3251, 3259, 3, 98, 49, 0, 3252, 3254, 5, 5, 0, 0, 3253, 3252,
		1, 0, 0, 0, 3254, 3257, 1, 0, 0, 0, 3255, 3253, 1, 0, 0, 0, 3255, 3256,
		1, 0, 0, 0, 3256, 3258, 1, 0, 0, 0, 3257, 3255, 1, 0, 0, 0, 3258, 3260,
		5, 8, 0, 0, 3259, 3255, 1, 0, 0, 0, 3259, 3260, 1, 0, 0, 0, 3260, 3261,
		1, 0, 0, 0, 3261, 3265, 5, 10, 0, 0, 3262, 3264, 5, 5, 0, 0, 3263, 3262,
		1, 0, 0, 0, 3264, 3267, 1, 0, 0, 0, 3265, 3263, 1, 0, 0, 0, 3265, 3266,
		1, 0, 0, 0, 3266, 3268, 1, 0, 0, 0, 3267, 3265, 1, 0, 0, 0, 3268, 3269,
		3, 136, 68, 0, 3269, 267, 1, 0, 0, 0, 3270, 3274, 5, 94, 0, 0, 3271, 3273,
		5, 5, 0, 0, 3272, 3271, 1, 0, 0, 0, 3273, 3276, 1, 0, 0, 0, 3274, 3272,
		1, 0, 0, 0, 3274, 3275, 1, 0, 0, 0, 3275, 3277, 1, 0, 0, 0, 3276, 3274,
		1, 0, 0, 0, 3277, 3278, 3, 136, 68, 0, 3278, 269, 1, 0, 0, 0, 3279, 3283,
		5, 98, 0, 0, 3280, 3282, 5, 5, 0, 0, 3281, 3280, 1, 0, 0, 0, 3282, 3285,
		1, 0, 0, 0, 3283, 3281, 1, 0, 0, 0, 3283, 3284, 1, 0, 0, 0, 3284, 3286,
		1, 0, 0, 0, 3285, 3283, 1, 0, 0, 0, 3286, 3296, 3, 152, 76, 0, 3287, 3289,
		7, 11, 0, 0, 3288, 3290, 3, 152, 76, 0, 3289, 3288, 1, 0, 0, 0, 3289, 3290,
		1, 0, 0, 0, 3290, 3296, 1, 0, 0, 0, 3291, 3296, 5, 100, 0, 0, 3292, 3296,
		5, 59, 0, 0, 3293, 3296, 5, 101, 0, 0, 3294, 3296, 5, 60, 0, 0, 3295, 3279,
		1, 0, 0, 0, 3295, 3287, 1, 0, 0, 0, 3295, 3291, 1, 0, 0, 0, 3295, 3292,
		1, 0, 0, 0, 3295, 3293, 1, 0, 0, 0, 3295, 3294, 1, 0, 0, 0, 3296, 271,
		1, 0, 0, 0, 3297, 3299, 3, 122, 61, 0, 3298, 3297, 1, 0, 0, 0, 3298, 3299,
		1, 0, 0, 0, 3299, 3300, 1, 0, 0, 0, 3300, 3304, 5, 38, 0, 0, 3301, 3303,
		5, 5, 0, 0, 3302, 3301, 1, 0, 0, 0, 3303, 3306, 1, 0, 0, 0, 3304, 3302,
		1, 0, 0, 0, 3304, 3305, 1, 0, 0, 0, 3305, 3309, 1, 0, 0, 0, 3306, 3304,
		1, 0, 0, 0, 3307, 3310, 3, 344, 172, 0, 3308, 3310, 5, 74, 0, 0, 3309,
		3307, 1, 0, 0, 0, 3309, 3308, 1, 0, 0, 0, 3310, 273, 1, 0, 0, 0, 3311,
		3312, 7, 12, 0, 0, 3312, 275, 1, 0, 0, 0, 3313, 3314, 7, 13, 0, 0, 3314,
		277, 1, 0, 0, 0, 3315, 3316, 7, 14, 0, 0, 3316, 279, 1, 0, 0, 0, 3317,
		3318, 7, 15, 0, 0, 3318, 281, 1, 0, 0, 0, 3319, 3320, 7, 16, 0, 0, 3320,
		283, 1, 0, 0, 0, 3321, 3322, 7, 17, 0, 0, 3322, 285, 1, 0, 0, 0, 3323,
		3324, 7, 18, 0, 0, 3324, 287, 1, 0, 0, 0, 3325, 3326, 7, 19, 0, 0, 3326,
		289, 1, 0, 0, 0, 3327, 3333, 5, 20, 0, 0, 3328, 3333, 5, 21, 0, 0, 3329,
		3333, 5, 19, 0, 0, 3330, 3333, 5, 18, 0, 0, 3331, 3333, 3, 294, 147, 0,
		3332, 3327, 1, 0, 0, 0, 3332, 3328, 1, 0, 0, 0, 3332, 3329, 1, 0, 0, 0,
		3332, 3330, 1, 0, 0, 0, 3332, 3331, 1, 0, 0, 0, 3333, 291, 1, 0, 0, 0,
		3334, 3339, 5, 20, 0, 0, 3335, 3339, 5, 21, 0, 0, 3336, 3337, 5, 25, 0,
		0, 3337, 3339, 3, 294, 147, 0, 3338, 3334, 1, 0, 0, 0, 3338, 3335, 1, 0,
		0, 0, 3338, 3336, 1, 0, 0, 0, 3339, 293, 1, 0, 0, 0, 3340, 3341, 7, 20,
		0, 0, 3341, 295, 1, 0, 0, 0, 3342, 3344, 5, 5, 0, 0, 3343, 3342, 1, 0,
		0, 0, 3344, 3347, 1, 0, 0, 0, 3345, 3343, 1, 0, 0, 0, 3345, 3346, 1, 0,
		0, 0, 3346, 3348, 1, 0, 0, 0, 3347, 3345, 1, 0, 0, 0, 3348, 3358, 5, 7,
		0, 0, 3349, 3351, 5, 5, 0, 0, 3350, 3349, 1, 0, 0, 0, 3351, 3354, 1, 0,
		0, 0, 3352, 3350, 1, 0, 0, 0, 3352, 3353, 1, 0, 0, 0, 3353, 3355, 1, 0,
		0, 0, 3354, 3352, 1, 0, 0, 0, 3355, 3358, 3, 298, 149, 0, 3356, 3358, 5,
		38, 0, 0, 3357, 3345, 1, 0, 0, 0, 3357, 3352, 1, 0, 0, 0, 3357, 3356, 1,
		0, 0, 0, 3358, 297, 1, 0, 0, 0, 3359, 3360, 5, 46, 0, 0, 3360, 3361, 5,
		7, 0, 0, 3361, 299, 1, 0, 0, 0, 3362, 3365, 3, 334, 167, 0, 3363, 3365,
		3, 304, 152, 0, 3364, 3362, 1, 0, 0, 0, 3364, 3363, 1, 0, 0, 0, 3365, 3366,
		1, 0, 0, 0, 3366, 3364, 1, 0, 0, 0, 3366, 3367, 1, 0, 0, 0, 3367, 301,
		1, 0, 0, 0, 3368, 3371, 3, 334, 167, 0, 3369, 3371, 3, 328, 164, 0, 3370,
		3368, 1, 0, 0, 0, 3370, 3369, 1, 0, 0, 0, 3371, 3372, 1, 0, 0, 0, 3372,
		3370, 1, 0, 0, 0, 3372, 3373, 1, 0, 0, 0, 3373, 303, 1, 0, 0, 0, 3374,
		3383, 3, 310, 155, 0, 3375, 3383, 3, 312, 156, 0, 3376, 3383, 3, 314, 157,
		0, 3377, 3383, 3, 322, 161, 0, 3378, 3383, 3, 324, 162, 0, 3379, 3383,
		3, 326, 163, 0, 3380, 3383, 3, 328, 164, 0, 3381, 3383, 3, 332, 166, 0,
		3382, 3374, 1, 0, 0, 0, 3382, 3375, 1, 0, 0, 0, 3382, 3376, 1, 0, 0, 0,
		3382, 3377, 1, 0, 0, 0, 3382, 3378, 1, 0, 0, 0, 3382, 3379, 1, 0, 0, 0,
		3382, 3380, 1, 0, 0, 0, 3382, 3381, 1, 0, 0, 0, 3383, 3387, 1, 0, 0, 0,
		3384, 3386, 5, 5, 0, 0, 3385, 3384, 1, 0, 0, 0, 3386, 3389, 1, 0, 0, 0,
		3387, 3385, 1, 0, 0, 0, 3387, 3388, 1, 0, 0, 0, 3388, 305, 1, 0, 0, 0,
		3389, 3387, 1, 0, 0, 0, 3390, 3392, 3, 308, 154, 0, 3391, 3390, 1, 0, 0,
		0, 3392, 3393, 1, 0, 0, 0, 3393, 3391, 1, 0, 0, 0, 3393, 3394, 1, 0, 0,
		0, 3394, 307, 1, 0, 0, 0, 3395, 3404, 3, 334, 167, 0, 3396, 3400, 5, 124,
		0, 0, 3397, 3399, 5, 5, 0, 0, 3398, 3397, 1, 0, 0, 0, 3399, 3402, 1, 0,
		0, 0, 3400, 3398, 1, 0, 0, 0, 3400, 3401, 1, 0, 0, 0, 3401, 3404, 1, 0,
		0, 0, 3402, 3400, 1, 0, 0, 0, 3403, 3395, 1, 0, 0, 0, 3403, 3396, 1, 0,
		0, 0, 3404, 309, 1, 0, 0, 0, 3405, 3406, 7, 21, 0, 0, 3406, 311, 1, 0,
		0, 0, 3407, 3408, 7, 22, 0, 0, 3408, 313, 1, 0, 0, 0, 3409, 3410, 7, 23,
		0, 0, 3410, 315, 1, 0, 0, 0, 3411, 3412, 7, 24, 0, 0, 3412, 317, 1, 0,
		0, 0, 3413, 3415, 3, 320, 160, 0, 3414, 3413, 1, 0, 0, 0, 3415, 3416, 1,
		0, 0, 0, 3416, 3414, 1, 0, 0, 0, 3416, 3417, 1, 0, 0, 0, 3417, 319, 1,
		0, 0, 0, 3418, 3422, 3, 330, 165, 0, 3419, 3421, 5, 5, 0, 0, 3420, 3419,
		1, 0, 0, 0, 3421, 3424, 1, 0, 0, 0, 3422, 3420, 1, 0, 0, 0, 3422, 3423,
		1, 0, 0, 0, 3423, 3434, 1, 0, 0, 0, 3424, 3422, 1, 0, 0, 0, 3425, 3429,
		3, 316, 158, 0, 3426, 3428, 5, 5, 0, 0, 3427, 3426, 1, 0, 0, 0, 3428, 3431,
		1, 0, 0, 0, 3429, 3427, 1, 0, 0, 0, 3429, 3430, 1, 0, 0, 0, 3430, 3434,
		1, 0, 0, 0, 3431, 3429, 1, 0, 0, 0, 3432, 3434, 3, 334, 167, 0, 3433, 3418,
		1, 0, 0, 0, 3433, 3425, 1, 0, 0, 0, 3433, 3432, 1, 0, 0, 0, 3434, 321,
		1, 0, 0, 0, 3435, 3436, 7, 25, 0, 0, 3436, 323, 1, 0, 0, 0, 3437, 3438,
		5, 129, 0, 0, 3438, 325, 1, 0, 0, 0, 3439, 3440, 7, 26, 0, 0, 3440, 327,
		1, 0, 0, 0, 3441, 3442, 7, 27, 0, 0, 3442, 329, 1, 0, 0, 0, 3443, 3444,
		5, 134, 0, 0, 3444, 331, 1, 0, 0, 0, 3445, 3446, 7, 28, 0, 0, 3446, 333,
		1, 0, 0, 0, 3447, 3450, 3, 336, 168, 0, 3448, 3450, 3, 338, 169, 0, 3449,
		3447, 1, 0, 0, 0, 3449, 3448, 1, 0, 0, 0, 3450, 3454, 1, 0, 0, 0, 3451,
		3453, 5, 5, 0, 0, 3452, 3451, 1, 0, 0, 0, 3453, 3456, 1, 0, 0, 0, 3454,
		3452, 1, 0, 0, 0, 3454, 3455, 1, 0, 0, 0, 3455, 335, 1, 0, 0, 0, 3456,
		3454, 1, 0, 0, 0, 3457, 3461, 3, 340, 170, 0, 3458, 3460, 5, 5, 0, 0, 3459,
		3458, 1, 0, 0, 0, 3460, 3463, 1, 0, 0, 0, 3461, 3459, 1, 0, 0, 0, 3461,
		3462, 1, 0, 0, 0, 3462, 3467, 1, 0, 0, 0, 3463, 3461, 1, 0, 0, 0, 3464,
		3467, 5, 41, 0, 0, 3465, 3467, 5, 43, 0, 0, 3466, 3457, 1, 0, 0, 0, 3466,
		3464, 1, 0, 0, 0, 3466, 3465, 1, 0, 0, 0, 3467, 3468, 1, 0, 0, 0, 3468,
		3469, 3, 342, 171, 0, 3469, 337, 1, 0, 0, 0, 3470, 3474, 3, 340, 170, 0,
		3471, 3473, 5, 5, 0, 0, 3472, 3471, 1, 0, 0, 0, 3473, 3476, 1, 0, 0, 0,
		3474, 3472, 1, 0, 0, 0, 3474, 3475, 1, 0, 0, 0, 3475, 3480, 1, 0, 0, 0,
		3476, 3474, 1, 0, 0, 0, 3477, 3480, 5, 41, 0, 0, 3478, 3480, 5, 43, 0,
		0, 3479, 3470, 1, 0, 0, 0, 3479, 3477, 1, 0, 0, 0, 3479, 3478, 1, 0, 0,
		0, 3480, 3481, 1, 0, 0, 0, 3481, 3483, 5, 11, 0, 0, 3482, 3484, 3, 342,
		171, 0, 3483, 3482, 1, 0, 0, 0, 3484, 3485, 1, 0, 0, 0, 3485, 3483, 1,
		0, 0, 0, 3485, 3486, 1, 0, 0, 0, 3486, 3487, 1, 0, 0, 0, 3487, 3488, 5,
		12, 0, 0, 3488, 339, 1, 0, 0, 0, 3489, 3490, 7, 0, 0, 0, 3490, 3494, 7,
		29, 0, 0, 3491, 3493, 5, 5, 0, 0, 3492, 3491, 1, 0, 0, 0, 3493, 3496, 1,
		0, 0, 0, 3494, 3492, 1, 0, 0, 0, 3494, 3495, 1, 0, 0, 0, 3495, 3497, 1,
		0, 0, 0, 3496, 3494, 1, 0, 0, 0, 3497, 3498, 5, 26, 0, 0, 3498, 341, 1,
		0, 0, 0, 3499, 3502, 3, 36, 18, 0, 3500, 3502, 3, 106, 53, 0, 3501, 3499,
		1, 0, 0, 0, 3501, 3500, 1, 0, 0, 0, 3502, 343, 1, 0, 0, 0, 3503, 3504,
		7, 30, 0, 0, 3504, 345, 1, 0, 0, 0, 3505, 3516, 3, 344, 172, 0, 3506, 3508,
		5, 5, 0, 0, 3507, 3506, 1, 0, 0, 0, 3508, 3511, 1, 0, 0, 0, 3509, 3507,
		1, 0, 0, 0, 3509, 3510, 1, 0, 0, 0, 3510, 3512, 1, 0, 0, 0, 3511, 3509,
		1, 0, 0, 0, 3512, 3513, 5, 7, 0, 0, 3513, 3515, 3, 344, 172, 0, 3514, 3509,
		1, 0, 0, 0, 3515, 3518, 1, 0, 0, 0, 3516, 3514, 1, 0, 0, 0, 3516, 3517,
		1, 0, 0, 0, 3517, 347, 1, 0, 0, 0, 3518, 3516, 1, 0, 0, 0, 542, 349, 354,
		360, 368, 374, 379, 385, 395, 404, 411, 418, 425, 430, 435, 441, 443, 448,
		456, 459, 466, 469, 475, 482, 486, 491, 498, 508, 511, 518, 521, 524, 529,
		536, 540, 545, 549, 554, 561, 565, 570, 574, 579, 586, 590, 593, 599, 602,
		610, 617, 626, 633, 640, 646, 652, 656, 658, 663, 669, 672, 677, 685, 692,
		699, 703, 709, 716, 722, 733, 737, 743, 751, 757, 764, 769, 776, 785, 792,
		799, 805, 811, 815, 820, 826, 831, 838, 845, 849, 855, 862, 869, 875, 881,
		888, 895, 902, 906, 913, 919, 925, 931, 935, 940, 947, 951, 956, 963, 967,
		972, 976, 982, 989, 996, 1002, 1008, 1012, 1014, 1019, 1025, 1031, 1038,
		1042, 1045, 1051, 1055, 1060, 1067, 1072, 1077, 1084, 1091, 1098, 1102,
		1107, 1111, 1116, 1120, 1127, 1131, 1136, 1142, 1149, 1156, 1160, 1166,
		1173, 1180, 1186, 1192, 1196, 1201, 1207, 1213, 1217, 1222, 1229, 1234,
		1239, 1244, 1249, 1253, 1258, 1265, 1270, 1272, 1277, 1281, 1286, 1290,
		1295, 1299, 1302, 1305, 1310, 1314, 1317, 1319, 1325, 1331, 1337, 1344,
		1351, 1358, 1362, 1367, 1371, 1374, 1380, 1387, 1394, 1398, 1403, 1410,
		1417, 1421, 1426, 1431, 1437, 1444, 1451, 1457, 1463, 1467, 1469, 1474,
		1480, 1486, 1493, 1497, 1503, 1510, 1514, 1520, 1527, 1533, 1539, 1546,
		1553, 1557, 1562, 1566, 1569, 1575, 1582, 1589, 1593, 1598, 1602, 1608,
		1617, 1621, 1626, 1633, 1637, 1642, 1651, 1658, 1664, 1670, 1674, 1680,
		1683, 1689, 1693, 1698, 1702, 1705, 1712, 1716, 1720, 1725, 1731, 1739,
		1746, 1752, 1759, 1763, 1766, 1770, 1775, 1781, 1785, 1791, 1798, 1801,
		1807, 1814, 1823, 1828, 1833, 1840, 1845, 1849, 1855, 1859, 1864, 1873,
		1880, 1886, 1891, 1897, 1902, 1907, 1913, 1917, 1922, 1929, 1933, 1937,
		1945, 1948, 1951, 1955, 1957, 1964, 1971, 1976, 1982, 1989, 1997, 2003,
		2010, 2015, 2023, 2027, 2033, 2042, 2047, 2053, 2057, 2062, 2069, 2082,
		2087, 2096, 2102, 2110, 2117, 2123, 2130, 2137, 2143, 2151, 2158, 2166,
		2173, 2180, 2188, 2197, 2202, 2204, 2211, 2218, 2225, 2236, 2243, 2251,
		2257, 2265, 2272, 2280, 2287, 2294, 2301, 2308, 2314, 2325, 2328, 2334,
		2342, 2349, 2355, 2362, 2369, 2375, 2382, 2390, 2396, 2403, 2410, 2416,
		2422, 2426, 2431, 2440, 2446, 2449, 2452, 2456, 2461, 2465, 2470, 2479,
		2486, 2493, 2499, 2505, 2509, 2514, 2523, 2530, 2537, 2543, 2549, 2553,
		2558, 2561, 2566, 2571, 2578, 2585, 2588, 2591, 2596, 2615, 2621, 2628,
		2637, 2644, 2651, 2657, 2663, 2667, 2672, 2675, 2683, 2688, 2690, 2699,
		2701, 2712, 2719, 2730, 2737, 2746, 2750, 2755, 2762, 2765, 2771, 2780,
		2787, 2793, 2799, 2803, 2810, 2817, 2821, 2823, 2826, 2831, 2838, 2845,
		2850, 2855, 2862, 2869, 2873, 2878, 2882, 2887, 2891, 2895, 2898, 2903,
		2910, 2917, 2924, 2927, 2932, 2936, 2945, 2952, 2957, 2961, 2964, 2970,
		2977, 2984, 2991, 2996, 3001, 3005, 3010, 3017, 3022, 3025, 3031, 3037,
		3044, 3051, 3058, 3061, 3070, 3074, 3079, 3086, 3093, 3098, 3104, 3113,
		3120, 3126, 3132, 3136, 3141, 3148, 3153, 3159, 3166, 3171, 3173, 3178,
		3184, 3193, 3202, 3209, 3215, 3220, 3224, 3229, 3233, 3239, 3246, 3255,
		3259, 3265, 3274, 3283, 3289, 3295, 3298, 3304, 3309, 3332, 3338, 3345,
		3352, 3357, 3364, 3366, 3370, 3372, 3382, 3387, 3393, 3400, 3403, 3416,
		3422, 3429, 3433, 3449, 3454, 3461, 3466, 3474, 3479, 3485, 3494, 3501,
		3509, 3516,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// KotlinParserInit initializes any static state used to implement KotlinParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewKotlinParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func KotlinParserInit() {
	staticData := &KotlinParserParserStaticData
	staticData.once.Do(kotlinparserParserInit)
}

// NewKotlinParser produces a new parser instance for the optional input antlr.TokenStream.
func NewKotlinParser(input antlr.TokenStream) *KotlinParser {
	KotlinParserInit()
	this := new(KotlinParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &KotlinParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "KotlinParser.g4"

	return this
}

// KotlinParser tokens.
const (
	KotlinParserEOF                   = antlr.TokenEOF
	KotlinParserShebangLine           = 1
	KotlinParserDelimitedComment      = 2
	KotlinParserLineComment           = 3
	KotlinParserWS                    = 4
	KotlinParserNL                    = 5
	KotlinParserRESERVED              = 6
	KotlinParserDOT                   = 7
	KotlinParserCOMMA                 = 8
	KotlinParserLPAREN                = 9
	KotlinParserRPAREN                = 10
	KotlinParserLSQUARE               = 11
	KotlinParserRSQUARE               = 12
	KotlinParserLCURL                 = 13
	KotlinParserRCURL                 = 14
	KotlinParserMULT                  = 15
	KotlinParserMOD                   = 16
	KotlinParserDIV                   = 17
	KotlinParserADD                   = 18
	KotlinParserSUB                   = 19
	KotlinParserINCR                  = 20
	KotlinParserDECR                  = 21
	KotlinParserCONJ                  = 22
	KotlinParserDISJ                  = 23
	KotlinParserEXCL_WS               = 24
	KotlinParserEXCL_NO_WS            = 25
	KotlinParserCOLON                 = 26
	KotlinParserSEMICOLON             = 27
	KotlinParserASSIGNMENT            = 28
	KotlinParserADD_ASSIGNMENT        = 29
	KotlinParserSUB_ASSIGNMENT        = 30
	KotlinParserMULT_ASSIGNMENT       = 31
	KotlinParserDIV_ASSIGNMENT        = 32
	KotlinParserMOD_ASSIGNMENT        = 33
	KotlinParserARROW                 = 34
	KotlinParserDOUBLE_ARROW          = 35
	KotlinParserRANGE                 = 36
	KotlinParserRANGE_UNTIL           = 37
	KotlinParserCOLONCOLON            = 38
	KotlinParserDOUBLE_SEMICOLON      = 39
	KotlinParserHASH                  = 40
	KotlinParserAT_NO_WS              = 41
	KotlinParserAT_POST_WS            = 42
	KotlinParserAT_PRE_WS             = 43
	KotlinParserAT_BOTH_WS            = 44
	KotlinParserQUEST_WS              = 45
	KotlinParserQUEST_NO_WS           = 46
	KotlinParserLANGLE                = 47
	KotlinParserRANGLE                = 48
	KotlinParserLE                    = 49
	KotlinParserGE                    = 50
	KotlinParserEXCL_EQ               = 51
	KotlinParserEXCL_EQEQ             = 52
	KotlinParserAS_SAFE               = 53
	KotlinParserEQEQ                  = 54
	KotlinParserEQEQEQ                = 55
	KotlinParserSINGLE_QUOTE          = 56
	KotlinParserAMP                   = 57
	KotlinParserRETURN_AT             = 58
	KotlinParserCONTINUE_AT           = 59
	KotlinParserBREAK_AT              = 60
	KotlinParserTHIS_AT               = 61
	KotlinParserSUPER_AT              = 62
	KotlinParserFILE                  = 63
	KotlinParserFIELD                 = 64
	KotlinParserPROPERTY              = 65
	KotlinParserGET                   = 66
	KotlinParserSET                   = 67
	KotlinParserRECEIVER              = 68
	KotlinParserPARAM                 = 69
	KotlinParserSETPARAM              = 70
	KotlinParserDELEGATE              = 71
	KotlinParserPACKAGE               = 72
	KotlinParserIMPORT                = 73
	KotlinParserCLASS                 = 74
	KotlinParserINTERFACE             = 75
	KotlinParserFUN                   = 76
	KotlinParserOBJECT                = 77
	KotlinParserVAL                   = 78
	KotlinParserVAR                   = 79
	KotlinParserTYPE_ALIAS            = 80
	KotlinParserCONSTRUCTOR           = 81
	KotlinParserBY                    = 82
	KotlinParserCOMPANION             = 83
	KotlinParserINIT                  = 84
	KotlinParserTHIS                  = 85
	KotlinParserSUPER                 = 86
	KotlinParserTYPEOF                = 87
	KotlinParserWHERE                 = 88
	KotlinParserIF                    = 89
	KotlinParserELSE                  = 90
	KotlinParserWHEN                  = 91
	KotlinParserTRY                   = 92
	KotlinParserCATCH                 = 93
	KotlinParserFINALLY               = 94
	KotlinParserFOR                   = 95
	KotlinParserDO                    = 96
	KotlinParserWHILE                 = 97
	KotlinParserTHROW                 = 98
	KotlinParserRETURN                = 99
	KotlinParserCONTINUE              = 100
	KotlinParserBREAK                 = 101
	KotlinParserAS                    = 102
	KotlinParserIS                    = 103
	KotlinParserIN                    = 104
	KotlinParserNOT_IS                = 105
	KotlinParserNOT_IN                = 106
	KotlinParserOUT                   = 107
	KotlinParserDYNAMIC               = 108
	KotlinParserPUBLIC                = 109
	KotlinParserPRIVATE               = 110
	KotlinParserPROTECTED             = 111
	KotlinParserINTERNAL              = 112
	KotlinParserENUM                  = 113
	KotlinParserSEALED                = 114
	KotlinParserANNOTATION            = 115
	KotlinParserDATA                  = 116
	KotlinParserINNER                 = 117
	KotlinParserVALUE                 = 118
	KotlinParserTAILREC               = 119
	KotlinParserOPERATOR              = 120
	KotlinParserINLINE                = 121
	KotlinParserINFIX                 = 122
	KotlinParserEXTERNAL              = 123
	KotlinParserSUSPEND               = 124
	KotlinParserOVERRIDE              = 125
	KotlinParserABSTRACT              = 126
	KotlinParserFINAL                 = 127
	KotlinParserOPEN                  = 128
	KotlinParserCONST                 = 129
	KotlinParserLATEINIT              = 130
	KotlinParserVARARG                = 131
	KotlinParserNOINLINE              = 132
	KotlinParserCROSSINLINE           = 133
	KotlinParserREIFIED               = 134
	KotlinParserEXPECT                = 135
	KotlinParserACTUAL                = 136
	KotlinParserRealLiteral           = 137
	KotlinParserFloatLiteral          = 138
	KotlinParserDoubleLiteral         = 139
	KotlinParserIntegerLiteral        = 140
	KotlinParserHexLiteral            = 141
	KotlinParserBinLiteral            = 142
	KotlinParserUnsignedLiteral       = 143
	KotlinParserLongLiteral           = 144
	KotlinParserBooleanLiteral        = 145
	KotlinParserNullLiteral           = 146
	KotlinParserCharacterLiteral      = 147
	KotlinParserIdentifier            = 148
	KotlinParserIdentifierOrSoftKey   = 149
	KotlinParserFieldIdentifier       = 150
	KotlinParserQUOTE_OPEN            = 151
	KotlinParserTRIPLE_QUOTE_OPEN     = 152
	KotlinParserUNICODE_CLASS_LL      = 153
	KotlinParserUNICODE_CLASS_LM      = 154
	KotlinParserUNICODE_CLASS_LO      = 155
	KotlinParserUNICODE_CLASS_LT      = 156
	KotlinParserUNICODE_CLASS_LU      = 157
	KotlinParserUNICODE_CLASS_ND      = 158
	KotlinParserUNICODE_CLASS_NL      = 159
	KotlinParserQUOTE_CLOSE           = 160
	KotlinParserLineStrRef            = 161
	KotlinParserLineStrText           = 162
	KotlinParserLineStrEscapedChar    = 163
	KotlinParserLineStrExprStart      = 164
	KotlinParserTRIPLE_QUOTE_CLOSE    = 165
	KotlinParserMultiLineStringQuote  = 166
	KotlinParserMultiLineStrRef       = 167
	KotlinParserMultiLineStrText      = 168
	KotlinParserMultiLineStrExprStart = 169
	KotlinParserInside_Comment        = 170
	KotlinParserInside_WS             = 171
	KotlinParserInside_NL             = 172
	KotlinParserErrorCharacter        = 173
)

// KotlinParser rules.
const (
	KotlinParserRULE_kotlinFile                                = 0
	KotlinParserRULE_script                                    = 1
	KotlinParserRULE_shebangLine                               = 2
	KotlinParserRULE_fileAnnotation                            = 3
	KotlinParserRULE_packageHeader                             = 4
	KotlinParserRULE_importList                                = 5
	KotlinParserRULE_importHeader                              = 6
	KotlinParserRULE_importAlias                               = 7
	KotlinParserRULE_topLevelObject                            = 8
	KotlinParserRULE_typeAlias                                 = 9
	KotlinParserRULE_declaration                               = 10
	KotlinParserRULE_classDeclaration                          = 11
	KotlinParserRULE_primaryConstructor                        = 12
	KotlinParserRULE_classBody                                 = 13
	KotlinParserRULE_classParameters                           = 14
	KotlinParserRULE_classParameter                            = 15
	KotlinParserRULE_delegationSpecifiers                      = 16
	KotlinParserRULE_delegationSpecifier                       = 17
	KotlinParserRULE_constructorInvocation                     = 18
	KotlinParserRULE_annotatedDelegationSpecifier              = 19
	KotlinParserRULE_explicitDelegation                        = 20
	KotlinParserRULE_typeParameters                            = 21
	KotlinParserRULE_typeParameter                             = 22
	KotlinParserRULE_typeConstraints                           = 23
	KotlinParserRULE_typeConstraint                            = 24
	KotlinParserRULE_classMemberDeclarations                   = 25
	KotlinParserRULE_classMemberDeclaration                    = 26
	KotlinParserRULE_anonymousInitializer                      = 27
	KotlinParserRULE_companionObject                           = 28
	KotlinParserRULE_functionValueParameters                   = 29
	KotlinParserRULE_functionValueParameter                    = 30
	KotlinParserRULE_functionDeclaration                       = 31
	KotlinParserRULE_functionBody                              = 32
	KotlinParserRULE_variableDeclaration                       = 33
	KotlinParserRULE_multiVariableDeclaration                  = 34
	KotlinParserRULE_propertyDeclaration                       = 35
	KotlinParserRULE_propertyDelegate                          = 36
	KotlinParserRULE_getter                                    = 37
	KotlinParserRULE_setter                                    = 38
	KotlinParserRULE_parametersWithOptionalType                = 39
	KotlinParserRULE_functionValueParameterWithOptionalType    = 40
	KotlinParserRULE_parameterWithOptionalType                 = 41
	KotlinParserRULE_parameter                                 = 42
	KotlinParserRULE_objectDeclaration                         = 43
	KotlinParserRULE_secondaryConstructor                      = 44
	KotlinParserRULE_constructorDelegationCall                 = 45
	KotlinParserRULE_enumClassBody                             = 46
	KotlinParserRULE_enumEntries                               = 47
	KotlinParserRULE_enumEntry                                 = 48
	KotlinParserRULE_type                                      = 49
	KotlinParserRULE_typeReference                             = 50
	KotlinParserRULE_nullableType                              = 51
	KotlinParserRULE_quest                                     = 52
	KotlinParserRULE_userType                                  = 53
	KotlinParserRULE_simpleUserType                            = 54
	KotlinParserRULE_typeProjection                            = 55
	KotlinParserRULE_typeProjectionModifiers                   = 56
	KotlinParserRULE_typeProjectionModifier                    = 57
	KotlinParserRULE_functionType                              = 58
	KotlinParserRULE_functionTypeParameters                    = 59
	KotlinParserRULE_parenthesizedType                         = 60
	KotlinParserRULE_receiverType                              = 61
	KotlinParserRULE_parenthesizedUserType                     = 62
	KotlinParserRULE_definitelyNonNullableType                 = 63
	KotlinParserRULE_statements                                = 64
	KotlinParserRULE_statement                                 = 65
	KotlinParserRULE_label                                     = 66
	KotlinParserRULE_controlStructureBody                      = 67
	KotlinParserRULE_block                                     = 68
	KotlinParserRULE_loopStatement                             = 69
	KotlinParserRULE_forStatement                              = 70
	KotlinParserRULE_whileStatement                            = 71
	KotlinParserRULE_doWhileStatement                          = 72
	KotlinParserRULE_assignment                                = 73
	KotlinParserRULE_semi                                      = 74
	KotlinParserRULE_semis                                     = 75
	KotlinParserRULE_expression                                = 76
	KotlinParserRULE_disjunction                               = 77
	KotlinParserRULE_conjunction                               = 78
	KotlinParserRULE_equality                                  = 79
	KotlinParserRULE_comparison                                = 80
	KotlinParserRULE_genericCallLikeComparison                 = 81
	KotlinParserRULE_infixOperation                            = 82
	KotlinParserRULE_elvisExpression                           = 83
	KotlinParserRULE_elvis                                     = 84
	KotlinParserRULE_infixFunctionCall                         = 85
	KotlinParserRULE_rangeExpression                           = 86
	KotlinParserRULE_additiveExpression                        = 87
	KotlinParserRULE_multiplicativeExpression                  = 88
	KotlinParserRULE_asExpression                              = 89
	KotlinParserRULE_prefixUnaryExpression                     = 90
	KotlinParserRULE_unaryPrefix                               = 91
	KotlinParserRULE_postfixUnaryExpression                    = 92
	KotlinParserRULE_postfixUnarySuffix                        = 93
	KotlinParserRULE_directlyAssignableExpression              = 94
	KotlinParserRULE_parenthesizedDirectlyAssignableExpression = 95
	KotlinParserRULE_assignableExpression                      = 96
	KotlinParserRULE_parenthesizedAssignableExpression         = 97
	KotlinParserRULE_assignableSuffix                          = 98
	KotlinParserRULE_indexingSuffix                            = 99
	KotlinParserRULE_navigationSuffix                          = 100
	KotlinParserRULE_callSuffix                                = 101
	KotlinParserRULE_annotatedLambda                           = 102
	KotlinParserRULE_typeArguments                             = 103
	KotlinParserRULE_valueArguments                            = 104
	KotlinParserRULE_valueArgument                             = 105
	KotlinParserRULE_primaryExpression                         = 106
	KotlinParserRULE_parenthesizedExpression                   = 107
	KotlinParserRULE_collectionLiteral                         = 108
	KotlinParserRULE_literalConstant                           = 109
	KotlinParserRULE_stringLiteral                             = 110
	KotlinParserRULE_lineStringLiteral                         = 111
	KotlinParserRULE_multiLineStringLiteral                    = 112
	KotlinParserRULE_lineStringContent                         = 113
	KotlinParserRULE_lineStringExpression                      = 114
	KotlinParserRULE_multiLineStringContent                    = 115
	KotlinParserRULE_multiLineStringExpression                 = 116
	KotlinParserRULE_lambdaLiteral                             = 117
	KotlinParserRULE_lambdaParameters                          = 118
	KotlinParserRULE_lambdaParameter                           = 119
	KotlinParserRULE_anonymousFunction                         = 120
	KotlinParserRULE_functionLiteral                           = 121
	KotlinParserRULE_objectLiteral                             = 122
	KotlinParserRULE_thisExpression                            = 123
	KotlinParserRULE_superExpression                           = 124
	KotlinParserRULE_ifExpression                              = 125
	KotlinParserRULE_whenSubject                               = 126
	KotlinParserRULE_whenExpression                            = 127
	KotlinParserRULE_whenEntry                                 = 128
	KotlinParserRULE_whenCondition                             = 129
	KotlinParserRULE_rangeTest                                 = 130
	KotlinParserRULE_typeTest                                  = 131
	KotlinParserRULE_tryExpression                             = 132
	KotlinParserRULE_catchBlock                                = 133
	KotlinParserRULE_finallyBlock                              = 134
	KotlinParserRULE_jumpExpression                            = 135
	KotlinParserRULE_callableReference                         = 136
	KotlinParserRULE_assignmentAndOperator                     = 137
	KotlinParserRULE_equalityOperator                          = 138
	KotlinParserRULE_comparisonOperator                        = 139
	KotlinParserRULE_inOperator                                = 140
	KotlinParserRULE_isOperator                                = 141
	KotlinParserRULE_additiveOperator                          = 142
	KotlinParserRULE_multiplicativeOperator                    = 143
	KotlinParserRULE_asOperator                                = 144
	KotlinParserRULE_prefixUnaryOperator                       = 145
	KotlinParserRULE_postfixUnaryOperator                      = 146
	KotlinParserRULE_excl                                      = 147
	KotlinParserRULE_memberAccessOperator                      = 148
	KotlinParserRULE_safeNav                                   = 149
	KotlinParserRULE_modifiers                                 = 150
	KotlinParserRULE_parameterModifiers                        = 151
	KotlinParserRULE_modifier                                  = 152
	KotlinParserRULE_typeModifiers                             = 153
	KotlinParserRULE_typeModifier                              = 154
	KotlinParserRULE_classModifier                             = 155
	KotlinParserRULE_memberModifier                            = 156
	KotlinParserRULE_visibilityModifier                        = 157
	KotlinParserRULE_varianceModifier                          = 158
	KotlinParserRULE_typeParameterModifiers                    = 159
	KotlinParserRULE_typeParameterModifier                     = 160
	KotlinParserRULE_functionModifier                          = 161
	KotlinParserRULE_propertyModifier                          = 162
	KotlinParserRULE_inheritanceModifier                       = 163
	KotlinParserRULE_parameterModifier                         = 164
	KotlinParserRULE_reificationModifier                       = 165
	KotlinParserRULE_platformModifier                          = 166
	KotlinParserRULE_annotation                                = 167
	KotlinParserRULE_singleAnnotation                          = 168
	KotlinParserRULE_multiAnnotation                           = 169
	KotlinParserRULE_annotationUseSiteTarget                   = 170
	KotlinParserRULE_unescapedAnnotation                       = 171
	KotlinParserRULE_simpleIdentifier                          = 172
	KotlinParserRULE_identifier                                = 173
)

// IKotlinFileContext is an interface to support dynamic dispatch.
type IKotlinFileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PackageHeader() IPackageHeaderContext
	ImportList() IImportListContext
	EOF() antlr.TerminalNode
	ShebangLine() IShebangLineContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	AllFileAnnotation() []IFileAnnotationContext
	FileAnnotation(i int) IFileAnnotationContext
	AllTopLevelObject() []ITopLevelObjectContext
	TopLevelObject(i int) ITopLevelObjectContext

	// IsKotlinFileContext differentiates from other interfaces.
	IsKotlinFileContext()
}

type KotlinFileContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKotlinFileContext() *KotlinFileContext {
	var p = new(KotlinFileContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_kotlinFile
	return p
}

func InitEmptyKotlinFileContext(p *KotlinFileContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_kotlinFile
}

func (*KotlinFileContext) IsKotlinFileContext() {}

func NewKotlinFileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KotlinFileContext {
	var p = new(KotlinFileContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_kotlinFile

	return p
}

func (s *KotlinFileContext) GetParser() antlr.Parser { return s.parser }

func (s *KotlinFileContext) PackageHeader() IPackageHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackageHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackageHeaderContext)
}

func (s *KotlinFileContext) ImportList() IImportListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportListContext)
}

func (s *KotlinFileContext) EOF() antlr.TerminalNode {
	return s.GetToken(KotlinParserEOF, 0)
}

func (s *KotlinFileContext) ShebangLine() IShebangLineContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShebangLineContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShebangLineContext)
}

func (s *KotlinFileContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *KotlinFileContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *KotlinFileContext) AllFileAnnotation() []IFileAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFileAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IFileAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFileAnnotationContext); ok {
			tst[i] = t.(IFileAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *KotlinFileContext) FileAnnotation(i int) IFileAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileAnnotationContext)
}

func (s *KotlinFileContext) AllTopLevelObject() []ITopLevelObjectContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITopLevelObjectContext); ok {
			len++
		}
	}

	tst := make([]ITopLevelObjectContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITopLevelObjectContext); ok {
			tst[i] = t.(ITopLevelObjectContext)
			i++
		}
	}

	return tst
}

func (s *KotlinFileContext) TopLevelObject(i int) ITopLevelObjectContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopLevelObjectContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopLevelObjectContext)
}

func (s *KotlinFileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KotlinFileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KotlinFileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterKotlinFile(s)
	}
}

func (s *KotlinFileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitKotlinFile(s)
	}
}

func (p *KotlinParser) KotlinFile() (localctx IKotlinFileContext) {
	localctx = NewKotlinFileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, KotlinParserRULE_kotlinFile)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(349)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserShebangLine {
		{
			p.SetState(348)
			p.ShebangLine()
		}

	}
	p.SetState(354)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(351)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(356)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(360)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(357)
				p.FileAnnotation()
			}

		}
		p.SetState(362)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(363)
		p.PackageHeader()
	}
	{
		p.SetState(364)
		p.ImportList()
	}
	p.SetState(368)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || ((int64((_la-74)) & ^0x3f) == 0 && ((int64(1)<<(_la-74))&8070450497888190591) != 0) {
		{
			p.SetState(365)
			p.TopLevelObject()
		}

		p.SetState(370)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(371)
		p.Match(KotlinParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScriptContext is an interface to support dynamic dispatch.
type IScriptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PackageHeader() IPackageHeaderContext
	ImportList() IImportListContext
	EOF() antlr.TerminalNode
	ShebangLine() IShebangLineContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	AllFileAnnotation() []IFileAnnotationContext
	FileAnnotation(i int) IFileAnnotationContext
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	AllSemi() []ISemiContext
	Semi(i int) ISemiContext

	// IsScriptContext differentiates from other interfaces.
	IsScriptContext()
}

type ScriptContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScriptContext() *ScriptContext {
	var p = new(ScriptContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_script
	return p
}

func InitEmptyScriptContext(p *ScriptContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_script
}

func (*ScriptContext) IsScriptContext() {}

func NewScriptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScriptContext {
	var p = new(ScriptContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_script

	return p
}

func (s *ScriptContext) GetParser() antlr.Parser { return s.parser }

func (s *ScriptContext) PackageHeader() IPackageHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackageHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackageHeaderContext)
}

func (s *ScriptContext) ImportList() IImportListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportListContext)
}

func (s *ScriptContext) EOF() antlr.TerminalNode {
	return s.GetToken(KotlinParserEOF, 0)
}

func (s *ScriptContext) ShebangLine() IShebangLineContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShebangLineContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShebangLineContext)
}

func (s *ScriptContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ScriptContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ScriptContext) AllFileAnnotation() []IFileAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFileAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IFileAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFileAnnotationContext); ok {
			tst[i] = t.(IFileAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *ScriptContext) FileAnnotation(i int) IFileAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileAnnotationContext)
}

func (s *ScriptContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *ScriptContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ScriptContext) AllSemi() []ISemiContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISemiContext); ok {
			len++
		}
	}

	tst := make([]ISemiContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISemiContext); ok {
			tst[i] = t.(ISemiContext)
			i++
		}
	}

	return tst
}

func (s *ScriptContext) Semi(i int) ISemiContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISemiContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISemiContext)
}

func (s *ScriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScriptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterScript(s)
	}
}

func (s *ScriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitScript(s)
	}
}

func (p *KotlinParser) Script() (localctx IScriptContext) {
	localctx = NewScriptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, KotlinParserRULE_script)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(374)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserShebangLine {
		{
			p.SetState(373)
			p.ShebangLine()
		}

	}
	p.SetState(379)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(376)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(381)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(385)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(382)
				p.FileAnnotation()
			}

		}
		p.SetState(387)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(388)
		p.PackageHeader()
	}
	{
		p.SetState(389)
		p.ImportList()
	}
	p.SetState(395)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-288219106103252448) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-8521290612993) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&27259903) != 0) {
		{
			p.SetState(390)
			p.Statement()
		}
		{
			p.SetState(391)
			p.Semi()
		}

		p.SetState(397)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(398)
		p.Match(KotlinParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShebangLineContext is an interface to support dynamic dispatch.
type IShebangLineContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ShebangLine() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsShebangLineContext differentiates from other interfaces.
	IsShebangLineContext()
}

type ShebangLineContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShebangLineContext() *ShebangLineContext {
	var p = new(ShebangLineContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_shebangLine
	return p
}

func InitEmptyShebangLineContext(p *ShebangLineContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_shebangLine
}

func (*ShebangLineContext) IsShebangLineContext() {}

func NewShebangLineContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShebangLineContext {
	var p = new(ShebangLineContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_shebangLine

	return p
}

func (s *ShebangLineContext) GetParser() antlr.Parser { return s.parser }

func (s *ShebangLineContext) ShebangLine() antlr.TerminalNode {
	return s.GetToken(KotlinParserShebangLine, 0)
}

func (s *ShebangLineContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ShebangLineContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ShebangLineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShebangLineContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShebangLineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterShebangLine(s)
	}
}

func (s *ShebangLineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitShebangLine(s)
	}
}

func (p *KotlinParser) ShebangLine() (localctx IShebangLineContext) {
	localctx = NewShebangLineContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, KotlinParserRULE_shebangLine)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(400)
		p.Match(KotlinParserShebangLine)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(402)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(401)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(404)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFileAnnotationContext is an interface to support dynamic dispatch.
type IFileAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FILE() antlr.TerminalNode
	COLON() antlr.TerminalNode
	AT_NO_WS() antlr.TerminalNode
	AT_PRE_WS() antlr.TerminalNode
	LSQUARE() antlr.TerminalNode
	RSQUARE() antlr.TerminalNode
	AllUnescapedAnnotation() []IUnescapedAnnotationContext
	UnescapedAnnotation(i int) IUnescapedAnnotationContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsFileAnnotationContext differentiates from other interfaces.
	IsFileAnnotationContext()
}

type FileAnnotationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileAnnotationContext() *FileAnnotationContext {
	var p = new(FileAnnotationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_fileAnnotation
	return p
}

func InitEmptyFileAnnotationContext(p *FileAnnotationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_fileAnnotation
}

func (*FileAnnotationContext) IsFileAnnotationContext() {}

func NewFileAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileAnnotationContext {
	var p = new(FileAnnotationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_fileAnnotation

	return p
}

func (s *FileAnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *FileAnnotationContext) FILE() antlr.TerminalNode {
	return s.GetToken(KotlinParserFILE, 0)
}

func (s *FileAnnotationContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *FileAnnotationContext) AT_NO_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAT_NO_WS, 0)
}

func (s *FileAnnotationContext) AT_PRE_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAT_PRE_WS, 0)
}

func (s *FileAnnotationContext) LSQUARE() antlr.TerminalNode {
	return s.GetToken(KotlinParserLSQUARE, 0)
}

func (s *FileAnnotationContext) RSQUARE() antlr.TerminalNode {
	return s.GetToken(KotlinParserRSQUARE, 0)
}

func (s *FileAnnotationContext) AllUnescapedAnnotation() []IUnescapedAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnescapedAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IUnescapedAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnescapedAnnotationContext); ok {
			tst[i] = t.(IUnescapedAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *FileAnnotationContext) UnescapedAnnotation(i int) IUnescapedAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnescapedAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnescapedAnnotationContext)
}

func (s *FileAnnotationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *FileAnnotationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *FileAnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileAnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileAnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFileAnnotation(s)
	}
}

func (s *FileAnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFileAnnotation(s)
	}
}

func (p *KotlinParser) FileAnnotation() (localctx IFileAnnotationContext) {
	localctx = NewFileAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, KotlinParserRULE_fileAnnotation)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(406)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(407)
		p.Match(KotlinParserFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(411)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(408)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(413)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(414)
		p.Match(KotlinParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(418)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(415)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(420)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(430)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KotlinParserLSQUARE:
		{
			p.SetState(421)
			p.Match(KotlinParserLSQUARE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(423)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = ((int64((_la-63)) & ^0x3f) == 0 && ((int64(1)<<(_la-63))&-17588927330817) != 0) || ((int64((_la-127)) & ^0x3f) == 0 && ((int64(1)<<(_la-127))&2098175) != 0) {
			{
				p.SetState(422)
				p.UnescapedAnnotation()
			}

			p.SetState(425)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(427)
			p.Match(KotlinParserRSQUARE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserIdentifier:
		{
			p.SetState(429)
			p.UnescapedAnnotation()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(435)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(432)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(437)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPackageHeaderContext is an interface to support dynamic dispatch.
type IPackageHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PACKAGE() antlr.TerminalNode
	Identifier() IIdentifierContext
	Semi() ISemiContext

	// IsPackageHeaderContext differentiates from other interfaces.
	IsPackageHeaderContext()
}

type PackageHeaderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackageHeaderContext() *PackageHeaderContext {
	var p = new(PackageHeaderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_packageHeader
	return p
}

func InitEmptyPackageHeaderContext(p *PackageHeaderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_packageHeader
}

func (*PackageHeaderContext) IsPackageHeaderContext() {}

func NewPackageHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PackageHeaderContext {
	var p = new(PackageHeaderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_packageHeader

	return p
}

func (s *PackageHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *PackageHeaderContext) PACKAGE() antlr.TerminalNode {
	return s.GetToken(KotlinParserPACKAGE, 0)
}

func (s *PackageHeaderContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PackageHeaderContext) Semi() ISemiContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISemiContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISemiContext)
}

func (s *PackageHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PackageHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PackageHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPackageHeader(s)
	}
}

func (s *PackageHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPackageHeader(s)
	}
}

func (p *KotlinParser) PackageHeader() (localctx IPackageHeaderContext) {
	localctx = NewPackageHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, KotlinParserRULE_packageHeader)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(443)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserPACKAGE {
		{
			p.SetState(438)
			p.Match(KotlinParserPACKAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(439)
			p.Identifier()
		}
		p.SetState(441)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(440)
				p.Semi()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportListContext is an interface to support dynamic dispatch.
type IImportListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllImportHeader() []IImportHeaderContext
	ImportHeader(i int) IImportHeaderContext

	// IsImportListContext differentiates from other interfaces.
	IsImportListContext()
}

type ImportListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportListContext() *ImportListContext {
	var p = new(ImportListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_importList
	return p
}

func InitEmptyImportListContext(p *ImportListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_importList
}

func (*ImportListContext) IsImportListContext() {}

func NewImportListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportListContext {
	var p = new(ImportListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_importList

	return p
}

func (s *ImportListContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportListContext) AllImportHeader() []IImportHeaderContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImportHeaderContext); ok {
			len++
		}
	}

	tst := make([]IImportHeaderContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImportHeaderContext); ok {
			tst[i] = t.(IImportHeaderContext)
			i++
		}
	}

	return tst
}

func (s *ImportListContext) ImportHeader(i int) IImportHeaderContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportHeaderContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportHeaderContext)
}

func (s *ImportListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterImportList(s)
	}
}

func (s *ImportListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitImportList(s)
	}
}

func (p *KotlinParser) ImportList() (localctx IImportListContext) {
	localctx = NewImportListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, KotlinParserRULE_importList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(448)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(445)
				p.ImportHeader()
			}

		}
		p.SetState(450)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportHeaderContext is an interface to support dynamic dispatch.
type IImportHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IMPORT() antlr.TerminalNode
	Identifier() IIdentifierContext
	DOT() antlr.TerminalNode
	MULT() antlr.TerminalNode
	ImportAlias() IImportAliasContext
	Semi() ISemiContext

	// IsImportHeaderContext differentiates from other interfaces.
	IsImportHeaderContext()
}

type ImportHeaderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportHeaderContext() *ImportHeaderContext {
	var p = new(ImportHeaderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_importHeader
	return p
}

func InitEmptyImportHeaderContext(p *ImportHeaderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_importHeader
}

func (*ImportHeaderContext) IsImportHeaderContext() {}

func NewImportHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportHeaderContext {
	var p = new(ImportHeaderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_importHeader

	return p
}

func (s *ImportHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportHeaderContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(KotlinParserIMPORT, 0)
}

func (s *ImportHeaderContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ImportHeaderContext) DOT() antlr.TerminalNode {
	return s.GetToken(KotlinParserDOT, 0)
}

func (s *ImportHeaderContext) MULT() antlr.TerminalNode {
	return s.GetToken(KotlinParserMULT, 0)
}

func (s *ImportHeaderContext) ImportAlias() IImportAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportAliasContext)
}

func (s *ImportHeaderContext) Semi() ISemiContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISemiContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISemiContext)
}

func (s *ImportHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterImportHeader(s)
	}
}

func (s *ImportHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitImportHeader(s)
	}
}

func (p *KotlinParser) ImportHeader() (localctx IImportHeaderContext) {
	localctx = NewImportHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, KotlinParserRULE_importHeader)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(451)
		p.Match(KotlinParserIMPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(452)
		p.Identifier()
	}
	p.SetState(456)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case KotlinParserDOT:
		{
			p.SetState(453)
			p.Match(KotlinParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(454)
			p.Match(KotlinParserMULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KotlinParserAS:
		{
			p.SetState(455)
			p.ImportAlias()
		}

	case KotlinParserEOF, KotlinParserNL, KotlinParserLPAREN, KotlinParserLSQUARE, KotlinParserLCURL, KotlinParserADD, KotlinParserSUB, KotlinParserINCR, KotlinParserDECR, KotlinParserEXCL_WS, KotlinParserEXCL_NO_WS, KotlinParserSEMICOLON, KotlinParserCOLONCOLON, KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS, KotlinParserRETURN_AT, KotlinParserCONTINUE_AT, KotlinParserBREAK_AT, KotlinParserTHIS_AT, KotlinParserSUPER_AT, KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCLASS, KotlinParserINTERFACE, KotlinParserFUN, KotlinParserOBJECT, KotlinParserVAL, KotlinParserVAR, KotlinParserTYPE_ALIAS, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserTHIS, KotlinParserSUPER, KotlinParserWHERE, KotlinParserIF, KotlinParserWHEN, KotlinParserTRY, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserFOR, KotlinParserDO, KotlinParserWHILE, KotlinParserTHROW, KotlinParserRETURN, KotlinParserCONTINUE, KotlinParserBREAK, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserRealLiteral, KotlinParserIntegerLiteral, KotlinParserHexLiteral, KotlinParserBinLiteral, KotlinParserUnsignedLiteral, KotlinParserLongLiteral, KotlinParserBooleanLiteral, KotlinParserNullLiteral, KotlinParserCharacterLiteral, KotlinParserIdentifier, KotlinParserQUOTE_OPEN, KotlinParserTRIPLE_QUOTE_OPEN:

	default:
	}
	p.SetState(459)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(458)
			p.Semi()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportAliasContext is an interface to support dynamic dispatch.
type IImportAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AS() antlr.TerminalNode
	SimpleIdentifier() ISimpleIdentifierContext

	// IsImportAliasContext differentiates from other interfaces.
	IsImportAliasContext()
}

type ImportAliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportAliasContext() *ImportAliasContext {
	var p = new(ImportAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_importAlias
	return p
}

func InitEmptyImportAliasContext(p *ImportAliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_importAlias
}

func (*ImportAliasContext) IsImportAliasContext() {}

func NewImportAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportAliasContext {
	var p = new(ImportAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_importAlias

	return p
}

func (s *ImportAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportAliasContext) AS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAS, 0)
}

func (s *ImportAliasContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *ImportAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterImportAlias(s)
	}
}

func (s *ImportAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitImportAlias(s)
	}
}

func (p *KotlinParser) ImportAlias() (localctx IImportAliasContext) {
	localctx = NewImportAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, KotlinParserRULE_importAlias)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(461)
		p.Match(KotlinParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(462)
		p.SimpleIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITopLevelObjectContext is an interface to support dynamic dispatch.
type ITopLevelObjectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Declaration() IDeclarationContext
	Semis() ISemisContext

	// IsTopLevelObjectContext differentiates from other interfaces.
	IsTopLevelObjectContext()
}

type TopLevelObjectContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopLevelObjectContext() *TopLevelObjectContext {
	var p = new(TopLevelObjectContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_topLevelObject
	return p
}

func InitEmptyTopLevelObjectContext(p *TopLevelObjectContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_topLevelObject
}

func (*TopLevelObjectContext) IsTopLevelObjectContext() {}

func NewTopLevelObjectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TopLevelObjectContext {
	var p = new(TopLevelObjectContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_topLevelObject

	return p
}

func (s *TopLevelObjectContext) GetParser() antlr.Parser { return s.parser }

func (s *TopLevelObjectContext) Declaration() IDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *TopLevelObjectContext) Semis() ISemisContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISemisContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISemisContext)
}

func (s *TopLevelObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TopLevelObjectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TopLevelObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTopLevelObject(s)
	}
}

func (s *TopLevelObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTopLevelObject(s)
	}
}

func (p *KotlinParser) TopLevelObject() (localctx ITopLevelObjectContext) {
	localctx = NewTopLevelObjectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, KotlinParserRULE_topLevelObject)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(464)
		p.Declaration()
	}
	p.SetState(466)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserNL || _la == KotlinParserSEMICOLON {
		{
			p.SetState(465)
			p.Semis()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeAliasContext is an interface to support dynamic dispatch.
type ITypeAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TYPE_ALIAS() antlr.TerminalNode
	SimpleIdentifier() ISimpleIdentifierContext
	ASSIGNMENT() antlr.TerminalNode
	Type_() ITypeContext
	Modifiers() IModifiersContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	TypeParameters() ITypeParametersContext

	// IsTypeAliasContext differentiates from other interfaces.
	IsTypeAliasContext()
}

type TypeAliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeAliasContext() *TypeAliasContext {
	var p = new(TypeAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_typeAlias
	return p
}

func InitEmptyTypeAliasContext(p *TypeAliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_typeAlias
}

func (*TypeAliasContext) IsTypeAliasContext() {}

func NewTypeAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeAliasContext {
	var p = new(TypeAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeAlias

	return p
}

func (s *TypeAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeAliasContext) TYPE_ALIAS() antlr.TerminalNode {
	return s.GetToken(KotlinParserTYPE_ALIAS, 0)
}

func (s *TypeAliasContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *TypeAliasContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserASSIGNMENT, 0)
}

func (s *TypeAliasContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypeAliasContext) Modifiers() IModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *TypeAliasContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeAliasContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeAliasContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *TypeAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeAlias(s)
	}
}

func (s *TypeAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeAlias(s)
	}
}

func (p *KotlinParser) TypeAlias() (localctx ITypeAliasContext) {
	localctx = NewTypeAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, KotlinParserRULE_typeAlias)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(469)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || ((int64((_la-109)) & ^0x3f) == 0 && ((int64(1)<<(_la-109))&234881023) != 0) {
		{
			p.SetState(468)
			p.Modifiers()
		}

	}
	{
		p.SetState(471)
		p.Match(KotlinParserTYPE_ALIAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(475)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(472)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(477)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(478)
		p.SimpleIdentifier()
	}
	p.SetState(486)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 23, p.GetParserRuleContext()) == 1 {
		p.SetState(482)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(479)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(484)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(485)
			p.TypeParameters()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(491)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(488)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(493)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(494)
		p.Match(KotlinParserASSIGNMENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(498)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(495)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(500)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(501)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclarationContext is an interface to support dynamic dispatch.
type IDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassDeclaration() IClassDeclarationContext
	ObjectDeclaration() IObjectDeclarationContext
	FunctionDeclaration() IFunctionDeclarationContext
	PropertyDeclaration() IPropertyDeclarationContext
	TypeAlias() ITypeAliasContext

	// IsDeclarationContext differentiates from other interfaces.
	IsDeclarationContext()
}

type DeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationContext() *DeclarationContext {
	var p = new(DeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_declaration
	return p
}

func InitEmptyDeclarationContext(p *DeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_declaration
}

func (*DeclarationContext) IsDeclarationContext() {}

func NewDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationContext {
	var p = new(DeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_declaration

	return p
}

func (s *DeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *DeclarationContext) ObjectDeclaration() IObjectDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectDeclarationContext)
}

func (s *DeclarationContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *DeclarationContext) PropertyDeclaration() IPropertyDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyDeclarationContext)
}

func (s *DeclarationContext) TypeAlias() ITypeAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAliasContext)
}

func (s *DeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterDeclaration(s)
	}
}

func (s *DeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitDeclaration(s)
	}
}

func (p *KotlinParser) Declaration() (localctx IDeclarationContext) {
	localctx = NewDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, KotlinParserRULE_declaration)
	p.SetState(508)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(503)
			p.ClassDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(504)
			p.ObjectDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(505)
			p.FunctionDeclaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(506)
			p.PropertyDeclaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(507)
			p.TypeAlias()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassDeclarationContext is an interface to support dynamic dispatch.
type IClassDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleIdentifier() ISimpleIdentifierContext
	CLASS() antlr.TerminalNode
	INTERFACE() antlr.TerminalNode
	Modifiers() IModifiersContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	TypeParameters() ITypeParametersContext
	PrimaryConstructor() IPrimaryConstructorContext
	COLON() antlr.TerminalNode
	DelegationSpecifiers() IDelegationSpecifiersContext
	TypeConstraints() ITypeConstraintsContext
	ClassBody() IClassBodyContext
	EnumClassBody() IEnumClassBodyContext
	FUN() antlr.TerminalNode

	// IsClassDeclarationContext differentiates from other interfaces.
	IsClassDeclarationContext()
}

type ClassDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDeclarationContext() *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_classDeclaration
	return p
}

func InitEmptyClassDeclarationContext(p *ClassDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_classDeclaration
}

func (*ClassDeclarationContext) IsClassDeclarationContext() {}

func NewClassDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_classDeclaration

	return p
}

func (s *ClassDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *ClassDeclarationContext) CLASS() antlr.TerminalNode {
	return s.GetToken(KotlinParserCLASS, 0)
}

func (s *ClassDeclarationContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(KotlinParserINTERFACE, 0)
}

func (s *ClassDeclarationContext) Modifiers() IModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *ClassDeclarationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ClassDeclarationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ClassDeclarationContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *ClassDeclarationContext) PrimaryConstructor() IPrimaryConstructorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryConstructorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryConstructorContext)
}

func (s *ClassDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *ClassDeclarationContext) DelegationSpecifiers() IDelegationSpecifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelegationSpecifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelegationSpecifiersContext)
}

func (s *ClassDeclarationContext) TypeConstraints() ITypeConstraintsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeConstraintsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeConstraintsContext)
}

func (s *ClassDeclarationContext) ClassBody() IClassBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *ClassDeclarationContext) EnumClassBody() IEnumClassBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumClassBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumClassBodyContext)
}

func (s *ClassDeclarationContext) FUN() antlr.TerminalNode {
	return s.GetToken(KotlinParserFUN, 0)
}

func (s *ClassDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterClassDeclaration(s)
	}
}

func (s *ClassDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitClassDeclaration(s)
	}
}

func (p *KotlinParser) ClassDeclaration() (localctx IClassDeclarationContext) {
	localctx = NewClassDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, KotlinParserRULE_classDeclaration)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(511)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || ((int64((_la-109)) & ^0x3f) == 0 && ((int64(1)<<(_la-109))&234881023) != 0) {
		{
			p.SetState(510)
			p.Modifiers()
		}

	}
	p.SetState(524)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KotlinParserCLASS:
		{
			p.SetState(513)
			p.Match(KotlinParserCLASS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KotlinParserINTERFACE, KotlinParserFUN:
		p.SetState(521)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KotlinParserFUN {
			{
				p.SetState(514)
				p.Match(KotlinParserFUN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(518)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(515)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(520)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(523)
			p.Match(KotlinParserINTERFACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(529)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(526)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(531)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(532)
		p.SimpleIdentifier()
	}
	p.SetState(540)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext()) == 1 {
		p.SetState(536)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(533)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(538)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(539)
			p.TypeParameters()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(549)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext()) == 1 {
		p.SetState(545)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(542)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(547)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(548)
			p.PrimaryConstructor()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(565)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 38, p.GetParserRuleContext()) == 1 {
		p.SetState(554)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(551)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(556)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(557)
			p.Match(KotlinParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(561)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(558)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(563)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(564)
			p.DelegationSpecifiers()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(574)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext()) == 1 {
		p.SetState(570)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(567)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(572)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(573)
			p.TypeConstraints()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(590)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 43, p.GetParserRuleContext()) == 1 {
		p.SetState(579)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(576)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(581)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(582)
			p.ClassBody()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 43, p.GetParserRuleContext()) == 2 {
		p.SetState(586)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(583)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(588)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(589)
			p.EnumClassBody()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryConstructorContext is an interface to support dynamic dispatch.
type IPrimaryConstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassParameters() IClassParametersContext
	CONSTRUCTOR() antlr.TerminalNode
	Modifiers() IModifiersContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsPrimaryConstructorContext differentiates from other interfaces.
	IsPrimaryConstructorContext()
}

type PrimaryConstructorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryConstructorContext() *PrimaryConstructorContext {
	var p = new(PrimaryConstructorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_primaryConstructor
	return p
}

func InitEmptyPrimaryConstructorContext(p *PrimaryConstructorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_primaryConstructor
}

func (*PrimaryConstructorContext) IsPrimaryConstructorContext() {}

func NewPrimaryConstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryConstructorContext {
	var p = new(PrimaryConstructorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_primaryConstructor

	return p
}

func (s *PrimaryConstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryConstructorContext) ClassParameters() IClassParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassParametersContext)
}

func (s *PrimaryConstructorContext) CONSTRUCTOR() antlr.TerminalNode {
	return s.GetToken(KotlinParserCONSTRUCTOR, 0)
}

func (s *PrimaryConstructorContext) Modifiers() IModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *PrimaryConstructorContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *PrimaryConstructorContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *PrimaryConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryConstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPrimaryConstructor(s)
	}
}

func (s *PrimaryConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPrimaryConstructor(s)
	}
}

func (p *KotlinParser) PrimaryConstructor() (localctx IPrimaryConstructorContext) {
	localctx = NewPrimaryConstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, KotlinParserRULE_primaryConstructor)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(602)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || ((int64((_la-81)) & ^0x3f) == 0 && ((int64(1)<<(_la-81))&63050394514751489) != 0) {
		p.SetState(593)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || ((int64((_la-109)) & ^0x3f) == 0 && ((int64(1)<<(_la-109))&234881023) != 0) {
			{
				p.SetState(592)
				p.Modifiers()
			}

		}
		{
			p.SetState(595)
			p.Match(KotlinParserCONSTRUCTOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(599)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(596)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(601)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(604)
		p.ClassParameters()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassBodyContext is an interface to support dynamic dispatch.
type IClassBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LCURL() antlr.TerminalNode
	ClassMemberDeclarations() IClassMemberDeclarationsContext
	RCURL() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsClassBodyContext differentiates from other interfaces.
	IsClassBodyContext()
}

type ClassBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassBodyContext() *ClassBodyContext {
	var p = new(ClassBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_classBody
	return p
}

func InitEmptyClassBodyContext(p *ClassBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_classBody
}

func (*ClassBodyContext) IsClassBodyContext() {}

func NewClassBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassBodyContext {
	var p = new(ClassBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_classBody

	return p
}

func (s *ClassBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassBodyContext) LCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserLCURL, 0)
}

func (s *ClassBodyContext) ClassMemberDeclarations() IClassMemberDeclarationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassMemberDeclarationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassMemberDeclarationsContext)
}

func (s *ClassBodyContext) RCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserRCURL, 0)
}

func (s *ClassBodyContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ClassBodyContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ClassBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterClassBody(s)
	}
}

func (s *ClassBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitClassBody(s)
	}
}

func (p *KotlinParser) ClassBody() (localctx IClassBodyContext) {
	localctx = NewClassBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, KotlinParserRULE_classBody)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(606)
		p.Match(KotlinParserLCURL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(610)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(607)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(612)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(613)
		p.ClassMemberDeclarations()
	}
	p.SetState(617)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(614)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(619)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(620)
		p.Match(KotlinParserRCURL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassParametersContext is an interface to support dynamic dispatch.
type IClassParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	AllClassParameter() []IClassParameterContext
	ClassParameter(i int) IClassParameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsClassParametersContext differentiates from other interfaces.
	IsClassParametersContext()
}

type ClassParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassParametersContext() *ClassParametersContext {
	var p = new(ClassParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_classParameters
	return p
}

func InitEmptyClassParametersContext(p *ClassParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_classParameters
}

func (*ClassParametersContext) IsClassParametersContext() {}

func NewClassParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassParametersContext {
	var p = new(ClassParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_classParameters

	return p
}

func (s *ClassParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassParametersContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *ClassParametersContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *ClassParametersContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ClassParametersContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ClassParametersContext) AllClassParameter() []IClassParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassParameterContext); ok {
			len++
		}
	}

	tst := make([]IClassParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassParameterContext); ok {
			tst[i] = t.(IClassParameterContext)
			i++
		}
	}

	return tst
}

func (s *ClassParametersContext) ClassParameter(i int) IClassParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassParameterContext)
}

func (s *ClassParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *ClassParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *ClassParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterClassParameters(s)
	}
}

func (s *ClassParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitClassParameters(s)
	}
}

func (p *KotlinParser) ClassParameters() (localctx IClassParametersContext) {
	localctx = NewClassParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, KotlinParserRULE_classParameters)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(622)
		p.Match(KotlinParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(626)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(623)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(628)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(658)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 55, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(629)
			p.ClassParameter()
		}
		p.SetState(646)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(633)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == KotlinParserNL {
					{
						p.SetState(630)
						p.Match(KotlinParserNL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

					p.SetState(635)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(636)
					p.Match(KotlinParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(640)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 51, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(637)
							p.Match(KotlinParserNL)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}

					}
					p.SetState(642)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 51, p.GetParserRuleContext())
					if p.HasError() {
						goto errorExit
					}
				}
				{
					p.SetState(643)
					p.ClassParameter()
				}

			}
			p.SetState(648)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(656)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 54, p.GetParserRuleContext()) == 1 {
			p.SetState(652)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(649)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(654)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(655)
				p.Match(KotlinParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(663)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(660)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(665)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(666)
		p.Match(KotlinParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassParameterContext is an interface to support dynamic dispatch.
type IClassParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleIdentifier() ISimpleIdentifierContext
	COLON() antlr.TerminalNode
	Type_() ITypeContext
	Modifiers() IModifiersContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	ASSIGNMENT() antlr.TerminalNode
	Expression() IExpressionContext
	VAL() antlr.TerminalNode
	VAR() antlr.TerminalNode

	// IsClassParameterContext differentiates from other interfaces.
	IsClassParameterContext()
}

type ClassParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassParameterContext() *ClassParameterContext {
	var p = new(ClassParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_classParameter
	return p
}

func InitEmptyClassParameterContext(p *ClassParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_classParameter
}

func (*ClassParameterContext) IsClassParameterContext() {}

func NewClassParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassParameterContext {
	var p = new(ClassParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_classParameter

	return p
}

func (s *ClassParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassParameterContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *ClassParameterContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *ClassParameterContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ClassParameterContext) Modifiers() IModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *ClassParameterContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ClassParameterContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ClassParameterContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserASSIGNMENT, 0)
}

func (s *ClassParameterContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ClassParameterContext) VAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserVAL, 0)
}

func (s *ClassParameterContext) VAR() antlr.TerminalNode {
	return s.GetToken(KotlinParserVAR, 0)
}

func (s *ClassParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterClassParameter(s)
	}
}

func (s *ClassParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitClassParameter(s)
	}
}

func (p *KotlinParser) ClassParameter() (localctx IClassParameterContext) {
	localctx = NewClassParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, KotlinParserRULE_classParameter)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(669)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(668)
			p.Modifiers()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(672)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserVAL || _la == KotlinParserVAR {
		{
			p.SetState(671)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KotlinParserVAL || _la == KotlinParserVAR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(677)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(674)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(679)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(680)
		p.SimpleIdentifier()
	}
	{
		p.SetState(681)
		p.Match(KotlinParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(685)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(682)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(687)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(688)
		p.Type_()
	}
	p.SetState(703)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 63, p.GetParserRuleContext()) == 1 {
		p.SetState(692)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(689)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(694)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(695)
			p.Match(KotlinParserASSIGNMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(699)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(696)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(701)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(702)
			p.Expression()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDelegationSpecifiersContext is an interface to support dynamic dispatch.
type IDelegationSpecifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAnnotatedDelegationSpecifier() []IAnnotatedDelegationSpecifierContext
	AnnotatedDelegationSpecifier(i int) IAnnotatedDelegationSpecifierContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsDelegationSpecifiersContext differentiates from other interfaces.
	IsDelegationSpecifiersContext()
}

type DelegationSpecifiersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelegationSpecifiersContext() *DelegationSpecifiersContext {
	var p = new(DelegationSpecifiersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_delegationSpecifiers
	return p
}

func InitEmptyDelegationSpecifiersContext(p *DelegationSpecifiersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_delegationSpecifiers
}

func (*DelegationSpecifiersContext) IsDelegationSpecifiersContext() {}

func NewDelegationSpecifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DelegationSpecifiersContext {
	var p = new(DelegationSpecifiersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_delegationSpecifiers

	return p
}

func (s *DelegationSpecifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *DelegationSpecifiersContext) AllAnnotatedDelegationSpecifier() []IAnnotatedDelegationSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotatedDelegationSpecifierContext); ok {
			len++
		}
	}

	tst := make([]IAnnotatedDelegationSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotatedDelegationSpecifierContext); ok {
			tst[i] = t.(IAnnotatedDelegationSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *DelegationSpecifiersContext) AnnotatedDelegationSpecifier(i int) IAnnotatedDelegationSpecifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotatedDelegationSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotatedDelegationSpecifierContext)
}

func (s *DelegationSpecifiersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *DelegationSpecifiersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *DelegationSpecifiersContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *DelegationSpecifiersContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *DelegationSpecifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DelegationSpecifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DelegationSpecifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterDelegationSpecifiers(s)
	}
}

func (s *DelegationSpecifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitDelegationSpecifiers(s)
	}
}

func (p *KotlinParser) DelegationSpecifiers() (localctx IDelegationSpecifiersContext) {
	localctx = NewDelegationSpecifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, KotlinParserRULE_delegationSpecifiers)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(705)
		p.AnnotatedDelegationSpecifier()
	}
	p.SetState(722)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 66, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(709)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(706)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(711)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(712)
				p.Match(KotlinParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(716)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(713)
						p.Match(KotlinParserNL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				p.SetState(718)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			{
				p.SetState(719)
				p.AnnotatedDelegationSpecifier()
			}

		}
		p.SetState(724)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 66, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDelegationSpecifierContext is an interface to support dynamic dispatch.
type IDelegationSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ConstructorInvocation() IConstructorInvocationContext
	ExplicitDelegation() IExplicitDelegationContext
	UserType() IUserTypeContext
	FunctionType() IFunctionTypeContext
	SUSPEND() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsDelegationSpecifierContext differentiates from other interfaces.
	IsDelegationSpecifierContext()
}

type DelegationSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelegationSpecifierContext() *DelegationSpecifierContext {
	var p = new(DelegationSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_delegationSpecifier
	return p
}

func InitEmptyDelegationSpecifierContext(p *DelegationSpecifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_delegationSpecifier
}

func (*DelegationSpecifierContext) IsDelegationSpecifierContext() {}

func NewDelegationSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DelegationSpecifierContext {
	var p = new(DelegationSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_delegationSpecifier

	return p
}

func (s *DelegationSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *DelegationSpecifierContext) ConstructorInvocation() IConstructorInvocationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstructorInvocationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstructorInvocationContext)
}

func (s *DelegationSpecifierContext) ExplicitDelegation() IExplicitDelegationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplicitDelegationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplicitDelegationContext)
}

func (s *DelegationSpecifierContext) UserType() IUserTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserTypeContext)
}

func (s *DelegationSpecifierContext) FunctionType() IFunctionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeContext)
}

func (s *DelegationSpecifierContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(KotlinParserSUSPEND, 0)
}

func (s *DelegationSpecifierContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *DelegationSpecifierContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *DelegationSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DelegationSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DelegationSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterDelegationSpecifier(s)
	}
}

func (s *DelegationSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitDelegationSpecifier(s)
	}
}

func (p *KotlinParser) DelegationSpecifier() (localctx IDelegationSpecifierContext) {
	localctx = NewDelegationSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, KotlinParserRULE_delegationSpecifier)
	var _la int

	p.SetState(737)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(725)
			p.ConstructorInvocation()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(726)
			p.ExplicitDelegation()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(727)
			p.UserType()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(728)
			p.FunctionType()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(729)
			p.Match(KotlinParserSUSPEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(733)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(730)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(735)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(736)
			p.FunctionType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstructorInvocationContext is an interface to support dynamic dispatch.
type IConstructorInvocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UserType() IUserTypeContext
	ValueArguments() IValueArgumentsContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsConstructorInvocationContext differentiates from other interfaces.
	IsConstructorInvocationContext()
}

type ConstructorInvocationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructorInvocationContext() *ConstructorInvocationContext {
	var p = new(ConstructorInvocationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_constructorInvocation
	return p
}

func InitEmptyConstructorInvocationContext(p *ConstructorInvocationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_constructorInvocation
}

func (*ConstructorInvocationContext) IsConstructorInvocationContext() {}

func NewConstructorInvocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstructorInvocationContext {
	var p = new(ConstructorInvocationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_constructorInvocation

	return p
}

func (s *ConstructorInvocationContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstructorInvocationContext) UserType() IUserTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserTypeContext)
}

func (s *ConstructorInvocationContext) ValueArguments() IValueArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueArgumentsContext)
}

func (s *ConstructorInvocationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ConstructorInvocationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ConstructorInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstructorInvocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstructorInvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterConstructorInvocation(s)
	}
}

func (s *ConstructorInvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitConstructorInvocation(s)
	}
}

func (p *KotlinParser) ConstructorInvocation() (localctx IConstructorInvocationContext) {
	localctx = NewConstructorInvocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, KotlinParserRULE_constructorInvocation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(739)
		p.UserType()
	}
	p.SetState(743)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(740)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(745)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(746)
		p.ValueArguments()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnnotatedDelegationSpecifierContext is an interface to support dynamic dispatch.
type IAnnotatedDelegationSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DelegationSpecifier() IDelegationSpecifierContext
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsAnnotatedDelegationSpecifierContext differentiates from other interfaces.
	IsAnnotatedDelegationSpecifierContext()
}

type AnnotatedDelegationSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotatedDelegationSpecifierContext() *AnnotatedDelegationSpecifierContext {
	var p = new(AnnotatedDelegationSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_annotatedDelegationSpecifier
	return p
}

func InitEmptyAnnotatedDelegationSpecifierContext(p *AnnotatedDelegationSpecifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_annotatedDelegationSpecifier
}

func (*AnnotatedDelegationSpecifierContext) IsAnnotatedDelegationSpecifierContext() {}

func NewAnnotatedDelegationSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotatedDelegationSpecifierContext {
	var p = new(AnnotatedDelegationSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_annotatedDelegationSpecifier

	return p
}

func (s *AnnotatedDelegationSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotatedDelegationSpecifierContext) DelegationSpecifier() IDelegationSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelegationSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelegationSpecifierContext)
}

func (s *AnnotatedDelegationSpecifierContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *AnnotatedDelegationSpecifierContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *AnnotatedDelegationSpecifierContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *AnnotatedDelegationSpecifierContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *AnnotatedDelegationSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotatedDelegationSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotatedDelegationSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAnnotatedDelegationSpecifier(s)
	}
}

func (s *AnnotatedDelegationSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAnnotatedDelegationSpecifier(s)
	}
}

func (p *KotlinParser) AnnotatedDelegationSpecifier() (localctx IAnnotatedDelegationSpecifierContext) {
	localctx = NewAnnotatedDelegationSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, KotlinParserRULE_annotatedDelegationSpecifier)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(751)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(748)
				p.Annotation()
			}

		}
		p.SetState(753)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(757)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(754)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(759)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(760)
		p.DelegationSpecifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExplicitDelegationContext is an interface to support dynamic dispatch.
type IExplicitDelegationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BY() antlr.TerminalNode
	Expression() IExpressionContext
	UserType() IUserTypeContext
	FunctionType() IFunctionTypeContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsExplicitDelegationContext differentiates from other interfaces.
	IsExplicitDelegationContext()
}

type ExplicitDelegationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplicitDelegationContext() *ExplicitDelegationContext {
	var p = new(ExplicitDelegationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_explicitDelegation
	return p
}

func InitEmptyExplicitDelegationContext(p *ExplicitDelegationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_explicitDelegation
}

func (*ExplicitDelegationContext) IsExplicitDelegationContext() {}

func NewExplicitDelegationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplicitDelegationContext {
	var p = new(ExplicitDelegationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_explicitDelegation

	return p
}

func (s *ExplicitDelegationContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplicitDelegationContext) BY() antlr.TerminalNode {
	return s.GetToken(KotlinParserBY, 0)
}

func (s *ExplicitDelegationContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExplicitDelegationContext) UserType() IUserTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserTypeContext)
}

func (s *ExplicitDelegationContext) FunctionType() IFunctionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeContext)
}

func (s *ExplicitDelegationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ExplicitDelegationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ExplicitDelegationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplicitDelegationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplicitDelegationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterExplicitDelegation(s)
	}
}

func (s *ExplicitDelegationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitExplicitDelegation(s)
	}
}

func (p *KotlinParser) ExplicitDelegation() (localctx IExplicitDelegationContext) {
	localctx = NewExplicitDelegationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, KotlinParserRULE_explicitDelegation)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(764)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 72, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(762)
			p.UserType()
		}

	case 2:
		{
			p.SetState(763)
			p.FunctionType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(769)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(766)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(771)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(772)
		p.Match(KotlinParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(776)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(773)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(778)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(779)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeParametersContext is an interface to support dynamic dispatch.
type ITypeParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LANGLE() antlr.TerminalNode
	AllTypeParameter() []ITypeParameterContext
	TypeParameter(i int) ITypeParameterContext
	RANGLE() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypeParametersContext differentiates from other interfaces.
	IsTypeParametersContext()
}

type TypeParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParametersContext() *TypeParametersContext {
	var p = new(TypeParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_typeParameters
	return p
}

func InitEmptyTypeParametersContext(p *TypeParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_typeParameters
}

func (*TypeParametersContext) IsTypeParametersContext() {}

func NewTypeParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParametersContext {
	var p = new(TypeParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeParameters

	return p
}

func (s *TypeParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParametersContext) LANGLE() antlr.TerminalNode {
	return s.GetToken(KotlinParserLANGLE, 0)
}

func (s *TypeParametersContext) AllTypeParameter() []ITypeParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeParameterContext); ok {
			len++
		}
	}

	tst := make([]ITypeParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeParameterContext); ok {
			tst[i] = t.(ITypeParameterContext)
			i++
		}
	}

	return tst
}

func (s *TypeParametersContext) TypeParameter(i int) ITypeParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterContext)
}

func (s *TypeParametersContext) RANGLE() antlr.TerminalNode {
	return s.GetToken(KotlinParserRANGLE, 0)
}

func (s *TypeParametersContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeParametersContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *TypeParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *TypeParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeParameters(s)
	}
}

func (s *TypeParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeParameters(s)
	}
}

func (p *KotlinParser) TypeParameters() (localctx ITypeParametersContext) {
	localctx = NewTypeParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, KotlinParserRULE_typeParameters)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(781)
		p.Match(KotlinParserLANGLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(785)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(782)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(787)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(788)
		p.TypeParameter()
	}
	p.SetState(805)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 78, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(792)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(789)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(794)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(795)
				p.Match(KotlinParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(799)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 77, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(796)
						p.Match(KotlinParserNL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				p.SetState(801)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 77, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			{
				p.SetState(802)
				p.TypeParameter()
			}

		}
		p.SetState(807)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 78, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(815)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 80, p.GetParserRuleContext()) == 1 {
		p.SetState(811)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(808)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(813)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(814)
			p.Match(KotlinParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(820)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(817)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(822)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(823)
		p.Match(KotlinParserRANGLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeParameterContext is an interface to support dynamic dispatch.
type ITypeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleIdentifier() ISimpleIdentifierContext
	TypeParameterModifiers() ITypeParameterModifiersContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	COLON() antlr.TerminalNode
	Type_() ITypeContext

	// IsTypeParameterContext differentiates from other interfaces.
	IsTypeParameterContext()
}

type TypeParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterContext() *TypeParameterContext {
	var p = new(TypeParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_typeParameter
	return p
}

func InitEmptyTypeParameterContext(p *TypeParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_typeParameter
}

func (*TypeParameterContext) IsTypeParameterContext() {}

func NewTypeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterContext {
	var p = new(TypeParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeParameter

	return p
}

func (s *TypeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *TypeParameterContext) TypeParameterModifiers() ITypeParameterModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterModifiersContext)
}

func (s *TypeParameterContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeParameterContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeParameterContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *TypeParameterContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeParameter(s)
	}
}

func (s *TypeParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeParameter(s)
	}
}

func (p *KotlinParser) TypeParameter() (localctx ITypeParameterContext) {
	localctx = NewTypeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, KotlinParserRULE_typeParameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(826)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 82, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(825)
			p.TypeParameterModifiers()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(831)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(828)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(833)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(834)
		p.SimpleIdentifier()
	}
	p.SetState(849)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext()) == 1 {
		p.SetState(838)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(835)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(840)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(841)
			p.Match(KotlinParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(845)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(842)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(847)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(848)
			p.Type_()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeConstraintsContext is an interface to support dynamic dispatch.
type ITypeConstraintsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHERE() antlr.TerminalNode
	AllTypeConstraint() []ITypeConstraintContext
	TypeConstraint(i int) ITypeConstraintContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypeConstraintsContext differentiates from other interfaces.
	IsTypeConstraintsContext()
}

type TypeConstraintsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeConstraintsContext() *TypeConstraintsContext {
	var p = new(TypeConstraintsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_typeConstraints
	return p
}

func InitEmptyTypeConstraintsContext(p *TypeConstraintsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_typeConstraints
}

func (*TypeConstraintsContext) IsTypeConstraintsContext() {}

func NewTypeConstraintsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeConstraintsContext {
	var p = new(TypeConstraintsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeConstraints

	return p
}

func (s *TypeConstraintsContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeConstraintsContext) WHERE() antlr.TerminalNode {
	return s.GetToken(KotlinParserWHERE, 0)
}

func (s *TypeConstraintsContext) AllTypeConstraint() []ITypeConstraintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeConstraintContext); ok {
			len++
		}
	}

	tst := make([]ITypeConstraintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeConstraintContext); ok {
			tst[i] = t.(ITypeConstraintContext)
			i++
		}
	}

	return tst
}

func (s *TypeConstraintsContext) TypeConstraint(i int) ITypeConstraintContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeConstraintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeConstraintContext)
}

func (s *TypeConstraintsContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeConstraintsContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeConstraintsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *TypeConstraintsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *TypeConstraintsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeConstraintsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeConstraintsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeConstraints(s)
	}
}

func (s *TypeConstraintsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeConstraints(s)
	}
}

func (p *KotlinParser) TypeConstraints() (localctx ITypeConstraintsContext) {
	localctx = NewTypeConstraintsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, KotlinParserRULE_typeConstraints)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(851)
		p.Match(KotlinParserWHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(855)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(852)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(857)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(858)
		p.TypeConstraint()
	}
	p.SetState(875)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 90, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(862)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(859)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(864)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(865)
				p.Match(KotlinParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(869)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(866)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(871)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(872)
				p.TypeConstraint()
			}

		}
		p.SetState(877)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 90, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeConstraintContext is an interface to support dynamic dispatch.
type ITypeConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleIdentifier() ISimpleIdentifierContext
	COLON() antlr.TerminalNode
	Type_() ITypeContext
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsTypeConstraintContext differentiates from other interfaces.
	IsTypeConstraintContext()
}

type TypeConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeConstraintContext() *TypeConstraintContext {
	var p = new(TypeConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_typeConstraint
	return p
}

func InitEmptyTypeConstraintContext(p *TypeConstraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_typeConstraint
}

func (*TypeConstraintContext) IsTypeConstraintContext() {}

func NewTypeConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeConstraintContext {
	var p = new(TypeConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeConstraint

	return p
}

func (s *TypeConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeConstraintContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *TypeConstraintContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *TypeConstraintContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypeConstraintContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *TypeConstraintContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *TypeConstraintContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeConstraintContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeConstraint(s)
	}
}

func (s *TypeConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeConstraint(s)
	}
}

func (p *KotlinParser) TypeConstraint() (localctx ITypeConstraintContext) {
	localctx = NewTypeConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, KotlinParserRULE_typeConstraint)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(881)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS {
		{
			p.SetState(878)
			p.Annotation()
		}

		p.SetState(883)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(884)
		p.SimpleIdentifier()
	}
	p.SetState(888)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(885)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(890)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(891)
		p.Match(KotlinParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(895)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(892)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(897)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(898)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassMemberDeclarationsContext is an interface to support dynamic dispatch.
type IClassMemberDeclarationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllClassMemberDeclaration() []IClassMemberDeclarationContext
	ClassMemberDeclaration(i int) IClassMemberDeclarationContext
	AllSemis() []ISemisContext
	Semis(i int) ISemisContext

	// IsClassMemberDeclarationsContext differentiates from other interfaces.
	IsClassMemberDeclarationsContext()
}

type ClassMemberDeclarationsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassMemberDeclarationsContext() *ClassMemberDeclarationsContext {
	var p = new(ClassMemberDeclarationsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_classMemberDeclarations
	return p
}

func InitEmptyClassMemberDeclarationsContext(p *ClassMemberDeclarationsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_classMemberDeclarations
}

func (*ClassMemberDeclarationsContext) IsClassMemberDeclarationsContext() {}

func NewClassMemberDeclarationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassMemberDeclarationsContext {
	var p = new(ClassMemberDeclarationsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_classMemberDeclarations

	return p
}

func (s *ClassMemberDeclarationsContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassMemberDeclarationsContext) AllClassMemberDeclaration() []IClassMemberDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassMemberDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IClassMemberDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassMemberDeclarationContext); ok {
			tst[i] = t.(IClassMemberDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ClassMemberDeclarationsContext) ClassMemberDeclaration(i int) IClassMemberDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassMemberDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassMemberDeclarationContext)
}

func (s *ClassMemberDeclarationsContext) AllSemis() []ISemisContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISemisContext); ok {
			len++
		}
	}

	tst := make([]ISemisContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISemisContext); ok {
			tst[i] = t.(ISemisContext)
			i++
		}
	}

	return tst
}

func (s *ClassMemberDeclarationsContext) Semis(i int) ISemisContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISemisContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISemisContext)
}

func (s *ClassMemberDeclarationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassMemberDeclarationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassMemberDeclarationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterClassMemberDeclarations(s)
	}
}

func (s *ClassMemberDeclarationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitClassMemberDeclarations(s)
	}
}

func (p *KotlinParser) ClassMemberDeclarations() (localctx IClassMemberDeclarationsContext) {
	localctx = NewClassMemberDeclarationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, KotlinParserRULE_classMemberDeclarations)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(906)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || ((int64((_la-74)) & ^0x3f) == 0 && ((int64(1)<<(_la-74))&8070450497888192255) != 0) {
		{
			p.SetState(900)
			p.ClassMemberDeclaration()
		}
		p.SetState(902)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 94, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(901)
				p.Semis()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

		p.SetState(908)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassMemberDeclarationContext is an interface to support dynamic dispatch.
type IClassMemberDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Declaration() IDeclarationContext
	CompanionObject() ICompanionObjectContext
	AnonymousInitializer() IAnonymousInitializerContext
	SecondaryConstructor() ISecondaryConstructorContext

	// IsClassMemberDeclarationContext differentiates from other interfaces.
	IsClassMemberDeclarationContext()
}

type ClassMemberDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassMemberDeclarationContext() *ClassMemberDeclarationContext {
	var p = new(ClassMemberDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_classMemberDeclaration
	return p
}

func InitEmptyClassMemberDeclarationContext(p *ClassMemberDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_classMemberDeclaration
}

func (*ClassMemberDeclarationContext) IsClassMemberDeclarationContext() {}

func NewClassMemberDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassMemberDeclarationContext {
	var p = new(ClassMemberDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_classMemberDeclaration

	return p
}

func (s *ClassMemberDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassMemberDeclarationContext) Declaration() IDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *ClassMemberDeclarationContext) CompanionObject() ICompanionObjectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompanionObjectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompanionObjectContext)
}

func (s *ClassMemberDeclarationContext) AnonymousInitializer() IAnonymousInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnonymousInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnonymousInitializerContext)
}

func (s *ClassMemberDeclarationContext) SecondaryConstructor() ISecondaryConstructorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISecondaryConstructorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISecondaryConstructorContext)
}

func (s *ClassMemberDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassMemberDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassMemberDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterClassMemberDeclaration(s)
	}
}

func (s *ClassMemberDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitClassMemberDeclaration(s)
	}
}

func (p *KotlinParser) ClassMemberDeclaration() (localctx IClassMemberDeclarationContext) {
	localctx = NewClassMemberDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, KotlinParserRULE_classMemberDeclaration)
	p.SetState(913)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 96, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(909)
			p.Declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(910)
			p.CompanionObject()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(911)
			p.AnonymousInitializer()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(912)
			p.SecondaryConstructor()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnonymousInitializerContext is an interface to support dynamic dispatch.
type IAnonymousInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INIT() antlr.TerminalNode
	Block() IBlockContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsAnonymousInitializerContext differentiates from other interfaces.
	IsAnonymousInitializerContext()
}

type AnonymousInitializerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnonymousInitializerContext() *AnonymousInitializerContext {
	var p = new(AnonymousInitializerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_anonymousInitializer
	return p
}

func InitEmptyAnonymousInitializerContext(p *AnonymousInitializerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_anonymousInitializer
}

func (*AnonymousInitializerContext) IsAnonymousInitializerContext() {}

func NewAnonymousInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnonymousInitializerContext {
	var p = new(AnonymousInitializerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_anonymousInitializer

	return p
}

func (s *AnonymousInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *AnonymousInitializerContext) INIT() antlr.TerminalNode {
	return s.GetToken(KotlinParserINIT, 0)
}

func (s *AnonymousInitializerContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *AnonymousInitializerContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *AnonymousInitializerContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *AnonymousInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnonymousInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnonymousInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAnonymousInitializer(s)
	}
}

func (s *AnonymousInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAnonymousInitializer(s)
	}
}

func (p *KotlinParser) AnonymousInitializer() (localctx IAnonymousInitializerContext) {
	localctx = NewAnonymousInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, KotlinParserRULE_anonymousInitializer)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(915)
		p.Match(KotlinParserINIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(919)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(916)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(921)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(922)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompanionObjectContext is an interface to support dynamic dispatch.
type ICompanionObjectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMPANION() antlr.TerminalNode
	OBJECT() antlr.TerminalNode
	Modifiers() IModifiersContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	DATA() antlr.TerminalNode
	SimpleIdentifier() ISimpleIdentifierContext
	COLON() antlr.TerminalNode
	DelegationSpecifiers() IDelegationSpecifiersContext
	ClassBody() IClassBodyContext

	// IsCompanionObjectContext differentiates from other interfaces.
	IsCompanionObjectContext()
}

type CompanionObjectContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompanionObjectContext() *CompanionObjectContext {
	var p = new(CompanionObjectContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_companionObject
	return p
}

func InitEmptyCompanionObjectContext(p *CompanionObjectContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_companionObject
}

func (*CompanionObjectContext) IsCompanionObjectContext() {}

func NewCompanionObjectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompanionObjectContext {
	var p = new(CompanionObjectContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_companionObject

	return p
}

func (s *CompanionObjectContext) GetParser() antlr.Parser { return s.parser }

func (s *CompanionObjectContext) COMPANION() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMPANION, 0)
}

func (s *CompanionObjectContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(KotlinParserOBJECT, 0)
}

func (s *CompanionObjectContext) Modifiers() IModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *CompanionObjectContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *CompanionObjectContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *CompanionObjectContext) DATA() antlr.TerminalNode {
	return s.GetToken(KotlinParserDATA, 0)
}

func (s *CompanionObjectContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *CompanionObjectContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *CompanionObjectContext) DelegationSpecifiers() IDelegationSpecifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelegationSpecifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelegationSpecifiersContext)
}

func (s *CompanionObjectContext) ClassBody() IClassBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *CompanionObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompanionObjectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompanionObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterCompanionObject(s)
	}
}

func (s *CompanionObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitCompanionObject(s)
	}
}

func (p *KotlinParser) CompanionObject() (localctx ICompanionObjectContext) {
	localctx = NewCompanionObjectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, KotlinParserRULE_companionObject)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(925)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || ((int64((_la-109)) & ^0x3f) == 0 && ((int64(1)<<(_la-109))&234881023) != 0) {
		{
			p.SetState(924)
			p.Modifiers()
		}

	}
	{
		p.SetState(927)
		p.Match(KotlinParserCOMPANION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(931)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 99, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(928)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(933)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 99, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(935)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserDATA {
		{
			p.SetState(934)
			p.Match(KotlinParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(940)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(937)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(942)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(943)
		p.Match(KotlinParserOBJECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(951)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 103, p.GetParserRuleContext()) == 1 {
		p.SetState(947)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(944)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(949)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(950)
			p.SimpleIdentifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(967)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 106, p.GetParserRuleContext()) == 1 {
		p.SetState(956)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(953)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(958)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(959)
			p.Match(KotlinParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(963)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 105, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(960)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(965)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 105, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(966)
			p.DelegationSpecifiers()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(976)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 108, p.GetParserRuleContext()) == 1 {
		p.SetState(972)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(969)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(974)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(975)
			p.ClassBody()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionValueParametersContext is an interface to support dynamic dispatch.
type IFunctionValueParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	AllFunctionValueParameter() []IFunctionValueParameterContext
	FunctionValueParameter(i int) IFunctionValueParameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFunctionValueParametersContext differentiates from other interfaces.
	IsFunctionValueParametersContext()
}

type FunctionValueParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionValueParametersContext() *FunctionValueParametersContext {
	var p = new(FunctionValueParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_functionValueParameters
	return p
}

func InitEmptyFunctionValueParametersContext(p *FunctionValueParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_functionValueParameters
}

func (*FunctionValueParametersContext) IsFunctionValueParametersContext() {}

func NewFunctionValueParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionValueParametersContext {
	var p = new(FunctionValueParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_functionValueParameters

	return p
}

func (s *FunctionValueParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionValueParametersContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *FunctionValueParametersContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *FunctionValueParametersContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *FunctionValueParametersContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *FunctionValueParametersContext) AllFunctionValueParameter() []IFunctionValueParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionValueParameterContext); ok {
			len++
		}
	}

	tst := make([]IFunctionValueParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionValueParameterContext); ok {
			tst[i] = t.(IFunctionValueParameterContext)
			i++
		}
	}

	return tst
}

func (s *FunctionValueParametersContext) FunctionValueParameter(i int) IFunctionValueParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionValueParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionValueParameterContext)
}

func (s *FunctionValueParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *FunctionValueParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *FunctionValueParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionValueParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionValueParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFunctionValueParameters(s)
	}
}

func (s *FunctionValueParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFunctionValueParameters(s)
	}
}

func (p *KotlinParser) FunctionValueParameters() (localctx IFunctionValueParametersContext) {
	localctx = NewFunctionValueParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, KotlinParserRULE_functionValueParameters)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(978)
		p.Match(KotlinParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(982)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 109, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(979)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(984)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 109, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1014)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-41)) & ^0x3f) == 0 && ((int64(1)<<(_la-41))&13668035483140101) != 0) || ((int64((_la-107)) & ^0x3f) == 0 && ((int64(1)<<(_la-107))&2200096997375) != 0) {
		{
			p.SetState(985)
			p.FunctionValueParameter()
		}
		p.SetState(1002)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 112, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(989)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == KotlinParserNL {
					{
						p.SetState(986)
						p.Match(KotlinParserNL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

					p.SetState(991)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(992)
					p.Match(KotlinParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(996)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == KotlinParserNL {
					{
						p.SetState(993)
						p.Match(KotlinParserNL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

					p.SetState(998)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(999)
					p.FunctionValueParameter()
				}

			}
			p.SetState(1004)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 112, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1012)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 114, p.GetParserRuleContext()) == 1 {
			p.SetState(1008)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1005)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(1010)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1011)
				p.Match(KotlinParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	p.SetState(1019)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1016)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1021)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1022)
		p.Match(KotlinParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionValueParameterContext is an interface to support dynamic dispatch.
type IFunctionValueParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Parameter() IParameterContext
	ParameterModifiers() IParameterModifiersContext
	ASSIGNMENT() antlr.TerminalNode
	Expression() IExpressionContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsFunctionValueParameterContext differentiates from other interfaces.
	IsFunctionValueParameterContext()
}

type FunctionValueParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionValueParameterContext() *FunctionValueParameterContext {
	var p = new(FunctionValueParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_functionValueParameter
	return p
}

func InitEmptyFunctionValueParameterContext(p *FunctionValueParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_functionValueParameter
}

func (*FunctionValueParameterContext) IsFunctionValueParameterContext() {}

func NewFunctionValueParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionValueParameterContext {
	var p = new(FunctionValueParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_functionValueParameter

	return p
}

func (s *FunctionValueParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionValueParameterContext) Parameter() IParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *FunctionValueParameterContext) ParameterModifiers() IParameterModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterModifiersContext)
}

func (s *FunctionValueParameterContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserASSIGNMENT, 0)
}

func (s *FunctionValueParameterContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionValueParameterContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *FunctionValueParameterContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *FunctionValueParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionValueParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionValueParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFunctionValueParameter(s)
	}
}

func (s *FunctionValueParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFunctionValueParameter(s)
	}
}

func (p *KotlinParser) FunctionValueParameter() (localctx IFunctionValueParameterContext) {
	localctx = NewFunctionValueParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, KotlinParserRULE_functionValueParameter)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1025)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 117, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1024)
			p.ParameterModifiers()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1027)
		p.Parameter()
	}
	p.SetState(1042)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 120, p.GetParserRuleContext()) == 1 {
		p.SetState(1031)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1028)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1033)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1034)
			p.Match(KotlinParserASSIGNMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1038)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 119, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1035)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(1040)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 119, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(1041)
			p.Expression()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionDeclarationContext is an interface to support dynamic dispatch.
type IFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FUN() antlr.TerminalNode
	SimpleIdentifier() ISimpleIdentifierContext
	FunctionValueParameters() IFunctionValueParametersContext
	Modifiers() IModifiersContext
	TypeParameters() ITypeParametersContext
	ReceiverType() IReceiverTypeContext
	DOT() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	COLON() antlr.TerminalNode
	Type_() ITypeContext
	TypeConstraints() ITypeConstraintsContext
	FunctionBody() IFunctionBodyContext

	// IsFunctionDeclarationContext differentiates from other interfaces.
	IsFunctionDeclarationContext()
}

type FunctionDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDeclarationContext() *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_functionDeclaration
	return p
}

func InitEmptyFunctionDeclarationContext(p *FunctionDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_functionDeclaration
}

func (*FunctionDeclarationContext) IsFunctionDeclarationContext() {}

func NewFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_functionDeclaration

	return p
}

func (s *FunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDeclarationContext) FUN() antlr.TerminalNode {
	return s.GetToken(KotlinParserFUN, 0)
}

func (s *FunctionDeclarationContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *FunctionDeclarationContext) FunctionValueParameters() IFunctionValueParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionValueParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionValueParametersContext)
}

func (s *FunctionDeclarationContext) Modifiers() IModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *FunctionDeclarationContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *FunctionDeclarationContext) ReceiverType() IReceiverTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiverTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiverTypeContext)
}

func (s *FunctionDeclarationContext) DOT() antlr.TerminalNode {
	return s.GetToken(KotlinParserDOT, 0)
}

func (s *FunctionDeclarationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *FunctionDeclarationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *FunctionDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *FunctionDeclarationContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *FunctionDeclarationContext) TypeConstraints() ITypeConstraintsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeConstraintsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeConstraintsContext)
}

func (s *FunctionDeclarationContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *FunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFunctionDeclaration(s)
	}
}

func (s *FunctionDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFunctionDeclaration(s)
	}
}

func (p *KotlinParser) FunctionDeclaration() (localctx IFunctionDeclarationContext) {
	localctx = NewFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, KotlinParserRULE_functionDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1045)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || ((int64((_la-109)) & ^0x3f) == 0 && ((int64(1)<<(_la-109))&234881023) != 0) {
		{
			p.SetState(1044)
			p.Modifiers()
		}

	}
	{
		p.SetState(1047)
		p.Match(KotlinParserFUN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1055)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 123, p.GetParserRuleContext()) == 1 {
		p.SetState(1051)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1048)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1053)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1054)
			p.TypeParameters()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1072)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext()) == 1 {
		p.SetState(1060)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1057)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1062)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1063)
			p.ReceiverType()
		}
		p.SetState(1067)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1064)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1069)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1070)
			p.Match(KotlinParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1077)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1074)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1079)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1080)
		p.SimpleIdentifier()
	}
	p.SetState(1084)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1081)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1086)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1087)
		p.FunctionValueParameters()
	}
	p.SetState(1102)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 131, p.GetParserRuleContext()) == 1 {
		p.SetState(1091)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1088)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1093)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1094)
			p.Match(KotlinParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1098)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1095)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1100)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1101)
			p.Type_()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1111)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 133, p.GetParserRuleContext()) == 1 {
		p.SetState(1107)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1104)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1109)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1110)
			p.TypeConstraints()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1120)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 135, p.GetParserRuleContext()) == 1 {
		p.SetState(1116)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1113)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1118)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1119)
			p.FunctionBody()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionBodyContext is an interface to support dynamic dispatch.
type IFunctionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext
	ASSIGNMENT() antlr.TerminalNode
	Expression() IExpressionContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsFunctionBodyContext differentiates from other interfaces.
	IsFunctionBodyContext()
}

type FunctionBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionBodyContext() *FunctionBodyContext {
	var p = new(FunctionBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_functionBody
	return p
}

func InitEmptyFunctionBodyContext(p *FunctionBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_functionBody
}

func (*FunctionBodyContext) IsFunctionBodyContext() {}

func NewFunctionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionBodyContext {
	var p = new(FunctionBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_functionBody

	return p
}

func (s *FunctionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionBodyContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FunctionBodyContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserASSIGNMENT, 0)
}

func (s *FunctionBodyContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionBodyContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *FunctionBodyContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *FunctionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFunctionBody(s)
	}
}

func (s *FunctionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFunctionBody(s)
	}
}

func (p *KotlinParser) FunctionBody() (localctx IFunctionBodyContext) {
	localctx = NewFunctionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, KotlinParserRULE_functionBody)
	var _alt int

	p.SetState(1131)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KotlinParserLCURL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1122)
			p.Block()
		}

	case KotlinParserASSIGNMENT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1123)
			p.Match(KotlinParserASSIGNMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1127)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 136, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1124)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(1129)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 136, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(1130)
			p.Expression()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclarationContext is an interface to support dynamic dispatch.
type IVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleIdentifier() ISimpleIdentifierContext
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	COLON() antlr.TerminalNode
	Type_() ITypeContext

	// IsVariableDeclarationContext differentiates from other interfaces.
	IsVariableDeclarationContext()
}

type VariableDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationContext() *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_variableDeclaration
	return p
}

func InitEmptyVariableDeclarationContext(p *VariableDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_variableDeclaration
}

func (*VariableDeclarationContext) IsVariableDeclarationContext() {}

func NewVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_variableDeclaration

	return p
}

func (s *VariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *VariableDeclarationContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *VariableDeclarationContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *VariableDeclarationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *VariableDeclarationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *VariableDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *VariableDeclarationContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *VariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitVariableDeclaration(s)
	}
}

func (p *KotlinParser) VariableDeclaration() (localctx IVariableDeclarationContext) {
	localctx = NewVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, KotlinParserRULE_variableDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1136)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS {
		{
			p.SetState(1133)
			p.Annotation()
		}

		p.SetState(1138)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1142)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1139)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1144)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1145)
		p.SimpleIdentifier()
	}
	p.SetState(1160)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 142, p.GetParserRuleContext()) == 1 {
		p.SetState(1149)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1146)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1151)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1152)
			p.Match(KotlinParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1156)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1153)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1158)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1159)
			p.Type_()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiVariableDeclarationContext is an interface to support dynamic dispatch.
type IMultiVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllVariableDeclaration() []IVariableDeclarationContext
	VariableDeclaration(i int) IVariableDeclarationContext
	RPAREN() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsMultiVariableDeclarationContext differentiates from other interfaces.
	IsMultiVariableDeclarationContext()
}

type MultiVariableDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiVariableDeclarationContext() *MultiVariableDeclarationContext {
	var p = new(MultiVariableDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_multiVariableDeclaration
	return p
}

func InitEmptyMultiVariableDeclarationContext(p *MultiVariableDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_multiVariableDeclaration
}

func (*MultiVariableDeclarationContext) IsMultiVariableDeclarationContext() {}

func NewMultiVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiVariableDeclarationContext {
	var p = new(MultiVariableDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_multiVariableDeclaration

	return p
}

func (s *MultiVariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiVariableDeclarationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *MultiVariableDeclarationContext) AllVariableDeclaration() []IVariableDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IVariableDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableDeclarationContext); ok {
			tst[i] = t.(IVariableDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *MultiVariableDeclarationContext) VariableDeclaration(i int) IVariableDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *MultiVariableDeclarationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *MultiVariableDeclarationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *MultiVariableDeclarationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *MultiVariableDeclarationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *MultiVariableDeclarationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *MultiVariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiVariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiVariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterMultiVariableDeclaration(s)
	}
}

func (s *MultiVariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitMultiVariableDeclaration(s)
	}
}

func (p *KotlinParser) MultiVariableDeclaration() (localctx IMultiVariableDeclarationContext) {
	localctx = NewMultiVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, KotlinParserRULE_multiVariableDeclaration)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1162)
		p.Match(KotlinParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1166)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 143, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1163)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1168)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 143, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(1169)
		p.VariableDeclaration()
	}
	p.SetState(1186)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 146, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1173)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1170)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(1175)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1176)
				p.Match(KotlinParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1180)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 145, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(1177)
						p.Match(KotlinParserNL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				p.SetState(1182)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 145, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			{
				p.SetState(1183)
				p.VariableDeclaration()
			}

		}
		p.SetState(1188)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 146, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1196)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 148, p.GetParserRuleContext()) == 1 {
		p.SetState(1192)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1189)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1194)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1195)
			p.Match(KotlinParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1201)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1198)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1203)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1204)
		p.Match(KotlinParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyDeclarationContext is an interface to support dynamic dispatch.
type IPropertyDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VAL() antlr.TerminalNode
	VAR() antlr.TerminalNode
	Modifiers() IModifiersContext
	TypeParameters() ITypeParametersContext
	ReceiverType() IReceiverTypeContext
	DOT() antlr.TerminalNode
	TypeConstraints() ITypeConstraintsContext
	SEMICOLON() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	MultiVariableDeclaration() IMultiVariableDeclarationContext
	VariableDeclaration() IVariableDeclarationContext
	ASSIGNMENT() antlr.TerminalNode
	Expression() IExpressionContext
	PropertyDelegate() IPropertyDelegateContext
	Getter() IGetterContext
	Setter() ISetterContext
	Semi() ISemiContext

	// IsPropertyDeclarationContext differentiates from other interfaces.
	IsPropertyDeclarationContext()
}

type PropertyDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyDeclarationContext() *PropertyDeclarationContext {
	var p = new(PropertyDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_propertyDeclaration
	return p
}

func InitEmptyPropertyDeclarationContext(p *PropertyDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_propertyDeclaration
}

func (*PropertyDeclarationContext) IsPropertyDeclarationContext() {}

func NewPropertyDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyDeclarationContext {
	var p = new(PropertyDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_propertyDeclaration

	return p
}

func (s *PropertyDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyDeclarationContext) VAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserVAL, 0)
}

func (s *PropertyDeclarationContext) VAR() antlr.TerminalNode {
	return s.GetToken(KotlinParserVAR, 0)
}

func (s *PropertyDeclarationContext) Modifiers() IModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *PropertyDeclarationContext) TypeParameters() ITypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *PropertyDeclarationContext) ReceiverType() IReceiverTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiverTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiverTypeContext)
}

func (s *PropertyDeclarationContext) DOT() antlr.TerminalNode {
	return s.GetToken(KotlinParserDOT, 0)
}

func (s *PropertyDeclarationContext) TypeConstraints() ITypeConstraintsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeConstraintsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeConstraintsContext)
}

func (s *PropertyDeclarationContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserSEMICOLON, 0)
}

func (s *PropertyDeclarationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *PropertyDeclarationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *PropertyDeclarationContext) MultiVariableDeclaration() IMultiVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiVariableDeclarationContext)
}

func (s *PropertyDeclarationContext) VariableDeclaration() IVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *PropertyDeclarationContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserASSIGNMENT, 0)
}

func (s *PropertyDeclarationContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PropertyDeclarationContext) PropertyDelegate() IPropertyDelegateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyDelegateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyDelegateContext)
}

func (s *PropertyDeclarationContext) Getter() IGetterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGetterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGetterContext)
}

func (s *PropertyDeclarationContext) Setter() ISetterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetterContext)
}

func (s *PropertyDeclarationContext) Semi() ISemiContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISemiContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISemiContext)
}

func (s *PropertyDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPropertyDeclaration(s)
	}
}

func (s *PropertyDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPropertyDeclaration(s)
	}
}

func (p *KotlinParser) PropertyDeclaration() (localctx IPropertyDeclarationContext) {
	localctx = NewPropertyDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, KotlinParserRULE_propertyDeclaration)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1207)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || ((int64((_la-109)) & ^0x3f) == 0 && ((int64(1)<<(_la-109))&234881023) != 0) {
		{
			p.SetState(1206)
			p.Modifiers()
		}

	}
	{
		p.SetState(1209)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserVAL || _la == KotlinParserVAR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1217)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 152, p.GetParserRuleContext()) == 1 {
		p.SetState(1213)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1210)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1215)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1216)
			p.TypeParameters()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1234)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 155, p.GetParserRuleContext()) == 1 {
		p.SetState(1222)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1219)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1224)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1225)
			p.ReceiverType()
		}
		p.SetState(1229)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1226)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1231)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1232)
			p.Match(KotlinParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

	p.SetState(1239)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 156, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1236)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1241)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 156, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1244)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KotlinParserLPAREN:
		{
			p.SetState(1242)
			p.MultiVariableDeclaration()
		}

	case KotlinParserNL, KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS, KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserIdentifier:
		{
			p.SetState(1243)
			p.VariableDeclaration()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

	p.SetState(1253)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 159, p.GetParserRuleContext()) == 1 {
		p.SetState(1249)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1246)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1251)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1252)
			p.TypeConstraints()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1272)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 163, p.GetParserRuleContext()) == 1 {
		p.SetState(1258)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1255)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1260)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1270)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case KotlinParserASSIGNMENT:
			{
				p.SetState(1261)
				p.Match(KotlinParserASSIGNMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1265)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 161, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(1262)
						p.Match(KotlinParserNL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				p.SetState(1267)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 161, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			{
				p.SetState(1268)
				p.Expression()
			}

		case KotlinParserBY:
			{
				p.SetState(1269)
				p.PropertyDelegate()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1281)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 165, p.GetParserRuleContext()) == 1 {
		p.SetState(1277)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1274)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1279)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1280)
			p.Match(KotlinParserSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1286)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 166, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1283)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1288)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 166, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1319)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 175, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1290)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 167, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1289)
				p.Getter()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1302)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 170, p.GetParserRuleContext()) == 1 {
			p.SetState(1295)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 168, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(1292)
						p.Match(KotlinParserNL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				p.SetState(1297)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 168, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			p.SetState(1299)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == KotlinParserNL || _la == KotlinParserSEMICOLON {
				{
					p.SetState(1298)
					p.Semi()
				}

			}
			{
				p.SetState(1301)
				p.Setter()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.SetState(1305)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 171, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1304)
				p.Setter()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1317)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 174, p.GetParserRuleContext()) == 1 {
			p.SetState(1310)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 172, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(1307)
						p.Match(KotlinParserNL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				p.SetState(1312)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 172, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			p.SetState(1314)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == KotlinParserNL || _la == KotlinParserSEMICOLON {
				{
					p.SetState(1313)
					p.Semi()
				}

			}
			{
				p.SetState(1316)
				p.Getter()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyDelegateContext is an interface to support dynamic dispatch.
type IPropertyDelegateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BY() antlr.TerminalNode
	Expression() IExpressionContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsPropertyDelegateContext differentiates from other interfaces.
	IsPropertyDelegateContext()
}

type PropertyDelegateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyDelegateContext() *PropertyDelegateContext {
	var p = new(PropertyDelegateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_propertyDelegate
	return p
}

func InitEmptyPropertyDelegateContext(p *PropertyDelegateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_propertyDelegate
}

func (*PropertyDelegateContext) IsPropertyDelegateContext() {}

func NewPropertyDelegateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyDelegateContext {
	var p = new(PropertyDelegateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_propertyDelegate

	return p
}

func (s *PropertyDelegateContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyDelegateContext) BY() antlr.TerminalNode {
	return s.GetToken(KotlinParserBY, 0)
}

func (s *PropertyDelegateContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PropertyDelegateContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *PropertyDelegateContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *PropertyDelegateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyDelegateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyDelegateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPropertyDelegate(s)
	}
}

func (s *PropertyDelegateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPropertyDelegate(s)
	}
}

func (p *KotlinParser) PropertyDelegate() (localctx IPropertyDelegateContext) {
	localctx = NewPropertyDelegateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, KotlinParserRULE_propertyDelegate)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1321)
		p.Match(KotlinParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1325)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 176, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1322)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1327)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 176, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(1328)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGetterContext is an interface to support dynamic dispatch.
type IGetterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GET() antlr.TerminalNode
	Modifiers() IModifiersContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	FunctionBody() IFunctionBodyContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	COLON() antlr.TerminalNode
	Type_() ITypeContext

	// IsGetterContext differentiates from other interfaces.
	IsGetterContext()
}

type GetterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGetterContext() *GetterContext {
	var p = new(GetterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_getter
	return p
}

func InitEmptyGetterContext(p *GetterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_getter
}

func (*GetterContext) IsGetterContext() {}

func NewGetterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GetterContext {
	var p = new(GetterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_getter

	return p
}

func (s *GetterContext) GetParser() antlr.Parser { return s.parser }

func (s *GetterContext) GET() antlr.TerminalNode {
	return s.GetToken(KotlinParserGET, 0)
}

func (s *GetterContext) Modifiers() IModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *GetterContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *GetterContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *GetterContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *GetterContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *GetterContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *GetterContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *GetterContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *GetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GetterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GetterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterGetter(s)
	}
}

func (s *GetterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitGetter(s)
	}
}

func (p *KotlinParser) Getter() (localctx IGetterContext) {
	localctx = NewGetterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, KotlinParserRULE_getter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1331)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || ((int64((_la-109)) & ^0x3f) == 0 && ((int64(1)<<(_la-109))&234881023) != 0) {
		{
			p.SetState(1330)
			p.Modifiers()
		}

	}
	{
		p.SetState(1333)
		p.Match(KotlinParserGET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1371)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 184, p.GetParserRuleContext()) == 1 {
		p.SetState(1337)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1334)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1339)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1340)
			p.Match(KotlinParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1344)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1341)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1346)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1347)
			p.Match(KotlinParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1362)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 182, p.GetParserRuleContext()) == 1 {
			p.SetState(1351)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1348)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(1353)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1354)
				p.Match(KotlinParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1358)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1355)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(1360)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1361)
				p.Type_()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1367)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1364)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1369)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1370)
			p.FunctionBody()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetterContext is an interface to support dynamic dispatch.
type ISetterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	Modifiers() IModifiersContext
	LPAREN() antlr.TerminalNode
	FunctionValueParameterWithOptionalType() IFunctionValueParameterWithOptionalTypeContext
	RPAREN() antlr.TerminalNode
	FunctionBody() IFunctionBodyContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	COMMA() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Type_() ITypeContext

	// IsSetterContext differentiates from other interfaces.
	IsSetterContext()
}

type SetterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetterContext() *SetterContext {
	var p = new(SetterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_setter
	return p
}

func InitEmptySetterContext(p *SetterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_setter
}

func (*SetterContext) IsSetterContext() {}

func NewSetterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetterContext {
	var p = new(SetterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_setter

	return p
}

func (s *SetterContext) GetParser() antlr.Parser { return s.parser }

func (s *SetterContext) SET() antlr.TerminalNode {
	return s.GetToken(KotlinParserSET, 0)
}

func (s *SetterContext) Modifiers() IModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *SetterContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *SetterContext) FunctionValueParameterWithOptionalType() IFunctionValueParameterWithOptionalTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionValueParameterWithOptionalTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionValueParameterWithOptionalTypeContext)
}

func (s *SetterContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *SetterContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *SetterContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *SetterContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *SetterContext) COMMA() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, 0)
}

func (s *SetterContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *SetterContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *SetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterSetter(s)
	}
}

func (s *SetterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitSetter(s)
	}
}

func (p *KotlinParser) Setter() (localctx ISetterContext) {
	localctx = NewSetterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, KotlinParserRULE_setter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1374)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || ((int64((_la-109)) & ^0x3f) == 0 && ((int64(1)<<(_la-109))&234881023) != 0) {
		{
			p.SetState(1373)
			p.Modifiers()
		}

	}
	{
		p.SetState(1376)
		p.Match(KotlinParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1431)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 195, p.GetParserRuleContext()) == 1 {
		p.SetState(1380)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1377)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1382)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1383)
			p.Match(KotlinParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1387)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1384)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1389)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1390)
			p.FunctionValueParameterWithOptionalType()
		}
		p.SetState(1398)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 189, p.GetParserRuleContext()) == 1 {
			p.SetState(1394)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1391)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(1396)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1397)
				p.Match(KotlinParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1403)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1400)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1405)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1406)
			p.Match(KotlinParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1421)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 193, p.GetParserRuleContext()) == 1 {
			p.SetState(1410)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1407)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(1412)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1413)
				p.Match(KotlinParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1417)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1414)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(1419)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1420)
				p.Type_()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1426)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1423)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1428)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1429)
			p.FunctionBody()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParametersWithOptionalTypeContext is an interface to support dynamic dispatch.
type IParametersWithOptionalTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	AllFunctionValueParameterWithOptionalType() []IFunctionValueParameterWithOptionalTypeContext
	FunctionValueParameterWithOptionalType(i int) IFunctionValueParameterWithOptionalTypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsParametersWithOptionalTypeContext differentiates from other interfaces.
	IsParametersWithOptionalTypeContext()
}

type ParametersWithOptionalTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParametersWithOptionalTypeContext() *ParametersWithOptionalTypeContext {
	var p = new(ParametersWithOptionalTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_parametersWithOptionalType
	return p
}

func InitEmptyParametersWithOptionalTypeContext(p *ParametersWithOptionalTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_parametersWithOptionalType
}

func (*ParametersWithOptionalTypeContext) IsParametersWithOptionalTypeContext() {}

func NewParametersWithOptionalTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParametersWithOptionalTypeContext {
	var p = new(ParametersWithOptionalTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_parametersWithOptionalType

	return p
}

func (s *ParametersWithOptionalTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ParametersWithOptionalTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *ParametersWithOptionalTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *ParametersWithOptionalTypeContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ParametersWithOptionalTypeContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ParametersWithOptionalTypeContext) AllFunctionValueParameterWithOptionalType() []IFunctionValueParameterWithOptionalTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionValueParameterWithOptionalTypeContext); ok {
			len++
		}
	}

	tst := make([]IFunctionValueParameterWithOptionalTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionValueParameterWithOptionalTypeContext); ok {
			tst[i] = t.(IFunctionValueParameterWithOptionalTypeContext)
			i++
		}
	}

	return tst
}

func (s *ParametersWithOptionalTypeContext) FunctionValueParameterWithOptionalType(i int) IFunctionValueParameterWithOptionalTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionValueParameterWithOptionalTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionValueParameterWithOptionalTypeContext)
}

func (s *ParametersWithOptionalTypeContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *ParametersWithOptionalTypeContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *ParametersWithOptionalTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParametersWithOptionalTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParametersWithOptionalTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterParametersWithOptionalType(s)
	}
}

func (s *ParametersWithOptionalTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitParametersWithOptionalType(s)
	}
}

func (p *KotlinParser) ParametersWithOptionalType() (localctx IParametersWithOptionalTypeContext) {
	localctx = NewParametersWithOptionalTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, KotlinParserRULE_parametersWithOptionalType)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1433)
		p.Match(KotlinParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1437)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 196, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1434)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1439)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 196, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1469)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-41)) & ^0x3f) == 0 && ((int64(1)<<(_la-41))&13668035483140101) != 0) || ((int64((_la-107)) & ^0x3f) == 0 && ((int64(1)<<(_la-107))&2200096997375) != 0) {
		{
			p.SetState(1440)
			p.FunctionValueParameterWithOptionalType()
		}
		p.SetState(1457)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 199, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(1444)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == KotlinParserNL {
					{
						p.SetState(1441)
						p.Match(KotlinParserNL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

					p.SetState(1446)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(1447)
					p.Match(KotlinParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(1451)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == KotlinParserNL {
					{
						p.SetState(1448)
						p.Match(KotlinParserNL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

					p.SetState(1453)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(1454)
					p.FunctionValueParameterWithOptionalType()
				}

			}
			p.SetState(1459)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 199, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1467)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 201, p.GetParserRuleContext()) == 1 {
			p.SetState(1463)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1460)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(1465)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1466)
				p.Match(KotlinParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	}
	p.SetState(1474)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1471)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1476)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1477)
		p.Match(KotlinParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionValueParameterWithOptionalTypeContext is an interface to support dynamic dispatch.
type IFunctionValueParameterWithOptionalTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParameterWithOptionalType() IParameterWithOptionalTypeContext
	ParameterModifiers() IParameterModifiersContext
	ASSIGNMENT() antlr.TerminalNode
	Expression() IExpressionContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsFunctionValueParameterWithOptionalTypeContext differentiates from other interfaces.
	IsFunctionValueParameterWithOptionalTypeContext()
}

type FunctionValueParameterWithOptionalTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionValueParameterWithOptionalTypeContext() *FunctionValueParameterWithOptionalTypeContext {
	var p = new(FunctionValueParameterWithOptionalTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_functionValueParameterWithOptionalType
	return p
}

func InitEmptyFunctionValueParameterWithOptionalTypeContext(p *FunctionValueParameterWithOptionalTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_functionValueParameterWithOptionalType
}

func (*FunctionValueParameterWithOptionalTypeContext) IsFunctionValueParameterWithOptionalTypeContext() {
}

func NewFunctionValueParameterWithOptionalTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionValueParameterWithOptionalTypeContext {
	var p = new(FunctionValueParameterWithOptionalTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_functionValueParameterWithOptionalType

	return p
}

func (s *FunctionValueParameterWithOptionalTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionValueParameterWithOptionalTypeContext) ParameterWithOptionalType() IParameterWithOptionalTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterWithOptionalTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterWithOptionalTypeContext)
}

func (s *FunctionValueParameterWithOptionalTypeContext) ParameterModifiers() IParameterModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterModifiersContext)
}

func (s *FunctionValueParameterWithOptionalTypeContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserASSIGNMENT, 0)
}

func (s *FunctionValueParameterWithOptionalTypeContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionValueParameterWithOptionalTypeContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *FunctionValueParameterWithOptionalTypeContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *FunctionValueParameterWithOptionalTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionValueParameterWithOptionalTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionValueParameterWithOptionalTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFunctionValueParameterWithOptionalType(s)
	}
}

func (s *FunctionValueParameterWithOptionalTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFunctionValueParameterWithOptionalType(s)
	}
}

func (p *KotlinParser) FunctionValueParameterWithOptionalType() (localctx IFunctionValueParameterWithOptionalTypeContext) {
	localctx = NewFunctionValueParameterWithOptionalTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, KotlinParserRULE_functionValueParameterWithOptionalType)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1480)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 204, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1479)
			p.ParameterModifiers()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1482)
		p.ParameterWithOptionalType()
	}
	p.SetState(1497)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 207, p.GetParserRuleContext()) == 1 {
		p.SetState(1486)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1483)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1488)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1489)
			p.Match(KotlinParserASSIGNMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1493)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 206, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1490)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(1495)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 206, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(1496)
			p.Expression()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterWithOptionalTypeContext is an interface to support dynamic dispatch.
type IParameterWithOptionalTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleIdentifier() ISimpleIdentifierContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	COLON() antlr.TerminalNode
	Type_() ITypeContext

	// IsParameterWithOptionalTypeContext differentiates from other interfaces.
	IsParameterWithOptionalTypeContext()
}

type ParameterWithOptionalTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterWithOptionalTypeContext() *ParameterWithOptionalTypeContext {
	var p = new(ParameterWithOptionalTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_parameterWithOptionalType
	return p
}

func InitEmptyParameterWithOptionalTypeContext(p *ParameterWithOptionalTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_parameterWithOptionalType
}

func (*ParameterWithOptionalTypeContext) IsParameterWithOptionalTypeContext() {}

func NewParameterWithOptionalTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterWithOptionalTypeContext {
	var p = new(ParameterWithOptionalTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_parameterWithOptionalType

	return p
}

func (s *ParameterWithOptionalTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterWithOptionalTypeContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *ParameterWithOptionalTypeContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ParameterWithOptionalTypeContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ParameterWithOptionalTypeContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *ParameterWithOptionalTypeContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ParameterWithOptionalTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterWithOptionalTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterWithOptionalTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterParameterWithOptionalType(s)
	}
}

func (s *ParameterWithOptionalTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitParameterWithOptionalType(s)
	}
}

func (p *KotlinParser) ParameterWithOptionalType() (localctx IParameterWithOptionalTypeContext) {
	localctx = NewParameterWithOptionalTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, KotlinParserRULE_parameterWithOptionalType)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1499)
		p.SimpleIdentifier()
	}
	p.SetState(1503)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 208, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1500)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1505)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 208, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1514)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserCOLON {
		{
			p.SetState(1506)
			p.Match(KotlinParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1510)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1507)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1512)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1513)
			p.Type_()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterContext is an interface to support dynamic dispatch.
type IParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleIdentifier() ISimpleIdentifierContext
	COLON() antlr.TerminalNode
	Type_() ITypeContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsParameterContext differentiates from other interfaces.
	IsParameterContext()
}

type ParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterContext() *ParameterContext {
	var p = new(ParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_parameter
	return p
}

func InitEmptyParameterContext(p *ParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_parameter
}

func (*ParameterContext) IsParameterContext() {}

func NewParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterContext {
	var p = new(ParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_parameter

	return p
}

func (s *ParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *ParameterContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *ParameterContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ParameterContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ParameterContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterParameter(s)
	}
}

func (s *ParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitParameter(s)
	}
}

func (p *KotlinParser) Parameter() (localctx IParameterContext) {
	localctx = NewParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, KotlinParserRULE_parameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1516)
		p.SimpleIdentifier()
	}
	p.SetState(1520)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1517)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1522)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1523)
		p.Match(KotlinParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1527)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1524)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1529)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1530)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectDeclarationContext is an interface to support dynamic dispatch.
type IObjectDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT() antlr.TerminalNode
	SimpleIdentifier() ISimpleIdentifierContext
	Modifiers() IModifiersContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	COLON() antlr.TerminalNode
	DelegationSpecifiers() IDelegationSpecifiersContext
	ClassBody() IClassBodyContext

	// IsObjectDeclarationContext differentiates from other interfaces.
	IsObjectDeclarationContext()
}

type ObjectDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectDeclarationContext() *ObjectDeclarationContext {
	var p = new(ObjectDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_objectDeclaration
	return p
}

func InitEmptyObjectDeclarationContext(p *ObjectDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_objectDeclaration
}

func (*ObjectDeclarationContext) IsObjectDeclarationContext() {}

func NewObjectDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectDeclarationContext {
	var p = new(ObjectDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_objectDeclaration

	return p
}

func (s *ObjectDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectDeclarationContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(KotlinParserOBJECT, 0)
}

func (s *ObjectDeclarationContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *ObjectDeclarationContext) Modifiers() IModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *ObjectDeclarationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ObjectDeclarationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ObjectDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *ObjectDeclarationContext) DelegationSpecifiers() IDelegationSpecifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelegationSpecifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelegationSpecifiersContext)
}

func (s *ObjectDeclarationContext) ClassBody() IClassBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *ObjectDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterObjectDeclaration(s)
	}
}

func (s *ObjectDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitObjectDeclaration(s)
	}
}

func (p *KotlinParser) ObjectDeclaration() (localctx IObjectDeclarationContext) {
	localctx = NewObjectDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, KotlinParserRULE_objectDeclaration)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1533)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || ((int64((_la-109)) & ^0x3f) == 0 && ((int64(1)<<(_la-109))&234881023) != 0) {
		{
			p.SetState(1532)
			p.Modifiers()
		}

	}
	{
		p.SetState(1535)
		p.Match(KotlinParserOBJECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1539)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1536)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1541)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1542)
		p.SimpleIdentifier()
	}
	p.SetState(1557)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 217, p.GetParserRuleContext()) == 1 {
		p.SetState(1546)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1543)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1548)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1549)
			p.Match(KotlinParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1553)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 216, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1550)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(1555)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 216, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(1556)
			p.DelegationSpecifiers()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1566)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 219, p.GetParserRuleContext()) == 1 {
		p.SetState(1562)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1559)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1564)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1565)
			p.ClassBody()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISecondaryConstructorContext is an interface to support dynamic dispatch.
type ISecondaryConstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONSTRUCTOR() antlr.TerminalNode
	FunctionValueParameters() IFunctionValueParametersContext
	Modifiers() IModifiersContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	COLON() antlr.TerminalNode
	ConstructorDelegationCall() IConstructorDelegationCallContext
	Block() IBlockContext

	// IsSecondaryConstructorContext differentiates from other interfaces.
	IsSecondaryConstructorContext()
}

type SecondaryConstructorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySecondaryConstructorContext() *SecondaryConstructorContext {
	var p = new(SecondaryConstructorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_secondaryConstructor
	return p
}

func InitEmptySecondaryConstructorContext(p *SecondaryConstructorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_secondaryConstructor
}

func (*SecondaryConstructorContext) IsSecondaryConstructorContext() {}

func NewSecondaryConstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SecondaryConstructorContext {
	var p = new(SecondaryConstructorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_secondaryConstructor

	return p
}

func (s *SecondaryConstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *SecondaryConstructorContext) CONSTRUCTOR() antlr.TerminalNode {
	return s.GetToken(KotlinParserCONSTRUCTOR, 0)
}

func (s *SecondaryConstructorContext) FunctionValueParameters() IFunctionValueParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionValueParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionValueParametersContext)
}

func (s *SecondaryConstructorContext) Modifiers() IModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *SecondaryConstructorContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *SecondaryConstructorContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *SecondaryConstructorContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *SecondaryConstructorContext) ConstructorDelegationCall() IConstructorDelegationCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstructorDelegationCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstructorDelegationCallContext)
}

func (s *SecondaryConstructorContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *SecondaryConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SecondaryConstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SecondaryConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterSecondaryConstructor(s)
	}
}

func (s *SecondaryConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitSecondaryConstructor(s)
	}
}

func (p *KotlinParser) SecondaryConstructor() (localctx ISecondaryConstructorContext) {
	localctx = NewSecondaryConstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, KotlinParserRULE_secondaryConstructor)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1569)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS || ((int64((_la-109)) & ^0x3f) == 0 && ((int64(1)<<(_la-109))&234881023) != 0) {
		{
			p.SetState(1568)
			p.Modifiers()
		}

	}
	{
		p.SetState(1571)
		p.Match(KotlinParserCONSTRUCTOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1575)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1572)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1577)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1578)
		p.FunctionValueParameters()
	}
	p.SetState(1593)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 224, p.GetParserRuleContext()) == 1 {
		p.SetState(1582)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1579)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1584)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1585)
			p.Match(KotlinParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1589)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1586)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1591)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1592)
			p.ConstructorDelegationCall()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1598)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 225, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1595)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1600)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 225, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1602)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserLCURL {
		{
			p.SetState(1601)
			p.Block()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstructorDelegationCallContext is an interface to support dynamic dispatch.
type IConstructorDelegationCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ValueArguments() IValueArgumentsContext
	THIS() antlr.TerminalNode
	SUPER() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsConstructorDelegationCallContext differentiates from other interfaces.
	IsConstructorDelegationCallContext()
}

type ConstructorDelegationCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructorDelegationCallContext() *ConstructorDelegationCallContext {
	var p = new(ConstructorDelegationCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_constructorDelegationCall
	return p
}

func InitEmptyConstructorDelegationCallContext(p *ConstructorDelegationCallContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_constructorDelegationCall
}

func (*ConstructorDelegationCallContext) IsConstructorDelegationCallContext() {}

func NewConstructorDelegationCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstructorDelegationCallContext {
	var p = new(ConstructorDelegationCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_constructorDelegationCall

	return p
}

func (s *ConstructorDelegationCallContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstructorDelegationCallContext) ValueArguments() IValueArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueArgumentsContext)
}

func (s *ConstructorDelegationCallContext) THIS() antlr.TerminalNode {
	return s.GetToken(KotlinParserTHIS, 0)
}

func (s *ConstructorDelegationCallContext) SUPER() antlr.TerminalNode {
	return s.GetToken(KotlinParserSUPER, 0)
}

func (s *ConstructorDelegationCallContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ConstructorDelegationCallContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ConstructorDelegationCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstructorDelegationCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstructorDelegationCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterConstructorDelegationCall(s)
	}
}

func (s *ConstructorDelegationCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitConstructorDelegationCall(s)
	}
}

func (p *KotlinParser) ConstructorDelegationCall() (localctx IConstructorDelegationCallContext) {
	localctx = NewConstructorDelegationCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, KotlinParserRULE_constructorDelegationCall)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1604)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserTHIS || _la == KotlinParserSUPER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1608)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1605)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1610)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1611)
		p.ValueArguments()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumClassBodyContext is an interface to support dynamic dispatch.
type IEnumClassBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LCURL() antlr.TerminalNode
	RCURL() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	EnumEntries() IEnumEntriesContext
	SEMICOLON() antlr.TerminalNode
	ClassMemberDeclarations() IClassMemberDeclarationsContext

	// IsEnumClassBodyContext differentiates from other interfaces.
	IsEnumClassBodyContext()
}

type EnumClassBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumClassBodyContext() *EnumClassBodyContext {
	var p = new(EnumClassBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_enumClassBody
	return p
}

func InitEmptyEnumClassBodyContext(p *EnumClassBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_enumClassBody
}

func (*EnumClassBodyContext) IsEnumClassBodyContext() {}

func NewEnumClassBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumClassBodyContext {
	var p = new(EnumClassBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_enumClassBody

	return p
}

func (s *EnumClassBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumClassBodyContext) LCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserLCURL, 0)
}

func (s *EnumClassBodyContext) RCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserRCURL, 0)
}

func (s *EnumClassBodyContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *EnumClassBodyContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *EnumClassBodyContext) EnumEntries() IEnumEntriesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumEntriesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumEntriesContext)
}

func (s *EnumClassBodyContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserSEMICOLON, 0)
}

func (s *EnumClassBodyContext) ClassMemberDeclarations() IClassMemberDeclarationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassMemberDeclarationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassMemberDeclarationsContext)
}

func (s *EnumClassBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumClassBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumClassBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterEnumClassBody(s)
	}
}

func (s *EnumClassBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitEnumClassBody(s)
	}
}

func (p *KotlinParser) EnumClassBody() (localctx IEnumClassBodyContext) {
	localctx = NewEnumClassBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, KotlinParserRULE_enumClassBody)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1613)
		p.Match(KotlinParserLCURL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1617)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 228, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1614)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1619)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 228, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1621)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-41)) & ^0x3f) == 0 && ((int64(1)<<(_la-41))&13668035483140101) != 0) || ((int64((_la-107)) & ^0x3f) == 0 && ((int64(1)<<(_la-107))&2200096997375) != 0) {
		{
			p.SetState(1620)
			p.EnumEntries()
		}

	}
	p.SetState(1637)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 232, p.GetParserRuleContext()) == 1 {
		p.SetState(1626)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1623)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1628)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1629)
			p.Match(KotlinParserSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1633)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 231, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1630)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(1635)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 231, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(1636)
			p.ClassMemberDeclarations()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1642)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1639)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1644)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1645)
		p.Match(KotlinParserRCURL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumEntriesContext is an interface to support dynamic dispatch.
type IEnumEntriesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllEnumEntry() []IEnumEntryContext
	EnumEntry(i int) IEnumEntryContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsEnumEntriesContext differentiates from other interfaces.
	IsEnumEntriesContext()
}

type EnumEntriesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumEntriesContext() *EnumEntriesContext {
	var p = new(EnumEntriesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_enumEntries
	return p
}

func InitEmptyEnumEntriesContext(p *EnumEntriesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_enumEntries
}

func (*EnumEntriesContext) IsEnumEntriesContext() {}

func NewEnumEntriesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumEntriesContext {
	var p = new(EnumEntriesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_enumEntries

	return p
}

func (s *EnumEntriesContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumEntriesContext) AllEnumEntry() []IEnumEntryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumEntryContext); ok {
			len++
		}
	}

	tst := make([]IEnumEntryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumEntryContext); ok {
			tst[i] = t.(IEnumEntryContext)
			i++
		}
	}

	return tst
}

func (s *EnumEntriesContext) EnumEntry(i int) IEnumEntryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumEntryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumEntryContext)
}

func (s *EnumEntriesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *EnumEntriesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *EnumEntriesContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *EnumEntriesContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *EnumEntriesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumEntriesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumEntriesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterEnumEntries(s)
	}
}

func (s *EnumEntriesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitEnumEntries(s)
	}
}

func (p *KotlinParser) EnumEntries() (localctx IEnumEntriesContext) {
	localctx = NewEnumEntriesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, KotlinParserRULE_enumEntries)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1647)
		p.EnumEntry()
	}
	p.SetState(1664)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 236, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1651)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1648)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(1653)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1654)
				p.Match(KotlinParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1658)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1655)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(1660)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1661)
				p.EnumEntry()
			}

		}
		p.SetState(1666)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 236, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1670)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 237, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1667)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1672)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 237, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1674)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserCOMMA {
		{
			p.SetState(1673)
			p.Match(KotlinParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumEntryContext is an interface to support dynamic dispatch.
type IEnumEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleIdentifier() ISimpleIdentifierContext
	Modifiers() IModifiersContext
	ValueArguments() IValueArgumentsContext
	ClassBody() IClassBodyContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsEnumEntryContext differentiates from other interfaces.
	IsEnumEntryContext()
}

type EnumEntryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumEntryContext() *EnumEntryContext {
	var p = new(EnumEntryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_enumEntry
	return p
}

func InitEmptyEnumEntryContext(p *EnumEntryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_enumEntry
}

func (*EnumEntryContext) IsEnumEntryContext() {}

func NewEnumEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumEntryContext {
	var p = new(EnumEntryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_enumEntry

	return p
}

func (s *EnumEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumEntryContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *EnumEntryContext) Modifiers() IModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *EnumEntryContext) ValueArguments() IValueArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueArgumentsContext)
}

func (s *EnumEntryContext) ClassBody() IClassBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *EnumEntryContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *EnumEntryContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *EnumEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterEnumEntry(s)
	}
}

func (s *EnumEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitEnumEntry(s)
	}
}

func (p *KotlinParser) EnumEntry() (localctx IEnumEntryContext) {
	localctx = NewEnumEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, KotlinParserRULE_enumEntry)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1683)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 240, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1676)
			p.Modifiers()
		}
		p.SetState(1680)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1677)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1682)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1685)
		p.SimpleIdentifier()
	}
	p.SetState(1693)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 242, p.GetParserRuleContext()) == 1 {
		p.SetState(1689)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1686)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1691)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1692)
			p.ValueArguments()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1702)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 244, p.GetParserRuleContext()) == 1 {
		p.SetState(1698)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1695)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1700)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1701)
			p.ClassBody()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeContext is an interface to support dynamic dispatch.
type ITypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionType() IFunctionTypeContext
	ParenthesizedType() IParenthesizedTypeContext
	NullableType() INullableTypeContext
	TypeReference() ITypeReferenceContext
	DefinitelyNonNullableType() IDefinitelyNonNullableTypeContext
	TypeModifiers() ITypeModifiersContext

	// IsTypeContext differentiates from other interfaces.
	IsTypeContext()
}

type TypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeContext() *TypeContext {
	var p = new(TypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_type
	return p
}

func InitEmptyTypeContext(p *TypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_type
}

func (*TypeContext) IsTypeContext() {}

func NewTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeContext {
	var p = new(TypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_type

	return p
}

func (s *TypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeContext) FunctionType() IFunctionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeContext)
}

func (s *TypeContext) ParenthesizedType() IParenthesizedTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesizedTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesizedTypeContext)
}

func (s *TypeContext) NullableType() INullableTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullableTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullableTypeContext)
}

func (s *TypeContext) TypeReference() ITypeReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeReferenceContext)
}

func (s *TypeContext) DefinitelyNonNullableType() IDefinitelyNonNullableTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitelyNonNullableTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitelyNonNullableTypeContext)
}

func (s *TypeContext) TypeModifiers() ITypeModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeModifiersContext)
}

func (s *TypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterType(s)
	}
}

func (s *TypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitType(s)
	}
}

func (p *KotlinParser) Type_() (localctx ITypeContext) {
	localctx = NewTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, KotlinParserRULE_type)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1705)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 245, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1704)
			p.TypeModifiers()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1712)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 246, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1707)
			p.FunctionType()
		}

	case 2:
		{
			p.SetState(1708)
			p.ParenthesizedType()
		}

	case 3:
		{
			p.SetState(1709)
			p.NullableType()
		}

	case 4:
		{
			p.SetState(1710)
			p.TypeReference()
		}

	case 5:
		{
			p.SetState(1711)
			p.DefinitelyNonNullableType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeReferenceContext is an interface to support dynamic dispatch.
type ITypeReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UserType() IUserTypeContext
	DYNAMIC() antlr.TerminalNode

	// IsTypeReferenceContext differentiates from other interfaces.
	IsTypeReferenceContext()
}

type TypeReferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeReferenceContext() *TypeReferenceContext {
	var p = new(TypeReferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_typeReference
	return p
}

func InitEmptyTypeReferenceContext(p *TypeReferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_typeReference
}

func (*TypeReferenceContext) IsTypeReferenceContext() {}

func NewTypeReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeReferenceContext {
	var p = new(TypeReferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeReference

	return p
}

func (s *TypeReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeReferenceContext) UserType() IUserTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserTypeContext)
}

func (s *TypeReferenceContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(KotlinParserDYNAMIC, 0)
}

func (s *TypeReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeReference(s)
	}
}

func (s *TypeReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeReference(s)
	}
}

func (p *KotlinParser) TypeReference() (localctx ITypeReferenceContext) {
	localctx = NewTypeReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, KotlinParserRULE_typeReference)
	p.SetState(1716)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 247, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1714)
			p.UserType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1715)
			p.Match(KotlinParserDYNAMIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INullableTypeContext is an interface to support dynamic dispatch.
type INullableTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeReference() ITypeReferenceContext
	ParenthesizedType() IParenthesizedTypeContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	AllQuest() []IQuestContext
	Quest(i int) IQuestContext

	// IsNullableTypeContext differentiates from other interfaces.
	IsNullableTypeContext()
}

type NullableTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullableTypeContext() *NullableTypeContext {
	var p = new(NullableTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_nullableType
	return p
}

func InitEmptyNullableTypeContext(p *NullableTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_nullableType
}

func (*NullableTypeContext) IsNullableTypeContext() {}

func NewNullableTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullableTypeContext {
	var p = new(NullableTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_nullableType

	return p
}

func (s *NullableTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *NullableTypeContext) TypeReference() ITypeReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeReferenceContext)
}

func (s *NullableTypeContext) ParenthesizedType() IParenthesizedTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesizedTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesizedTypeContext)
}

func (s *NullableTypeContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *NullableTypeContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *NullableTypeContext) AllQuest() []IQuestContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQuestContext); ok {
			len++
		}
	}

	tst := make([]IQuestContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQuestContext); ok {
			tst[i] = t.(IQuestContext)
			i++
		}
	}

	return tst
}

func (s *NullableTypeContext) Quest(i int) IQuestContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuestContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuestContext)
}

func (s *NullableTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullableTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullableTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterNullableType(s)
	}
}

func (s *NullableTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitNullableType(s)
	}
}

func (p *KotlinParser) NullableType() (localctx INullableTypeContext) {
	localctx = NewNullableTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, KotlinParserRULE_nullableType)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1720)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserIdentifier:
		{
			p.SetState(1718)
			p.TypeReference()
		}

	case KotlinParserLPAREN:
		{
			p.SetState(1719)
			p.ParenthesizedType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(1725)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1722)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1727)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1729)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1728)
				p.Quest()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1731)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 250, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuestContext is an interface to support dynamic dispatch.
type IQuestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QUEST_NO_WS() antlr.TerminalNode
	QUEST_WS() antlr.TerminalNode

	// IsQuestContext differentiates from other interfaces.
	IsQuestContext()
}

type QuestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuestContext() *QuestContext {
	var p = new(QuestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_quest
	return p
}

func InitEmptyQuestContext(p *QuestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_quest
}

func (*QuestContext) IsQuestContext() {}

func NewQuestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuestContext {
	var p = new(QuestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_quest

	return p
}

func (s *QuestContext) GetParser() antlr.Parser { return s.parser }

func (s *QuestContext) QUEST_NO_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserQUEST_NO_WS, 0)
}

func (s *QuestContext) QUEST_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserQUEST_WS, 0)
}

func (s *QuestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterQuest(s)
	}
}

func (s *QuestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitQuest(s)
	}
}

func (p *KotlinParser) Quest() (localctx IQuestContext) {
	localctx = NewQuestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, KotlinParserRULE_quest)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1733)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserQUEST_WS || _la == KotlinParserQUEST_NO_WS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserTypeContext is an interface to support dynamic dispatch.
type IUserTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSimpleUserType() []ISimpleUserTypeContext
	SimpleUserType(i int) ISimpleUserTypeContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsUserTypeContext differentiates from other interfaces.
	IsUserTypeContext()
}

type UserTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserTypeContext() *UserTypeContext {
	var p = new(UserTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_userType
	return p
}

func InitEmptyUserTypeContext(p *UserTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_userType
}

func (*UserTypeContext) IsUserTypeContext() {}

func NewUserTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserTypeContext {
	var p = new(UserTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_userType

	return p
}

func (s *UserTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *UserTypeContext) AllSimpleUserType() []ISimpleUserTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimpleUserTypeContext); ok {
			len++
		}
	}

	tst := make([]ISimpleUserTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimpleUserTypeContext); ok {
			tst[i] = t.(ISimpleUserTypeContext)
			i++
		}
	}

	return tst
}

func (s *UserTypeContext) SimpleUserType(i int) ISimpleUserTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleUserTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleUserTypeContext)
}

func (s *UserTypeContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserDOT)
}

func (s *UserTypeContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserDOT, i)
}

func (s *UserTypeContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *UserTypeContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *UserTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterUserType(s)
	}
}

func (s *UserTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitUserType(s)
	}
}

func (p *KotlinParser) UserType() (localctx IUserTypeContext) {
	localctx = NewUserTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, KotlinParserRULE_userType)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1735)
		p.SimpleUserType()
	}
	p.SetState(1752)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 253, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1739)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1736)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(1741)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1742)
				p.Match(KotlinParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1746)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1743)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(1748)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1749)
				p.SimpleUserType()
			}

		}
		p.SetState(1754)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 253, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleUserTypeContext is an interface to support dynamic dispatch.
type ISimpleUserTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleIdentifier() ISimpleIdentifierContext
	TypeArguments() ITypeArgumentsContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsSimpleUserTypeContext differentiates from other interfaces.
	IsSimpleUserTypeContext()
}

type SimpleUserTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleUserTypeContext() *SimpleUserTypeContext {
	var p = new(SimpleUserTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_simpleUserType
	return p
}

func InitEmptySimpleUserTypeContext(p *SimpleUserTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_simpleUserType
}

func (*SimpleUserTypeContext) IsSimpleUserTypeContext() {}

func NewSimpleUserTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleUserTypeContext {
	var p = new(SimpleUserTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_simpleUserType

	return p
}

func (s *SimpleUserTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleUserTypeContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *SimpleUserTypeContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *SimpleUserTypeContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *SimpleUserTypeContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *SimpleUserTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleUserTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleUserTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterSimpleUserType(s)
	}
}

func (s *SimpleUserTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitSimpleUserType(s)
	}
}

func (p *KotlinParser) SimpleUserType() (localctx ISimpleUserTypeContext) {
	localctx = NewSimpleUserTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, KotlinParserRULE_simpleUserType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1755)
		p.SimpleIdentifier()
	}
	p.SetState(1763)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 255, p.GetParserRuleContext()) == 1 {
		p.SetState(1759)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1756)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1761)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1762)
			p.TypeArguments()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeProjectionContext is an interface to support dynamic dispatch.
type ITypeProjectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() ITypeContext
	TypeProjectionModifiers() ITypeProjectionModifiersContext
	MULT() antlr.TerminalNode

	// IsTypeProjectionContext differentiates from other interfaces.
	IsTypeProjectionContext()
}

type TypeProjectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeProjectionContext() *TypeProjectionContext {
	var p = new(TypeProjectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_typeProjection
	return p
}

func InitEmptyTypeProjectionContext(p *TypeProjectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_typeProjection
}

func (*TypeProjectionContext) IsTypeProjectionContext() {}

func NewTypeProjectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeProjectionContext {
	var p = new(TypeProjectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeProjection

	return p
}

func (s *TypeProjectionContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeProjectionContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypeProjectionContext) TypeProjectionModifiers() ITypeProjectionModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeProjectionModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeProjectionModifiersContext)
}

func (s *TypeProjectionContext) MULT() antlr.TerminalNode {
	return s.GetToken(KotlinParserMULT, 0)
}

func (s *TypeProjectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeProjectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeProjectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeProjection(s)
	}
}

func (s *TypeProjectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeProjection(s)
	}
}

func (p *KotlinParser) TypeProjection() (localctx ITypeProjectionContext) {
	localctx = NewTypeProjectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, KotlinParserRULE_typeProjection)
	p.SetState(1770)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KotlinParserLPAREN, KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS, KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserIN, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1766)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 256, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1765)
				p.TypeProjectionModifiers()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1768)
			p.Type_()
		}

	case KotlinParserMULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1769)
			p.Match(KotlinParserMULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeProjectionModifiersContext is an interface to support dynamic dispatch.
type ITypeProjectionModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTypeProjectionModifier() []ITypeProjectionModifierContext
	TypeProjectionModifier(i int) ITypeProjectionModifierContext

	// IsTypeProjectionModifiersContext differentiates from other interfaces.
	IsTypeProjectionModifiersContext()
}

type TypeProjectionModifiersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeProjectionModifiersContext() *TypeProjectionModifiersContext {
	var p = new(TypeProjectionModifiersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_typeProjectionModifiers
	return p
}

func InitEmptyTypeProjectionModifiersContext(p *TypeProjectionModifiersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_typeProjectionModifiers
}

func (*TypeProjectionModifiersContext) IsTypeProjectionModifiersContext() {}

func NewTypeProjectionModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeProjectionModifiersContext {
	var p = new(TypeProjectionModifiersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeProjectionModifiers

	return p
}

func (s *TypeProjectionModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeProjectionModifiersContext) AllTypeProjectionModifier() []ITypeProjectionModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeProjectionModifierContext); ok {
			len++
		}
	}

	tst := make([]ITypeProjectionModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeProjectionModifierContext); ok {
			tst[i] = t.(ITypeProjectionModifierContext)
			i++
		}
	}

	return tst
}

func (s *TypeProjectionModifiersContext) TypeProjectionModifier(i int) ITypeProjectionModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeProjectionModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeProjectionModifierContext)
}

func (s *TypeProjectionModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeProjectionModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeProjectionModifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeProjectionModifiers(s)
	}
}

func (s *TypeProjectionModifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeProjectionModifiers(s)
	}
}

func (p *KotlinParser) TypeProjectionModifiers() (localctx ITypeProjectionModifiersContext) {
	localctx = NewTypeProjectionModifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, KotlinParserRULE_typeProjectionModifiers)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1773)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1772)
				p.TypeProjectionModifier()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1775)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 258, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeProjectionModifierContext is an interface to support dynamic dispatch.
type ITypeProjectionModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VarianceModifier() IVarianceModifierContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	Annotation() IAnnotationContext

	// IsTypeProjectionModifierContext differentiates from other interfaces.
	IsTypeProjectionModifierContext()
}

type TypeProjectionModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeProjectionModifierContext() *TypeProjectionModifierContext {
	var p = new(TypeProjectionModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_typeProjectionModifier
	return p
}

func InitEmptyTypeProjectionModifierContext(p *TypeProjectionModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_typeProjectionModifier
}

func (*TypeProjectionModifierContext) IsTypeProjectionModifierContext() {}

func NewTypeProjectionModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeProjectionModifierContext {
	var p = new(TypeProjectionModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeProjectionModifier

	return p
}

func (s *TypeProjectionModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeProjectionModifierContext) VarianceModifier() IVarianceModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarianceModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarianceModifierContext)
}

func (s *TypeProjectionModifierContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeProjectionModifierContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeProjectionModifierContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *TypeProjectionModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeProjectionModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeProjectionModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeProjectionModifier(s)
	}
}

func (s *TypeProjectionModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeProjectionModifier(s)
	}
}

func (p *KotlinParser) TypeProjectionModifier() (localctx ITypeProjectionModifierContext) {
	localctx = NewTypeProjectionModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, KotlinParserRULE_typeProjectionModifier)
	var _la int

	p.SetState(1785)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KotlinParserIN, KotlinParserOUT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1777)
			p.VarianceModifier()
		}
		p.SetState(1781)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1778)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1783)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1784)
			p.Annotation()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionTypeContext is an interface to support dynamic dispatch.
type IFunctionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionTypeParameters() IFunctionTypeParametersContext
	ARROW() antlr.TerminalNode
	Type_() ITypeContext
	ReceiverType() IReceiverTypeContext
	DOT() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsFunctionTypeContext differentiates from other interfaces.
	IsFunctionTypeContext()
}

type FunctionTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTypeContext() *FunctionTypeContext {
	var p = new(FunctionTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_functionType
	return p
}

func InitEmptyFunctionTypeContext(p *FunctionTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_functionType
}

func (*FunctionTypeContext) IsFunctionTypeContext() {}

func NewFunctionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTypeContext {
	var p = new(FunctionTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_functionType

	return p
}

func (s *FunctionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTypeContext) FunctionTypeParameters() IFunctionTypeParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTypeParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeParametersContext)
}

func (s *FunctionTypeContext) ARROW() antlr.TerminalNode {
	return s.GetToken(KotlinParserARROW, 0)
}

func (s *FunctionTypeContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *FunctionTypeContext) ReceiverType() IReceiverTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiverTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiverTypeContext)
}

func (s *FunctionTypeContext) DOT() antlr.TerminalNode {
	return s.GetToken(KotlinParserDOT, 0)
}

func (s *FunctionTypeContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *FunctionTypeContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *FunctionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFunctionType(s)
	}
}

func (s *FunctionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFunctionType(s)
	}
}

func (p *KotlinParser) FunctionType() (localctx IFunctionTypeContext) {
	localctx = NewFunctionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, KotlinParserRULE_functionType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1801)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 263, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1787)
			p.ReceiverType()
		}
		p.SetState(1791)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1788)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1793)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1794)
			p.Match(KotlinParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1798)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1795)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1800)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1803)
		p.FunctionTypeParameters()
	}
	p.SetState(1807)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1804)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1809)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1810)
		p.Match(KotlinParserARROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1814)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1811)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1816)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1817)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionTypeParametersContext is an interface to support dynamic dispatch.
type IFunctionTypeParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	AllParameter() []IParameterContext
	Parameter(i int) IParameterContext
	AllType_() []ITypeContext
	Type_(i int) ITypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFunctionTypeParametersContext differentiates from other interfaces.
	IsFunctionTypeParametersContext()
}

type FunctionTypeParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTypeParametersContext() *FunctionTypeParametersContext {
	var p = new(FunctionTypeParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_functionTypeParameters
	return p
}

func InitEmptyFunctionTypeParametersContext(p *FunctionTypeParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_functionTypeParameters
}

func (*FunctionTypeParametersContext) IsFunctionTypeParametersContext() {}

func NewFunctionTypeParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTypeParametersContext {
	var p = new(FunctionTypeParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_functionTypeParameters

	return p
}

func (s *FunctionTypeParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTypeParametersContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *FunctionTypeParametersContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *FunctionTypeParametersContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *FunctionTypeParametersContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *FunctionTypeParametersContext) AllParameter() []IParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParameterContext); ok {
			len++
		}
	}

	tst := make([]IParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParameterContext); ok {
			tst[i] = t.(IParameterContext)
			i++
		}
	}

	return tst
}

func (s *FunctionTypeParametersContext) Parameter(i int) IParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *FunctionTypeParametersContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *FunctionTypeParametersContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *FunctionTypeParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *FunctionTypeParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *FunctionTypeParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTypeParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTypeParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFunctionTypeParameters(s)
	}
}

func (s *FunctionTypeParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFunctionTypeParameters(s)
	}
}

func (p *KotlinParser) FunctionTypeParameters() (localctx IFunctionTypeParametersContext) {
	localctx = NewFunctionTypeParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, KotlinParserRULE_functionTypeParameters)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1819)
		p.Match(KotlinParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1823)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 266, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1820)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1825)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 266, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1828)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 267, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1826)
			p.Parameter()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 267, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(1827)
			p.Type_()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1849)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 271, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1833)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1830)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(1835)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1836)
				p.Match(KotlinParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1840)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(1837)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(1842)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			p.SetState(1845)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 270, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(1843)
					p.Parameter()
				}

			case 2:
				{
					p.SetState(1844)
					p.Type_()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1851)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 271, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1859)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 273, p.GetParserRuleContext()) == 1 {
		p.SetState(1855)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(1852)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1857)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1858)
			p.Match(KotlinParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1864)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1861)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1866)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1867)
		p.Match(KotlinParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParenthesizedTypeContext is an interface to support dynamic dispatch.
type IParenthesizedTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	Type_() ITypeContext
	RPAREN() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsParenthesizedTypeContext differentiates from other interfaces.
	IsParenthesizedTypeContext()
}

type ParenthesizedTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesizedTypeContext() *ParenthesizedTypeContext {
	var p = new(ParenthesizedTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_parenthesizedType
	return p
}

func InitEmptyParenthesizedTypeContext(p *ParenthesizedTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_parenthesizedType
}

func (*ParenthesizedTypeContext) IsParenthesizedTypeContext() {}

func NewParenthesizedTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesizedTypeContext {
	var p = new(ParenthesizedTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_parenthesizedType

	return p
}

func (s *ParenthesizedTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesizedTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *ParenthesizedTypeContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ParenthesizedTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *ParenthesizedTypeContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ParenthesizedTypeContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ParenthesizedTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParenthesizedTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterParenthesizedType(s)
	}
}

func (s *ParenthesizedTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitParenthesizedType(s)
	}
}

func (p *KotlinParser) ParenthesizedType() (localctx IParenthesizedTypeContext) {
	localctx = NewParenthesizedTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, KotlinParserRULE_parenthesizedType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1869)
		p.Match(KotlinParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1873)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1870)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1875)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1876)
		p.Type_()
	}
	p.SetState(1880)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1877)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1882)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1883)
		p.Match(KotlinParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReceiverTypeContext is an interface to support dynamic dispatch.
type IReceiverTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParenthesizedType() IParenthesizedTypeContext
	NullableType() INullableTypeContext
	TypeReference() ITypeReferenceContext
	TypeModifiers() ITypeModifiersContext

	// IsReceiverTypeContext differentiates from other interfaces.
	IsReceiverTypeContext()
}

type ReceiverTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiverTypeContext() *ReceiverTypeContext {
	var p = new(ReceiverTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_receiverType
	return p
}

func InitEmptyReceiverTypeContext(p *ReceiverTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_receiverType
}

func (*ReceiverTypeContext) IsReceiverTypeContext() {}

func NewReceiverTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiverTypeContext {
	var p = new(ReceiverTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_receiverType

	return p
}

func (s *ReceiverTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiverTypeContext) ParenthesizedType() IParenthesizedTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesizedTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesizedTypeContext)
}

func (s *ReceiverTypeContext) NullableType() INullableTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullableTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullableTypeContext)
}

func (s *ReceiverTypeContext) TypeReference() ITypeReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeReferenceContext)
}

func (s *ReceiverTypeContext) TypeModifiers() ITypeModifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeModifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeModifiersContext)
}

func (s *ReceiverTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiverTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiverTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterReceiverType(s)
	}
}

func (s *ReceiverTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitReceiverType(s)
	}
}

func (p *KotlinParser) ReceiverType() (localctx IReceiverTypeContext) {
	localctx = NewReceiverTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, KotlinParserRULE_receiverType)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1886)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 277, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1885)
			p.TypeModifiers()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1891)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 278, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1888)
			p.ParenthesizedType()
		}

	case 2:
		{
			p.SetState(1889)
			p.NullableType()
		}

	case 3:
		{
			p.SetState(1890)
			p.TypeReference()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParenthesizedUserTypeContext is an interface to support dynamic dispatch.
type IParenthesizedUserTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	UserType() IUserTypeContext
	ParenthesizedUserType() IParenthesizedUserTypeContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsParenthesizedUserTypeContext differentiates from other interfaces.
	IsParenthesizedUserTypeContext()
}

type ParenthesizedUserTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesizedUserTypeContext() *ParenthesizedUserTypeContext {
	var p = new(ParenthesizedUserTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_parenthesizedUserType
	return p
}

func InitEmptyParenthesizedUserTypeContext(p *ParenthesizedUserTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_parenthesizedUserType
}

func (*ParenthesizedUserTypeContext) IsParenthesizedUserTypeContext() {}

func NewParenthesizedUserTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesizedUserTypeContext {
	var p = new(ParenthesizedUserTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_parenthesizedUserType

	return p
}

func (s *ParenthesizedUserTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesizedUserTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *ParenthesizedUserTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *ParenthesizedUserTypeContext) UserType() IUserTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserTypeContext)
}

func (s *ParenthesizedUserTypeContext) ParenthesizedUserType() IParenthesizedUserTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesizedUserTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesizedUserTypeContext)
}

func (s *ParenthesizedUserTypeContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ParenthesizedUserTypeContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ParenthesizedUserTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedUserTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParenthesizedUserTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterParenthesizedUserType(s)
	}
}

func (s *ParenthesizedUserTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitParenthesizedUserType(s)
	}
}

func (p *KotlinParser) ParenthesizedUserType() (localctx IParenthesizedUserTypeContext) {
	localctx = NewParenthesizedUserTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, KotlinParserRULE_parenthesizedUserType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1893)
		p.Match(KotlinParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1897)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1894)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1899)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1902)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserIdentifier:
		{
			p.SetState(1900)
			p.UserType()
		}

	case KotlinParserLPAREN:
		{
			p.SetState(1901)
			p.ParenthesizedUserType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(1907)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1904)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1909)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1910)
		p.Match(KotlinParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefinitelyNonNullableTypeContext is an interface to support dynamic dispatch.
type IDefinitelyNonNullableTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AMP() antlr.TerminalNode
	AllUserType() []IUserTypeContext
	UserType(i int) IUserTypeContext
	AllParenthesizedUserType() []IParenthesizedUserTypeContext
	ParenthesizedUserType(i int) IParenthesizedUserTypeContext
	AllTypeModifiers() []ITypeModifiersContext
	TypeModifiers(i int) ITypeModifiersContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsDefinitelyNonNullableTypeContext differentiates from other interfaces.
	IsDefinitelyNonNullableTypeContext()
}

type DefinitelyNonNullableTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefinitelyNonNullableTypeContext() *DefinitelyNonNullableTypeContext {
	var p = new(DefinitelyNonNullableTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_definitelyNonNullableType
	return p
}

func InitEmptyDefinitelyNonNullableTypeContext(p *DefinitelyNonNullableTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_definitelyNonNullableType
}

func (*DefinitelyNonNullableTypeContext) IsDefinitelyNonNullableTypeContext() {}

func NewDefinitelyNonNullableTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefinitelyNonNullableTypeContext {
	var p = new(DefinitelyNonNullableTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_definitelyNonNullableType

	return p
}

func (s *DefinitelyNonNullableTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DefinitelyNonNullableTypeContext) AMP() antlr.TerminalNode {
	return s.GetToken(KotlinParserAMP, 0)
}

func (s *DefinitelyNonNullableTypeContext) AllUserType() []IUserTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserTypeContext); ok {
			len++
		}
	}

	tst := make([]IUserTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserTypeContext); ok {
			tst[i] = t.(IUserTypeContext)
			i++
		}
	}

	return tst
}

func (s *DefinitelyNonNullableTypeContext) UserType(i int) IUserTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserTypeContext)
}

func (s *DefinitelyNonNullableTypeContext) AllParenthesizedUserType() []IParenthesizedUserTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParenthesizedUserTypeContext); ok {
			len++
		}
	}

	tst := make([]IParenthesizedUserTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParenthesizedUserTypeContext); ok {
			tst[i] = t.(IParenthesizedUserTypeContext)
			i++
		}
	}

	return tst
}

func (s *DefinitelyNonNullableTypeContext) ParenthesizedUserType(i int) IParenthesizedUserTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesizedUserTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesizedUserTypeContext)
}

func (s *DefinitelyNonNullableTypeContext) AllTypeModifiers() []ITypeModifiersContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeModifiersContext); ok {
			len++
		}
	}

	tst := make([]ITypeModifiersContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeModifiersContext); ok {
			tst[i] = t.(ITypeModifiersContext)
			i++
		}
	}

	return tst
}

func (s *DefinitelyNonNullableTypeContext) TypeModifiers(i int) ITypeModifiersContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeModifiersContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeModifiersContext)
}

func (s *DefinitelyNonNullableTypeContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *DefinitelyNonNullableTypeContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *DefinitelyNonNullableTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefinitelyNonNullableTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefinitelyNonNullableTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterDefinitelyNonNullableType(s)
	}
}

func (s *DefinitelyNonNullableTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitDefinitelyNonNullableType(s)
	}
}

func (p *KotlinParser) DefinitelyNonNullableType() (localctx IDefinitelyNonNullableTypeContext) {
	localctx = NewDefinitelyNonNullableTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, KotlinParserRULE_definitelyNonNullableType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1913)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 282, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1912)
			p.TypeModifiers()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1917)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserIdentifier:
		{
			p.SetState(1915)
			p.UserType()
		}

	case KotlinParserLPAREN:
		{
			p.SetState(1916)
			p.ParenthesizedUserType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(1922)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1919)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1924)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1925)
		p.Match(KotlinParserAMP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1929)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1926)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1931)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1933)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 286, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1932)
			p.TypeModifiers()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1937)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserIdentifier:
		{
			p.SetState(1935)
			p.UserType()
		}

	case KotlinParserLPAREN:
		{
			p.SetState(1936)
			p.ParenthesizedUserType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementsContext is an interface to support dynamic dispatch.
type IStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	AllSemis() []ISemisContext
	Semis(i int) ISemisContext

	// IsStatementsContext differentiates from other interfaces.
	IsStatementsContext()
}

type StatementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementsContext() *StatementsContext {
	var p = new(StatementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_statements
	return p
}

func InitEmptyStatementsContext(p *StatementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_statements
}

func (*StatementsContext) IsStatementsContext() {}

func NewStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementsContext {
	var p = new(StatementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_statements

	return p
}

func (s *StatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementsContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *StatementsContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementsContext) AllSemis() []ISemisContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISemisContext); ok {
			len++
		}
	}

	tst := make([]ISemisContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISemisContext); ok {
			tst[i] = t.(ISemisContext)
			i++
		}
	}

	return tst
}

func (s *StatementsContext) Semis(i int) ISemisContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISemisContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISemisContext)
}

func (s *StatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterStatements(s)
	}
}

func (s *StatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitStatements(s)
	}
}

func (p *KotlinParser) Statements() (localctx IStatementsContext) {
	localctx = NewStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, KotlinParserRULE_statements)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1948)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 289, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1939)
			p.Statement()
		}
		p.SetState(1945)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 288, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1940)
					p.Semis()
				}
				{
					p.SetState(1941)
					p.Statement()
				}

			}
			p.SetState(1947)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 288, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1951)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 290, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1950)
			p.Semis()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Declaration() IDeclarationContext
	Assignment() IAssignmentContext
	LoopStatement() ILoopStatementContext
	Expression() IExpressionContext
	AllLabel() []ILabelContext
	Label(i int) ILabelContext
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Declaration() IDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *StatementContext) Assignment() IAssignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentContext)
}

func (s *StatementContext) LoopStatement() ILoopStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoopStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoopStatementContext)
}

func (s *StatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StatementContext) AllLabel() []ILabelContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILabelContext); ok {
			len++
		}
	}

	tst := make([]ILabelContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILabelContext); ok {
			tst[i] = t.(ILabelContext)
			i++
		}
	}

	return tst
}

func (s *StatementContext) Label(i int) ILabelContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *StatementContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *StatementContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *KotlinParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, KotlinParserRULE_statement)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1957)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 292, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1955)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserIdentifier:
				{
					p.SetState(1953)
					p.Label()
				}

			case KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS:
				{
					p.SetState(1954)
					p.Annotation()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(1959)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 292, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1964)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 293, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1960)
			p.Declaration()
		}

	case 2:
		{
			p.SetState(1961)
			p.Assignment()
		}

	case 3:
		{
			p.SetState(1962)
			p.LoopStatement()
		}

	case 4:
		{
			p.SetState(1963)
			p.Expression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabelContext is an interface to support dynamic dispatch.
type ILabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleIdentifier() ISimpleIdentifierContext
	AT_NO_WS() antlr.TerminalNode
	AT_POST_WS() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsLabelContext differentiates from other interfaces.
	IsLabelContext()
}

type LabelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelContext() *LabelContext {
	var p = new(LabelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_label
	return p
}

func InitEmptyLabelContext(p *LabelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_label
}

func (*LabelContext) IsLabelContext() {}

func NewLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelContext {
	var p = new(LabelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_label

	return p
}

func (s *LabelContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *LabelContext) AT_NO_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAT_NO_WS, 0)
}

func (s *LabelContext) AT_POST_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAT_POST_WS, 0)
}

func (s *LabelContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *LabelContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *LabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterLabel(s)
	}
}

func (s *LabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitLabel(s)
	}
}

func (p *KotlinParser) Label() (localctx ILabelContext) {
	localctx = NewLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, KotlinParserRULE_label)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1966)
		p.SimpleIdentifier()
	}
	{
		p.SetState(1967)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserAT_NO_WS || _la == KotlinParserAT_POST_WS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1971)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 294, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1968)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1973)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 294, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IControlStructureBodyContext is an interface to support dynamic dispatch.
type IControlStructureBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext
	Statement() IStatementContext

	// IsControlStructureBodyContext differentiates from other interfaces.
	IsControlStructureBodyContext()
}

type ControlStructureBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyControlStructureBodyContext() *ControlStructureBodyContext {
	var p = new(ControlStructureBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_controlStructureBody
	return p
}

func InitEmptyControlStructureBodyContext(p *ControlStructureBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_controlStructureBody
}

func (*ControlStructureBodyContext) IsControlStructureBodyContext() {}

func NewControlStructureBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ControlStructureBodyContext {
	var p = new(ControlStructureBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_controlStructureBody

	return p
}

func (s *ControlStructureBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ControlStructureBodyContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ControlStructureBodyContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ControlStructureBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ControlStructureBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ControlStructureBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterControlStructureBody(s)
	}
}

func (s *ControlStructureBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitControlStructureBody(s)
	}
}

func (p *KotlinParser) ControlStructureBody() (localctx IControlStructureBodyContext) {
	localctx = NewControlStructureBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, KotlinParserRULE_controlStructureBody)
	p.SetState(1976)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 295, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1974)
			p.Block()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1975)
			p.Statement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LCURL() antlr.TerminalNode
	Statements() IStatementsContext
	RCURL() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_block
	return p
}

func InitEmptyBlockContext(p *BlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_block
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) LCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserLCURL, 0)
}

func (s *BlockContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *BlockContext) RCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserRCURL, 0)
}

func (s *BlockContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *BlockContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (p *KotlinParser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, KotlinParserRULE_block)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1978)
		p.Match(KotlinParserLCURL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1982)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 296, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1979)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1984)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 296, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(1985)
		p.Statements()
	}
	p.SetState(1989)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(1986)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1991)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1992)
		p.Match(KotlinParserRCURL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoopStatementContext is an interface to support dynamic dispatch.
type ILoopStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ForStatement() IForStatementContext
	WhileStatement() IWhileStatementContext
	DoWhileStatement() IDoWhileStatementContext

	// IsLoopStatementContext differentiates from other interfaces.
	IsLoopStatementContext()
}

type LoopStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoopStatementContext() *LoopStatementContext {
	var p = new(LoopStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_loopStatement
	return p
}

func InitEmptyLoopStatementContext(p *LoopStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_loopStatement
}

func (*LoopStatementContext) IsLoopStatementContext() {}

func NewLoopStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoopStatementContext {
	var p = new(LoopStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_loopStatement

	return p
}

func (s *LoopStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LoopStatementContext) ForStatement() IForStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStatementContext)
}

func (s *LoopStatementContext) WhileStatement() IWhileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileStatementContext)
}

func (s *LoopStatementContext) DoWhileStatement() IDoWhileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDoWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDoWhileStatementContext)
}

func (s *LoopStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoopStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterLoopStatement(s)
	}
}

func (s *LoopStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitLoopStatement(s)
	}
}

func (p *KotlinParser) LoopStatement() (localctx ILoopStatementContext) {
	localctx = NewLoopStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, KotlinParserRULE_loopStatement)
	p.SetState(1997)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KotlinParserFOR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1994)
			p.ForStatement()
		}

	case KotlinParserWHILE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1995)
			p.WhileStatement()
		}

	case KotlinParserDO:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1996)
			p.DoWhileStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForStatementContext is an interface to support dynamic dispatch.
type IForStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	IN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	VariableDeclaration() IVariableDeclarationContext
	MultiVariableDeclaration() IMultiVariableDeclarationContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext
	ControlStructureBody() IControlStructureBodyContext

	// IsForStatementContext differentiates from other interfaces.
	IsForStatementContext()
}

type ForStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStatementContext() *ForStatementContext {
	var p = new(ForStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_forStatement
	return p
}

func InitEmptyForStatementContext(p *ForStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_forStatement
}

func (*ForStatementContext) IsForStatementContext() {}

func NewForStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStatementContext {
	var p = new(ForStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_forStatement

	return p
}

func (s *ForStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(KotlinParserFOR, 0)
}

func (s *ForStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *ForStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(KotlinParserIN, 0)
}

func (s *ForStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *ForStatementContext) VariableDeclaration() IVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *ForStatementContext) MultiVariableDeclaration() IMultiVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiVariableDeclarationContext)
}

func (s *ForStatementContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ForStatementContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ForStatementContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *ForStatementContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ForStatementContext) ControlStructureBody() IControlStructureBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IControlStructureBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IControlStructureBodyContext)
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterForStatement(s)
	}
}

func (s *ForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitForStatement(s)
	}
}

func (p *KotlinParser) ForStatement() (localctx IForStatementContext) {
	localctx = NewForStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, KotlinParserRULE_forStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1999)
		p.Match(KotlinParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2003)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2000)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(2005)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2006)
		p.Match(KotlinParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2010)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 300, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2007)
				p.Annotation()
			}

		}
		p.SetState(2012)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 300, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2015)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KotlinParserNL, KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS, KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserIdentifier:
		{
			p.SetState(2013)
			p.VariableDeclaration()
		}

	case KotlinParserLPAREN:
		{
			p.SetState(2014)
			p.MultiVariableDeclaration()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(2017)
		p.Match(KotlinParserIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2018)
		p.Expression()
	}
	{
		p.SetState(2019)
		p.Match(KotlinParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2023)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 302, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2020)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2025)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 302, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2027)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 303, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2026)
			p.ControlStructureBody()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhileStatementContext is an interface to support dynamic dispatch.
type IWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHILE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	ControlStructureBody() IControlStructureBodyContext
	SEMICOLON() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsWhileStatementContext differentiates from other interfaces.
	IsWhileStatementContext()
}

type WhileStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileStatementContext() *WhileStatementContext {
	var p = new(WhileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_whileStatement
	return p
}

func InitEmptyWhileStatementContext(p *WhileStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_whileStatement
}

func (*WhileStatementContext) IsWhileStatementContext() {}

func NewWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStatementContext {
	var p = new(WhileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_whileStatement

	return p
}

func (s *WhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStatementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(KotlinParserWHILE, 0)
}

func (s *WhileStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *WhileStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhileStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *WhileStatementContext) ControlStructureBody() IControlStructureBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IControlStructureBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IControlStructureBodyContext)
}

func (s *WhileStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserSEMICOLON, 0)
}

func (s *WhileStatementContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *WhileStatementContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterWhileStatement(s)
	}
}

func (s *WhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitWhileStatement(s)
	}
}

func (p *KotlinParser) WhileStatement() (localctx IWhileStatementContext) {
	localctx = NewWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, KotlinParserRULE_whileStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2029)
		p.Match(KotlinParserWHILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2033)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2030)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(2035)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2036)
		p.Match(KotlinParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2037)
		p.Expression()
	}
	{
		p.SetState(2038)
		p.Match(KotlinParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2042)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 305, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2039)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2044)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 305, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2047)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KotlinParserNL, KotlinParserLPAREN, KotlinParserLSQUARE, KotlinParserLCURL, KotlinParserADD, KotlinParserSUB, KotlinParserINCR, KotlinParserDECR, KotlinParserEXCL_WS, KotlinParserEXCL_NO_WS, KotlinParserCOLONCOLON, KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS, KotlinParserRETURN_AT, KotlinParserCONTINUE_AT, KotlinParserBREAK_AT, KotlinParserTHIS_AT, KotlinParserSUPER_AT, KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCLASS, KotlinParserINTERFACE, KotlinParserFUN, KotlinParserOBJECT, KotlinParserVAL, KotlinParserVAR, KotlinParserTYPE_ALIAS, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserTHIS, KotlinParserSUPER, KotlinParserWHERE, KotlinParserIF, KotlinParserWHEN, KotlinParserTRY, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserFOR, KotlinParserDO, KotlinParserWHILE, KotlinParserTHROW, KotlinParserRETURN, KotlinParserCONTINUE, KotlinParserBREAK, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserRealLiteral, KotlinParserIntegerLiteral, KotlinParserHexLiteral, KotlinParserBinLiteral, KotlinParserUnsignedLiteral, KotlinParserLongLiteral, KotlinParserBooleanLiteral, KotlinParserNullLiteral, KotlinParserCharacterLiteral, KotlinParserIdentifier, KotlinParserQUOTE_OPEN, KotlinParserTRIPLE_QUOTE_OPEN:
		{
			p.SetState(2045)
			p.ControlStructureBody()
		}

	case KotlinParserSEMICOLON:
		{
			p.SetState(2046)
			p.Match(KotlinParserSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDoWhileStatementContext is an interface to support dynamic dispatch.
type IDoWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DO() antlr.TerminalNode
	WHILE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	ControlStructureBody() IControlStructureBodyContext

	// IsDoWhileStatementContext differentiates from other interfaces.
	IsDoWhileStatementContext()
}

type DoWhileStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoWhileStatementContext() *DoWhileStatementContext {
	var p = new(DoWhileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_doWhileStatement
	return p
}

func InitEmptyDoWhileStatementContext(p *DoWhileStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_doWhileStatement
}

func (*DoWhileStatementContext) IsDoWhileStatementContext() {}

func NewDoWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoWhileStatementContext {
	var p = new(DoWhileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_doWhileStatement

	return p
}

func (s *DoWhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DoWhileStatementContext) DO() antlr.TerminalNode {
	return s.GetToken(KotlinParserDO, 0)
}

func (s *DoWhileStatementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(KotlinParserWHILE, 0)
}

func (s *DoWhileStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *DoWhileStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DoWhileStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *DoWhileStatementContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *DoWhileStatementContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *DoWhileStatementContext) ControlStructureBody() IControlStructureBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IControlStructureBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IControlStructureBodyContext)
}

func (s *DoWhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoWhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DoWhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterDoWhileStatement(s)
	}
}

func (s *DoWhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitDoWhileStatement(s)
	}
}

func (p *KotlinParser) DoWhileStatement() (localctx IDoWhileStatementContext) {
	localctx = NewDoWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, KotlinParserRULE_doWhileStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2049)
		p.Match(KotlinParserDO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2053)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 307, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2050)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2055)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 307, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2057)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 308, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2056)
			p.ControlStructureBody()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2062)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2059)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(2064)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2065)
		p.Match(KotlinParserWHILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2069)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2066)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(2071)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2072)
		p.Match(KotlinParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2073)
		p.Expression()
	}
	{
		p.SetState(2074)
		p.Match(KotlinParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentContext is an interface to support dynamic dispatch.
type IAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	DirectlyAssignableExpression() IDirectlyAssignableExpressionContext
	ASSIGNMENT() antlr.TerminalNode
	AssignableExpression() IAssignableExpressionContext
	AssignmentAndOperator() IAssignmentAndOperatorContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsAssignmentContext differentiates from other interfaces.
	IsAssignmentContext()
}

type AssignmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentContext() *AssignmentContext {
	var p = new(AssignmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_assignment
	return p
}

func InitEmptyAssignmentContext(p *AssignmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_assignment
}

func (*AssignmentContext) IsAssignmentContext() {}

func NewAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentContext {
	var p = new(AssignmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_assignment

	return p
}

func (s *AssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssignmentContext) DirectlyAssignableExpression() IDirectlyAssignableExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectlyAssignableExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectlyAssignableExpressionContext)
}

func (s *AssignmentContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserASSIGNMENT, 0)
}

func (s *AssignmentContext) AssignableExpression() IAssignableExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignableExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignableExpressionContext)
}

func (s *AssignmentContext) AssignmentAndOperator() IAssignmentAndOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentAndOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentAndOperatorContext)
}

func (s *AssignmentContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *AssignmentContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *AssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAssignment(s)
	}
}

func (s *AssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAssignment(s)
	}
}

func (p *KotlinParser) Assignment() (localctx IAssignmentContext) {
	localctx = NewAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, KotlinParserRULE_assignment)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2082)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 311, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2076)
			p.DirectlyAssignableExpression()
		}
		{
			p.SetState(2077)
			p.Match(KotlinParserASSIGNMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(2079)
			p.AssignableExpression()
		}
		{
			p.SetState(2080)
			p.AssignmentAndOperator()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(2087)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 312, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2084)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2089)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 312, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(2090)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISemiContext is an interface to support dynamic dispatch.
type ISemiContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEMICOLON() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsSemiContext differentiates from other interfaces.
	IsSemiContext()
}

type SemiContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySemiContext() *SemiContext {
	var p = new(SemiContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_semi
	return p
}

func InitEmptySemiContext(p *SemiContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_semi
}

func (*SemiContext) IsSemiContext() {}

func NewSemiContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SemiContext {
	var p = new(SemiContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_semi

	return p
}

func (s *SemiContext) GetParser() antlr.Parser { return s.parser }

func (s *SemiContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserSEMICOLON, 0)
}

func (s *SemiContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *SemiContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *SemiContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SemiContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SemiContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterSemi(s)
	}
}

func (s *SemiContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitSemi(s)
	}
}

func (p *KotlinParser) Semi() (localctx ISemiContext) {
	localctx = NewSemiContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, KotlinParserRULE_semi)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2092)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserNL || _la == KotlinParserSEMICOLON) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(2096)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 313, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2093)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2098)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 313, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISemisContext is an interface to support dynamic dispatch.
type ISemisContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSEMICOLON() []antlr.TerminalNode
	SEMICOLON(i int) antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsSemisContext differentiates from other interfaces.
	IsSemisContext()
}

type SemisContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySemisContext() *SemisContext {
	var p = new(SemisContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_semis
	return p
}

func InitEmptySemisContext(p *SemisContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_semis
}

func (*SemisContext) IsSemisContext() {}

func NewSemisContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SemisContext {
	var p = new(SemisContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_semis

	return p
}

func (s *SemisContext) GetParser() antlr.Parser { return s.parser }

func (s *SemisContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserSEMICOLON)
}

func (s *SemisContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserSEMICOLON, i)
}

func (s *SemisContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *SemisContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *SemisContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SemisContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SemisContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterSemis(s)
	}
}

func (s *SemisContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitSemis(s)
	}
}

func (p *KotlinParser) Semis() (localctx ISemisContext) {
	localctx = NewSemisContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, KotlinParserRULE_semis)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2100)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(2099)
				_la = p.GetTokenStream().LA(1)

				if !(_la == KotlinParserNL || _la == KotlinParserSEMICOLON) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(2102)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 314, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Disjunction() IDisjunctionContext

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) Disjunction() IDisjunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDisjunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDisjunctionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *KotlinParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, KotlinParserRULE_expression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2104)
		p.Disjunction()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDisjunctionContext is an interface to support dynamic dispatch.
type IDisjunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllConjunction() []IConjunctionContext
	Conjunction(i int) IConjunctionContext
	AllDISJ() []antlr.TerminalNode
	DISJ(i int) antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsDisjunctionContext differentiates from other interfaces.
	IsDisjunctionContext()
}

type DisjunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisjunctionContext() *DisjunctionContext {
	var p = new(DisjunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_disjunction
	return p
}

func InitEmptyDisjunctionContext(p *DisjunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_disjunction
}

func (*DisjunctionContext) IsDisjunctionContext() {}

func NewDisjunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisjunctionContext {
	var p = new(DisjunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_disjunction

	return p
}

func (s *DisjunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *DisjunctionContext) AllConjunction() []IConjunctionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConjunctionContext); ok {
			len++
		}
	}

	tst := make([]IConjunctionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConjunctionContext); ok {
			tst[i] = t.(IConjunctionContext)
			i++
		}
	}

	return tst
}

func (s *DisjunctionContext) Conjunction(i int) IConjunctionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConjunctionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConjunctionContext)
}

func (s *DisjunctionContext) AllDISJ() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserDISJ)
}

func (s *DisjunctionContext) DISJ(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserDISJ, i)
}

func (s *DisjunctionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *DisjunctionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *DisjunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisjunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisjunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterDisjunction(s)
	}
}

func (s *DisjunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitDisjunction(s)
	}
}

func (p *KotlinParser) Disjunction() (localctx IDisjunctionContext) {
	localctx = NewDisjunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, KotlinParserRULE_disjunction)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2106)
		p.Conjunction()
	}
	p.SetState(2123)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 317, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2110)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2107)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(2112)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2113)
				p.Match(KotlinParserDISJ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2117)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 316, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(2114)
						p.Match(KotlinParserNL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				p.SetState(2119)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 316, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			{
				p.SetState(2120)
				p.Conjunction()
			}

		}
		p.SetState(2125)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 317, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConjunctionContext is an interface to support dynamic dispatch.
type IConjunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllEquality() []IEqualityContext
	Equality(i int) IEqualityContext
	AllCONJ() []antlr.TerminalNode
	CONJ(i int) antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsConjunctionContext differentiates from other interfaces.
	IsConjunctionContext()
}

type ConjunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConjunctionContext() *ConjunctionContext {
	var p = new(ConjunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_conjunction
	return p
}

func InitEmptyConjunctionContext(p *ConjunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_conjunction
}

func (*ConjunctionContext) IsConjunctionContext() {}

func NewConjunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConjunctionContext {
	var p = new(ConjunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_conjunction

	return p
}

func (s *ConjunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConjunctionContext) AllEquality() []IEqualityContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEqualityContext); ok {
			len++
		}
	}

	tst := make([]IEqualityContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEqualityContext); ok {
			tst[i] = t.(IEqualityContext)
			i++
		}
	}

	return tst
}

func (s *ConjunctionContext) Equality(i int) IEqualityContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualityContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualityContext)
}

func (s *ConjunctionContext) AllCONJ() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCONJ)
}

func (s *ConjunctionContext) CONJ(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCONJ, i)
}

func (s *ConjunctionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ConjunctionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ConjunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConjunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConjunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterConjunction(s)
	}
}

func (s *ConjunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitConjunction(s)
	}
}

func (p *KotlinParser) Conjunction() (localctx IConjunctionContext) {
	localctx = NewConjunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, KotlinParserRULE_conjunction)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2126)
		p.Equality()
	}
	p.SetState(2143)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 320, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2130)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2127)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(2132)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2133)
				p.Match(KotlinParserCONJ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2137)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 319, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(2134)
						p.Match(KotlinParserNL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				p.SetState(2139)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 319, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			{
				p.SetState(2140)
				p.Equality()
			}

		}
		p.SetState(2145)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 320, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEqualityContext is an interface to support dynamic dispatch.
type IEqualityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllComparison() []IComparisonContext
	Comparison(i int) IComparisonContext
	AllEqualityOperator() []IEqualityOperatorContext
	EqualityOperator(i int) IEqualityOperatorContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsEqualityContext differentiates from other interfaces.
	IsEqualityContext()
}

type EqualityContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEqualityContext() *EqualityContext {
	var p = new(EqualityContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_equality
	return p
}

func InitEmptyEqualityContext(p *EqualityContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_equality
}

func (*EqualityContext) IsEqualityContext() {}

func NewEqualityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EqualityContext {
	var p = new(EqualityContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_equality

	return p
}

func (s *EqualityContext) GetParser() antlr.Parser { return s.parser }

func (s *EqualityContext) AllComparison() []IComparisonContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IComparisonContext); ok {
			len++
		}
	}

	tst := make([]IComparisonContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IComparisonContext); ok {
			tst[i] = t.(IComparisonContext)
			i++
		}
	}

	return tst
}

func (s *EqualityContext) Comparison(i int) IComparisonContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonContext)
}

func (s *EqualityContext) AllEqualityOperator() []IEqualityOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEqualityOperatorContext); ok {
			len++
		}
	}

	tst := make([]IEqualityOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEqualityOperatorContext); ok {
			tst[i] = t.(IEqualityOperatorContext)
			i++
		}
	}

	return tst
}

func (s *EqualityContext) EqualityOperator(i int) IEqualityOperatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualityOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualityOperatorContext)
}

func (s *EqualityContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *EqualityContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *EqualityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EqualityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterEquality(s)
	}
}

func (s *EqualityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitEquality(s)
	}
}

func (p *KotlinParser) Equality() (localctx IEqualityContext) {
	localctx = NewEqualityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, KotlinParserRULE_equality)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2146)
		p.Comparison()
	}
	p.SetState(2158)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 322, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2147)
				p.EqualityOperator()
			}
			p.SetState(2151)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 321, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(2148)
						p.Match(KotlinParserNL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				p.SetState(2153)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 321, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			{
				p.SetState(2154)
				p.Comparison()
			}

		}
		p.SetState(2160)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 322, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonContext is an interface to support dynamic dispatch.
type IComparisonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllGenericCallLikeComparison() []IGenericCallLikeComparisonContext
	GenericCallLikeComparison(i int) IGenericCallLikeComparisonContext
	AllComparisonOperator() []IComparisonOperatorContext
	ComparisonOperator(i int) IComparisonOperatorContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsComparisonContext differentiates from other interfaces.
	IsComparisonContext()
}

type ComparisonContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonContext() *ComparisonContext {
	var p = new(ComparisonContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_comparison
	return p
}

func InitEmptyComparisonContext(p *ComparisonContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_comparison
}

func (*ComparisonContext) IsComparisonContext() {}

func NewComparisonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonContext {
	var p = new(ComparisonContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_comparison

	return p
}

func (s *ComparisonContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonContext) AllGenericCallLikeComparison() []IGenericCallLikeComparisonContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGenericCallLikeComparisonContext); ok {
			len++
		}
	}

	tst := make([]IGenericCallLikeComparisonContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGenericCallLikeComparisonContext); ok {
			tst[i] = t.(IGenericCallLikeComparisonContext)
			i++
		}
	}

	return tst
}

func (s *ComparisonContext) GenericCallLikeComparison(i int) IGenericCallLikeComparisonContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericCallLikeComparisonContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericCallLikeComparisonContext)
}

func (s *ComparisonContext) AllComparisonOperator() []IComparisonOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			len++
		}
	}

	tst := make([]IComparisonOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IComparisonOperatorContext); ok {
			tst[i] = t.(IComparisonOperatorContext)
			i++
		}
	}

	return tst
}

func (s *ComparisonContext) ComparisonOperator(i int) IComparisonOperatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *ComparisonContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ComparisonContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterComparison(s)
	}
}

func (s *ComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitComparison(s)
	}
}

func (p *KotlinParser) Comparison() (localctx IComparisonContext) {
	localctx = NewComparisonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, KotlinParserRULE_comparison)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2161)
		p.GenericCallLikeComparison()
	}
	p.SetState(2173)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 324, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2162)
				p.ComparisonOperator()
			}
			p.SetState(2166)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 323, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(2163)
						p.Match(KotlinParserNL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				p.SetState(2168)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 323, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			{
				p.SetState(2169)
				p.GenericCallLikeComparison()
			}

		}
		p.SetState(2175)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 324, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericCallLikeComparisonContext is an interface to support dynamic dispatch.
type IGenericCallLikeComparisonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InfixOperation() IInfixOperationContext
	AllCallSuffix() []ICallSuffixContext
	CallSuffix(i int) ICallSuffixContext

	// IsGenericCallLikeComparisonContext differentiates from other interfaces.
	IsGenericCallLikeComparisonContext()
}

type GenericCallLikeComparisonContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericCallLikeComparisonContext() *GenericCallLikeComparisonContext {
	var p = new(GenericCallLikeComparisonContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_genericCallLikeComparison
	return p
}

func InitEmptyGenericCallLikeComparisonContext(p *GenericCallLikeComparisonContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_genericCallLikeComparison
}

func (*GenericCallLikeComparisonContext) IsGenericCallLikeComparisonContext() {}

func NewGenericCallLikeComparisonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericCallLikeComparisonContext {
	var p = new(GenericCallLikeComparisonContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_genericCallLikeComparison

	return p
}

func (s *GenericCallLikeComparisonContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericCallLikeComparisonContext) InfixOperation() IInfixOperationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInfixOperationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInfixOperationContext)
}

func (s *GenericCallLikeComparisonContext) AllCallSuffix() []ICallSuffixContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICallSuffixContext); ok {
			len++
		}
	}

	tst := make([]ICallSuffixContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICallSuffixContext); ok {
			tst[i] = t.(ICallSuffixContext)
			i++
		}
	}

	return tst
}

func (s *GenericCallLikeComparisonContext) CallSuffix(i int) ICallSuffixContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallSuffixContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallSuffixContext)
}

func (s *GenericCallLikeComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericCallLikeComparisonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericCallLikeComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterGenericCallLikeComparison(s)
	}
}

func (s *GenericCallLikeComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitGenericCallLikeComparison(s)
	}
}

func (p *KotlinParser) GenericCallLikeComparison() (localctx IGenericCallLikeComparisonContext) {
	localctx = NewGenericCallLikeComparisonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, KotlinParserRULE_genericCallLikeComparison)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2176)
		p.InfixOperation()
	}
	p.SetState(2180)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 325, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2177)
				p.CallSuffix()
			}

		}
		p.SetState(2182)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 325, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInfixOperationContext is an interface to support dynamic dispatch.
type IInfixOperationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllElvisExpression() []IElvisExpressionContext
	ElvisExpression(i int) IElvisExpressionContext
	AllInOperator() []IInOperatorContext
	InOperator(i int) IInOperatorContext
	AllIsOperator() []IIsOperatorContext
	IsOperator(i int) IIsOperatorContext
	AllType_() []ITypeContext
	Type_(i int) ITypeContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsInfixOperationContext differentiates from other interfaces.
	IsInfixOperationContext()
}

type InfixOperationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInfixOperationContext() *InfixOperationContext {
	var p = new(InfixOperationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_infixOperation
	return p
}

func InitEmptyInfixOperationContext(p *InfixOperationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_infixOperation
}

func (*InfixOperationContext) IsInfixOperationContext() {}

func NewInfixOperationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InfixOperationContext {
	var p = new(InfixOperationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_infixOperation

	return p
}

func (s *InfixOperationContext) GetParser() antlr.Parser { return s.parser }

func (s *InfixOperationContext) AllElvisExpression() []IElvisExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElvisExpressionContext); ok {
			len++
		}
	}

	tst := make([]IElvisExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElvisExpressionContext); ok {
			tst[i] = t.(IElvisExpressionContext)
			i++
		}
	}

	return tst
}

func (s *InfixOperationContext) ElvisExpression(i int) IElvisExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElvisExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElvisExpressionContext)
}

func (s *InfixOperationContext) AllInOperator() []IInOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInOperatorContext); ok {
			len++
		}
	}

	tst := make([]IInOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInOperatorContext); ok {
			tst[i] = t.(IInOperatorContext)
			i++
		}
	}

	return tst
}

func (s *InfixOperationContext) InOperator(i int) IInOperatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInOperatorContext)
}

func (s *InfixOperationContext) AllIsOperator() []IIsOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIsOperatorContext); ok {
			len++
		}
	}

	tst := make([]IIsOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIsOperatorContext); ok {
			tst[i] = t.(IIsOperatorContext)
			i++
		}
	}

	return tst
}

func (s *InfixOperationContext) IsOperator(i int) IIsOperatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIsOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIsOperatorContext)
}

func (s *InfixOperationContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *InfixOperationContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *InfixOperationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *InfixOperationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *InfixOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InfixOperationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InfixOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterInfixOperation(s)
	}
}

func (s *InfixOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitInfixOperation(s)
	}
}

func (p *KotlinParser) InfixOperation() (localctx IInfixOperationContext) {
	localctx = NewInfixOperationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, KotlinParserRULE_infixOperation)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2183)
		p.ElvisExpression()
	}
	p.SetState(2204)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 329, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2202)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case KotlinParserIN, KotlinParserNOT_IN:
				{
					p.SetState(2184)
					p.InOperator()
				}
				p.SetState(2188)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 326, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(2185)
							p.Match(KotlinParserNL)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}

					}
					p.SetState(2190)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 326, p.GetParserRuleContext())
					if p.HasError() {
						goto errorExit
					}
				}
				{
					p.SetState(2191)
					p.ElvisExpression()
				}

			case KotlinParserIS, KotlinParserNOT_IS:
				{
					p.SetState(2193)
					p.IsOperator()
				}
				p.SetState(2197)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == KotlinParserNL {
					{
						p.SetState(2194)
						p.Match(KotlinParserNL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

					p.SetState(2199)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(2200)
					p.Type_()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(2206)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 329, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElvisExpressionContext is an interface to support dynamic dispatch.
type IElvisExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllInfixFunctionCall() []IInfixFunctionCallContext
	InfixFunctionCall(i int) IInfixFunctionCallContext
	AllElvis() []IElvisContext
	Elvis(i int) IElvisContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsElvisExpressionContext differentiates from other interfaces.
	IsElvisExpressionContext()
}

type ElvisExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElvisExpressionContext() *ElvisExpressionContext {
	var p = new(ElvisExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_elvisExpression
	return p
}

func InitEmptyElvisExpressionContext(p *ElvisExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_elvisExpression
}

func (*ElvisExpressionContext) IsElvisExpressionContext() {}

func NewElvisExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElvisExpressionContext {
	var p = new(ElvisExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_elvisExpression

	return p
}

func (s *ElvisExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ElvisExpressionContext) AllInfixFunctionCall() []IInfixFunctionCallContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInfixFunctionCallContext); ok {
			len++
		}
	}

	tst := make([]IInfixFunctionCallContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInfixFunctionCallContext); ok {
			tst[i] = t.(IInfixFunctionCallContext)
			i++
		}
	}

	return tst
}

func (s *ElvisExpressionContext) InfixFunctionCall(i int) IInfixFunctionCallContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInfixFunctionCallContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInfixFunctionCallContext)
}

func (s *ElvisExpressionContext) AllElvis() []IElvisContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElvisContext); ok {
			len++
		}
	}

	tst := make([]IElvisContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElvisContext); ok {
			tst[i] = t.(IElvisContext)
			i++
		}
	}

	return tst
}

func (s *ElvisExpressionContext) Elvis(i int) IElvisContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElvisContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElvisContext)
}

func (s *ElvisExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ElvisExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ElvisExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElvisExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElvisExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterElvisExpression(s)
	}
}

func (s *ElvisExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitElvisExpression(s)
	}
}

func (p *KotlinParser) ElvisExpression() (localctx IElvisExpressionContext) {
	localctx = NewElvisExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, KotlinParserRULE_elvisExpression)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2207)
		p.InfixFunctionCall()
	}
	p.SetState(2225)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 332, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2211)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2208)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(2213)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2214)
				p.Elvis()
			}
			p.SetState(2218)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 331, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(2215)
						p.Match(KotlinParserNL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				p.SetState(2220)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 331, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			{
				p.SetState(2221)
				p.InfixFunctionCall()
			}

		}
		p.SetState(2227)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 332, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElvisContext is an interface to support dynamic dispatch.
type IElvisContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QUEST_NO_WS() antlr.TerminalNode
	COLON() antlr.TerminalNode

	// IsElvisContext differentiates from other interfaces.
	IsElvisContext()
}

type ElvisContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElvisContext() *ElvisContext {
	var p = new(ElvisContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_elvis
	return p
}

func InitEmptyElvisContext(p *ElvisContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_elvis
}

func (*ElvisContext) IsElvisContext() {}

func NewElvisContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElvisContext {
	var p = new(ElvisContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_elvis

	return p
}

func (s *ElvisContext) GetParser() antlr.Parser { return s.parser }

func (s *ElvisContext) QUEST_NO_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserQUEST_NO_WS, 0)
}

func (s *ElvisContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *ElvisContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElvisContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElvisContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterElvis(s)
	}
}

func (s *ElvisContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitElvis(s)
	}
}

func (p *KotlinParser) Elvis() (localctx IElvisContext) {
	localctx = NewElvisContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, KotlinParserRULE_elvis)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2228)
		p.Match(KotlinParserQUEST_NO_WS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2229)
		p.Match(KotlinParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInfixFunctionCallContext is an interface to support dynamic dispatch.
type IInfixFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRangeExpression() []IRangeExpressionContext
	RangeExpression(i int) IRangeExpressionContext
	AllSimpleIdentifier() []ISimpleIdentifierContext
	SimpleIdentifier(i int) ISimpleIdentifierContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsInfixFunctionCallContext differentiates from other interfaces.
	IsInfixFunctionCallContext()
}

type InfixFunctionCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInfixFunctionCallContext() *InfixFunctionCallContext {
	var p = new(InfixFunctionCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_infixFunctionCall
	return p
}

func InitEmptyInfixFunctionCallContext(p *InfixFunctionCallContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_infixFunctionCall
}

func (*InfixFunctionCallContext) IsInfixFunctionCallContext() {}

func NewInfixFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InfixFunctionCallContext {
	var p = new(InfixFunctionCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_infixFunctionCall

	return p
}

func (s *InfixFunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *InfixFunctionCallContext) AllRangeExpression() []IRangeExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRangeExpressionContext); ok {
			len++
		}
	}

	tst := make([]IRangeExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRangeExpressionContext); ok {
			tst[i] = t.(IRangeExpressionContext)
			i++
		}
	}

	return tst
}

func (s *InfixFunctionCallContext) RangeExpression(i int) IRangeExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRangeExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRangeExpressionContext)
}

func (s *InfixFunctionCallContext) AllSimpleIdentifier() []ISimpleIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			len++
		}
	}

	tst := make([]ISimpleIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimpleIdentifierContext); ok {
			tst[i] = t.(ISimpleIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *InfixFunctionCallContext) SimpleIdentifier(i int) ISimpleIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *InfixFunctionCallContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *InfixFunctionCallContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *InfixFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InfixFunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InfixFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterInfixFunctionCall(s)
	}
}

func (s *InfixFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitInfixFunctionCall(s)
	}
}

func (p *KotlinParser) InfixFunctionCall() (localctx IInfixFunctionCallContext) {
	localctx = NewInfixFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, KotlinParserRULE_infixFunctionCall)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2231)
		p.RangeExpression()
	}
	p.SetState(2243)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 334, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2232)
				p.SimpleIdentifier()
			}
			p.SetState(2236)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 333, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(2233)
						p.Match(KotlinParserNL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				p.SetState(2238)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 333, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			{
				p.SetState(2239)
				p.RangeExpression()
			}

		}
		p.SetState(2245)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 334, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRangeExpressionContext is an interface to support dynamic dispatch.
type IRangeExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAdditiveExpression() []IAdditiveExpressionContext
	AdditiveExpression(i int) IAdditiveExpressionContext
	AllRANGE() []antlr.TerminalNode
	RANGE(i int) antlr.TerminalNode
	AllRANGE_UNTIL() []antlr.TerminalNode
	RANGE_UNTIL(i int) antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsRangeExpressionContext differentiates from other interfaces.
	IsRangeExpressionContext()
}

type RangeExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRangeExpressionContext() *RangeExpressionContext {
	var p = new(RangeExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_rangeExpression
	return p
}

func InitEmptyRangeExpressionContext(p *RangeExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_rangeExpression
}

func (*RangeExpressionContext) IsRangeExpressionContext() {}

func NewRangeExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangeExpressionContext {
	var p = new(RangeExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_rangeExpression

	return p
}

func (s *RangeExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *RangeExpressionContext) AllAdditiveExpression() []IAdditiveExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAdditiveExpressionContext); ok {
			len++
		}
	}

	tst := make([]IAdditiveExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAdditiveExpressionContext); ok {
			tst[i] = t.(IAdditiveExpressionContext)
			i++
		}
	}

	return tst
}

func (s *RangeExpressionContext) AdditiveExpression(i int) IAdditiveExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdditiveExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdditiveExpressionContext)
}

func (s *RangeExpressionContext) AllRANGE() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserRANGE)
}

func (s *RangeExpressionContext) RANGE(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserRANGE, i)
}

func (s *RangeExpressionContext) AllRANGE_UNTIL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserRANGE_UNTIL)
}

func (s *RangeExpressionContext) RANGE_UNTIL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserRANGE_UNTIL, i)
}

func (s *RangeExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *RangeExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *RangeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangeExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterRangeExpression(s)
	}
}

func (s *RangeExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitRangeExpression(s)
	}
}

func (p *KotlinParser) RangeExpression() (localctx IRangeExpressionContext) {
	localctx = NewRangeExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, KotlinParserRULE_rangeExpression)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2246)
		p.AdditiveExpression()
	}
	p.SetState(2257)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 336, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2247)
				_la = p.GetTokenStream().LA(1)

				if !(_la == KotlinParserRANGE || _la == KotlinParserRANGE_UNTIL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			p.SetState(2251)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 335, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(2248)
						p.Match(KotlinParserNL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				p.SetState(2253)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 335, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			{
				p.SetState(2254)
				p.AdditiveExpression()
			}

		}
		p.SetState(2259)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 336, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdditiveExpressionContext is an interface to support dynamic dispatch.
type IAdditiveExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMultiplicativeExpression() []IMultiplicativeExpressionContext
	MultiplicativeExpression(i int) IMultiplicativeExpressionContext
	AllAdditiveOperator() []IAdditiveOperatorContext
	AdditiveOperator(i int) IAdditiveOperatorContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsAdditiveExpressionContext differentiates from other interfaces.
	IsAdditiveExpressionContext()
}

type AdditiveExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditiveExpressionContext() *AdditiveExpressionContext {
	var p = new(AdditiveExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_additiveExpression
	return p
}

func InitEmptyAdditiveExpressionContext(p *AdditiveExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_additiveExpression
}

func (*AdditiveExpressionContext) IsAdditiveExpressionContext() {}

func NewAdditiveExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditiveExpressionContext {
	var p = new(AdditiveExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_additiveExpression

	return p
}

func (s *AdditiveExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditiveExpressionContext) AllMultiplicativeExpression() []IMultiplicativeExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultiplicativeExpressionContext); ok {
			len++
		}
	}

	tst := make([]IMultiplicativeExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultiplicativeExpressionContext); ok {
			tst[i] = t.(IMultiplicativeExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AdditiveExpressionContext) MultiplicativeExpression(i int) IMultiplicativeExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplicativeExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeExpressionContext)
}

func (s *AdditiveExpressionContext) AllAdditiveOperator() []IAdditiveOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAdditiveOperatorContext); ok {
			len++
		}
	}

	tst := make([]IAdditiveOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAdditiveOperatorContext); ok {
			tst[i] = t.(IAdditiveOperatorContext)
			i++
		}
	}

	return tst
}

func (s *AdditiveExpressionContext) AdditiveOperator(i int) IAdditiveOperatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdditiveOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdditiveOperatorContext)
}

func (s *AdditiveExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *AdditiveExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *AdditiveExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditiveExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAdditiveExpression(s)
	}
}

func (s *AdditiveExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAdditiveExpression(s)
	}
}

func (p *KotlinParser) AdditiveExpression() (localctx IAdditiveExpressionContext) {
	localctx = NewAdditiveExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, KotlinParserRULE_additiveExpression)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2260)
		p.MultiplicativeExpression()
	}
	p.SetState(2272)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 338, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2261)
				p.AdditiveOperator()
			}
			p.SetState(2265)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 337, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(2262)
						p.Match(KotlinParserNL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				p.SetState(2267)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 337, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			{
				p.SetState(2268)
				p.MultiplicativeExpression()
			}

		}
		p.SetState(2274)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 338, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiplicativeExpressionContext is an interface to support dynamic dispatch.
type IMultiplicativeExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAsExpression() []IAsExpressionContext
	AsExpression(i int) IAsExpressionContext
	AllMultiplicativeOperator() []IMultiplicativeOperatorContext
	MultiplicativeOperator(i int) IMultiplicativeOperatorContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsMultiplicativeExpressionContext differentiates from other interfaces.
	IsMultiplicativeExpressionContext()
}

type MultiplicativeExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplicativeExpressionContext() *MultiplicativeExpressionContext {
	var p = new(MultiplicativeExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_multiplicativeExpression
	return p
}

func InitEmptyMultiplicativeExpressionContext(p *MultiplicativeExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_multiplicativeExpression
}

func (*MultiplicativeExpressionContext) IsMultiplicativeExpressionContext() {}

func NewMultiplicativeExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplicativeExpressionContext {
	var p = new(MultiplicativeExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_multiplicativeExpression

	return p
}

func (s *MultiplicativeExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplicativeExpressionContext) AllAsExpression() []IAsExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAsExpressionContext); ok {
			len++
		}
	}

	tst := make([]IAsExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAsExpressionContext); ok {
			tst[i] = t.(IAsExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MultiplicativeExpressionContext) AsExpression(i int) IAsExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsExpressionContext)
}

func (s *MultiplicativeExpressionContext) AllMultiplicativeOperator() []IMultiplicativeOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultiplicativeOperatorContext); ok {
			len++
		}
	}

	tst := make([]IMultiplicativeOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultiplicativeOperatorContext); ok {
			tst[i] = t.(IMultiplicativeOperatorContext)
			i++
		}
	}

	return tst
}

func (s *MultiplicativeExpressionContext) MultiplicativeOperator(i int) IMultiplicativeOperatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplicativeOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeOperatorContext)
}

func (s *MultiplicativeExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *MultiplicativeExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *MultiplicativeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplicativeExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterMultiplicativeExpression(s)
	}
}

func (s *MultiplicativeExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitMultiplicativeExpression(s)
	}
}

func (p *KotlinParser) MultiplicativeExpression() (localctx IMultiplicativeExpressionContext) {
	localctx = NewMultiplicativeExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, KotlinParserRULE_multiplicativeExpression)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2275)
		p.AsExpression()
	}
	p.SetState(2287)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 340, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2276)
				p.MultiplicativeOperator()
			}
			p.SetState(2280)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 339, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(2277)
						p.Match(KotlinParserNL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				p.SetState(2282)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 339, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			{
				p.SetState(2283)
				p.AsExpression()
			}

		}
		p.SetState(2289)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 340, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAsExpressionContext is an interface to support dynamic dispatch.
type IAsExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrefixUnaryExpression() IPrefixUnaryExpressionContext
	AllAsOperator() []IAsOperatorContext
	AsOperator(i int) IAsOperatorContext
	AllType_() []ITypeContext
	Type_(i int) ITypeContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsAsExpressionContext differentiates from other interfaces.
	IsAsExpressionContext()
}

type AsExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsExpressionContext() *AsExpressionContext {
	var p = new(AsExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_asExpression
	return p
}

func InitEmptyAsExpressionContext(p *AsExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_asExpression
}

func (*AsExpressionContext) IsAsExpressionContext() {}

func NewAsExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsExpressionContext {
	var p = new(AsExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_asExpression

	return p
}

func (s *AsExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AsExpressionContext) PrefixUnaryExpression() IPrefixUnaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrefixUnaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrefixUnaryExpressionContext)
}

func (s *AsExpressionContext) AllAsOperator() []IAsOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAsOperatorContext); ok {
			len++
		}
	}

	tst := make([]IAsOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAsOperatorContext); ok {
			tst[i] = t.(IAsOperatorContext)
			i++
		}
	}

	return tst
}

func (s *AsExpressionContext) AsOperator(i int) IAsOperatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsOperatorContext)
}

func (s *AsExpressionContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *AsExpressionContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *AsExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *AsExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *AsExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAsExpression(s)
	}
}

func (s *AsExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAsExpression(s)
	}
}

func (p *KotlinParser) AsExpression() (localctx IAsExpressionContext) {
	localctx = NewAsExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, KotlinParserRULE_asExpression)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2290)
		p.PrefixUnaryExpression()
	}
	p.SetState(2308)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 343, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2294)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2291)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(2296)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2297)
				p.AsOperator()
			}
			p.SetState(2301)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2298)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(2303)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2304)
				p.Type_()
			}

		}
		p.SetState(2310)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 343, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrefixUnaryExpressionContext is an interface to support dynamic dispatch.
type IPrefixUnaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PostfixUnaryExpression() IPostfixUnaryExpressionContext
	AllUnaryPrefix() []IUnaryPrefixContext
	UnaryPrefix(i int) IUnaryPrefixContext

	// IsPrefixUnaryExpressionContext differentiates from other interfaces.
	IsPrefixUnaryExpressionContext()
}

type PrefixUnaryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrefixUnaryExpressionContext() *PrefixUnaryExpressionContext {
	var p = new(PrefixUnaryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_prefixUnaryExpression
	return p
}

func InitEmptyPrefixUnaryExpressionContext(p *PrefixUnaryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_prefixUnaryExpression
}

func (*PrefixUnaryExpressionContext) IsPrefixUnaryExpressionContext() {}

func NewPrefixUnaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrefixUnaryExpressionContext {
	var p = new(PrefixUnaryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_prefixUnaryExpression

	return p
}

func (s *PrefixUnaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrefixUnaryExpressionContext) PostfixUnaryExpression() IPostfixUnaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixUnaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixUnaryExpressionContext)
}

func (s *PrefixUnaryExpressionContext) AllUnaryPrefix() []IUnaryPrefixContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnaryPrefixContext); ok {
			len++
		}
	}

	tst := make([]IUnaryPrefixContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnaryPrefixContext); ok {
			tst[i] = t.(IUnaryPrefixContext)
			i++
		}
	}

	return tst
}

func (s *PrefixUnaryExpressionContext) UnaryPrefix(i int) IUnaryPrefixContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryPrefixContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryPrefixContext)
}

func (s *PrefixUnaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrefixUnaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrefixUnaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPrefixUnaryExpression(s)
	}
}

func (s *PrefixUnaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPrefixUnaryExpression(s)
	}
}

func (p *KotlinParser) PrefixUnaryExpression() (localctx IPrefixUnaryExpressionContext) {
	localctx = NewPrefixUnaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, KotlinParserRULE_prefixUnaryExpression)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2314)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 344, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2311)
				p.UnaryPrefix()
			}

		}
		p.SetState(2316)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 344, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(2317)
		p.PostfixUnaryExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnaryPrefixContext is an interface to support dynamic dispatch.
type IUnaryPrefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Annotation() IAnnotationContext
	Label() ILabelContext
	PrefixUnaryOperator() IPrefixUnaryOperatorContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsUnaryPrefixContext differentiates from other interfaces.
	IsUnaryPrefixContext()
}

type UnaryPrefixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryPrefixContext() *UnaryPrefixContext {
	var p = new(UnaryPrefixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_unaryPrefix
	return p
}

func InitEmptyUnaryPrefixContext(p *UnaryPrefixContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_unaryPrefix
}

func (*UnaryPrefixContext) IsUnaryPrefixContext() {}

func NewUnaryPrefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryPrefixContext {
	var p = new(UnaryPrefixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_unaryPrefix

	return p
}

func (s *UnaryPrefixContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryPrefixContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *UnaryPrefixContext) Label() ILabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *UnaryPrefixContext) PrefixUnaryOperator() IPrefixUnaryOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrefixUnaryOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrefixUnaryOperatorContext)
}

func (s *UnaryPrefixContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *UnaryPrefixContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *UnaryPrefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryPrefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryPrefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterUnaryPrefix(s)
	}
}

func (s *UnaryPrefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitUnaryPrefix(s)
	}
}

func (p *KotlinParser) UnaryPrefix() (localctx IUnaryPrefixContext) {
	localctx = NewUnaryPrefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, KotlinParserRULE_unaryPrefix)
	var _alt int

	p.SetState(2328)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2319)
			p.Annotation()
		}

	case KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserIdentifier:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2320)
			p.Label()
		}

	case KotlinParserADD, KotlinParserSUB, KotlinParserINCR, KotlinParserDECR, KotlinParserEXCL_WS, KotlinParserEXCL_NO_WS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2321)
			p.PrefixUnaryOperator()
		}
		p.SetState(2325)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 345, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2322)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(2327)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 345, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPostfixUnaryExpressionContext is an interface to support dynamic dispatch.
type IPostfixUnaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrimaryExpression() IPrimaryExpressionContext
	AllPostfixUnarySuffix() []IPostfixUnarySuffixContext
	PostfixUnarySuffix(i int) IPostfixUnarySuffixContext

	// IsPostfixUnaryExpressionContext differentiates from other interfaces.
	IsPostfixUnaryExpressionContext()
}

type PostfixUnaryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixUnaryExpressionContext() *PostfixUnaryExpressionContext {
	var p = new(PostfixUnaryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_postfixUnaryExpression
	return p
}

func InitEmptyPostfixUnaryExpressionContext(p *PostfixUnaryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_postfixUnaryExpression
}

func (*PostfixUnaryExpressionContext) IsPostfixUnaryExpressionContext() {}

func NewPostfixUnaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixUnaryExpressionContext {
	var p = new(PostfixUnaryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_postfixUnaryExpression

	return p
}

func (s *PostfixUnaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixUnaryExpressionContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *PostfixUnaryExpressionContext) AllPostfixUnarySuffix() []IPostfixUnarySuffixContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPostfixUnarySuffixContext); ok {
			len++
		}
	}

	tst := make([]IPostfixUnarySuffixContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPostfixUnarySuffixContext); ok {
			tst[i] = t.(IPostfixUnarySuffixContext)
			i++
		}
	}

	return tst
}

func (s *PostfixUnaryExpressionContext) PostfixUnarySuffix(i int) IPostfixUnarySuffixContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixUnarySuffixContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixUnarySuffixContext)
}

func (s *PostfixUnaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixUnaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixUnaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPostfixUnaryExpression(s)
	}
}

func (s *PostfixUnaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPostfixUnaryExpression(s)
	}
}

func (p *KotlinParser) PostfixUnaryExpression() (localctx IPostfixUnaryExpressionContext) {
	localctx = NewPostfixUnaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, KotlinParserRULE_postfixUnaryExpression)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2330)
		p.PrimaryExpression()
	}
	p.SetState(2334)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 347, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2331)
				p.PostfixUnarySuffix()
			}

		}
		p.SetState(2336)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 347, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPostfixUnarySuffixContext is an interface to support dynamic dispatch.
type IPostfixUnarySuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PostfixUnaryOperator() IPostfixUnaryOperatorContext
	TypeArguments() ITypeArgumentsContext
	CallSuffix() ICallSuffixContext
	IndexingSuffix() IIndexingSuffixContext
	NavigationSuffix() INavigationSuffixContext

	// IsPostfixUnarySuffixContext differentiates from other interfaces.
	IsPostfixUnarySuffixContext()
}

type PostfixUnarySuffixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixUnarySuffixContext() *PostfixUnarySuffixContext {
	var p = new(PostfixUnarySuffixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_postfixUnarySuffix
	return p
}

func InitEmptyPostfixUnarySuffixContext(p *PostfixUnarySuffixContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_postfixUnarySuffix
}

func (*PostfixUnarySuffixContext) IsPostfixUnarySuffixContext() {}

func NewPostfixUnarySuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixUnarySuffixContext {
	var p = new(PostfixUnarySuffixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_postfixUnarySuffix

	return p
}

func (s *PostfixUnarySuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixUnarySuffixContext) PostfixUnaryOperator() IPostfixUnaryOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixUnaryOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixUnaryOperatorContext)
}

func (s *PostfixUnarySuffixContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *PostfixUnarySuffixContext) CallSuffix() ICallSuffixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallSuffixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallSuffixContext)
}

func (s *PostfixUnarySuffixContext) IndexingSuffix() IIndexingSuffixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexingSuffixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexingSuffixContext)
}

func (s *PostfixUnarySuffixContext) NavigationSuffix() INavigationSuffixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INavigationSuffixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INavigationSuffixContext)
}

func (s *PostfixUnarySuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixUnarySuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixUnarySuffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPostfixUnarySuffix(s)
	}
}

func (s *PostfixUnarySuffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPostfixUnarySuffix(s)
	}
}

func (p *KotlinParser) PostfixUnarySuffix() (localctx IPostfixUnarySuffixContext) {
	localctx = NewPostfixUnarySuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, KotlinParserRULE_postfixUnarySuffix)
	p.SetState(2342)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 348, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2337)
			p.PostfixUnaryOperator()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2338)
			p.TypeArguments()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2339)
			p.CallSuffix()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2340)
			p.IndexingSuffix()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2341)
			p.NavigationSuffix()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDirectlyAssignableExpressionContext is an interface to support dynamic dispatch.
type IDirectlyAssignableExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PostfixUnaryExpression() IPostfixUnaryExpressionContext
	AssignableSuffix() IAssignableSuffixContext
	SimpleIdentifier() ISimpleIdentifierContext
	ParenthesizedDirectlyAssignableExpression() IParenthesizedDirectlyAssignableExpressionContext

	// IsDirectlyAssignableExpressionContext differentiates from other interfaces.
	IsDirectlyAssignableExpressionContext()
}

type DirectlyAssignableExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDirectlyAssignableExpressionContext() *DirectlyAssignableExpressionContext {
	var p = new(DirectlyAssignableExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_directlyAssignableExpression
	return p
}

func InitEmptyDirectlyAssignableExpressionContext(p *DirectlyAssignableExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_directlyAssignableExpression
}

func (*DirectlyAssignableExpressionContext) IsDirectlyAssignableExpressionContext() {}

func NewDirectlyAssignableExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DirectlyAssignableExpressionContext {
	var p = new(DirectlyAssignableExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_directlyAssignableExpression

	return p
}

func (s *DirectlyAssignableExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *DirectlyAssignableExpressionContext) PostfixUnaryExpression() IPostfixUnaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixUnaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixUnaryExpressionContext)
}

func (s *DirectlyAssignableExpressionContext) AssignableSuffix() IAssignableSuffixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignableSuffixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignableSuffixContext)
}

func (s *DirectlyAssignableExpressionContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *DirectlyAssignableExpressionContext) ParenthesizedDirectlyAssignableExpression() IParenthesizedDirectlyAssignableExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesizedDirectlyAssignableExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesizedDirectlyAssignableExpressionContext)
}

func (s *DirectlyAssignableExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DirectlyAssignableExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DirectlyAssignableExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterDirectlyAssignableExpression(s)
	}
}

func (s *DirectlyAssignableExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitDirectlyAssignableExpression(s)
	}
}

func (p *KotlinParser) DirectlyAssignableExpression() (localctx IDirectlyAssignableExpressionContext) {
	localctx = NewDirectlyAssignableExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, KotlinParserRULE_directlyAssignableExpression)
	p.SetState(2349)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 349, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2344)
			p.PostfixUnaryExpression()
		}
		{
			p.SetState(2345)
			p.AssignableSuffix()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2347)
			p.SimpleIdentifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2348)
			p.ParenthesizedDirectlyAssignableExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParenthesizedDirectlyAssignableExpressionContext is an interface to support dynamic dispatch.
type IParenthesizedDirectlyAssignableExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	DirectlyAssignableExpression() IDirectlyAssignableExpressionContext
	RPAREN() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsParenthesizedDirectlyAssignableExpressionContext differentiates from other interfaces.
	IsParenthesizedDirectlyAssignableExpressionContext()
}

type ParenthesizedDirectlyAssignableExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesizedDirectlyAssignableExpressionContext() *ParenthesizedDirectlyAssignableExpressionContext {
	var p = new(ParenthesizedDirectlyAssignableExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_parenthesizedDirectlyAssignableExpression
	return p
}

func InitEmptyParenthesizedDirectlyAssignableExpressionContext(p *ParenthesizedDirectlyAssignableExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_parenthesizedDirectlyAssignableExpression
}

func (*ParenthesizedDirectlyAssignableExpressionContext) IsParenthesizedDirectlyAssignableExpressionContext() {
}

func NewParenthesizedDirectlyAssignableExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesizedDirectlyAssignableExpressionContext {
	var p = new(ParenthesizedDirectlyAssignableExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_parenthesizedDirectlyAssignableExpression

	return p
}

func (s *ParenthesizedDirectlyAssignableExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesizedDirectlyAssignableExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *ParenthesizedDirectlyAssignableExpressionContext) DirectlyAssignableExpression() IDirectlyAssignableExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectlyAssignableExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectlyAssignableExpressionContext)
}

func (s *ParenthesizedDirectlyAssignableExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *ParenthesizedDirectlyAssignableExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ParenthesizedDirectlyAssignableExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ParenthesizedDirectlyAssignableExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedDirectlyAssignableExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParenthesizedDirectlyAssignableExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterParenthesizedDirectlyAssignableExpression(s)
	}
}

func (s *ParenthesizedDirectlyAssignableExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitParenthesizedDirectlyAssignableExpression(s)
	}
}

func (p *KotlinParser) ParenthesizedDirectlyAssignableExpression() (localctx IParenthesizedDirectlyAssignableExpressionContext) {
	localctx = NewParenthesizedDirectlyAssignableExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, KotlinParserRULE_parenthesizedDirectlyAssignableExpression)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2351)
		p.Match(KotlinParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2355)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 350, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2352)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2357)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 350, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(2358)
		p.DirectlyAssignableExpression()
	}
	p.SetState(2362)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2359)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(2364)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2365)
		p.Match(KotlinParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignableExpressionContext is an interface to support dynamic dispatch.
type IAssignableExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrefixUnaryExpression() IPrefixUnaryExpressionContext
	ParenthesizedAssignableExpression() IParenthesizedAssignableExpressionContext

	// IsAssignableExpressionContext differentiates from other interfaces.
	IsAssignableExpressionContext()
}

type AssignableExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignableExpressionContext() *AssignableExpressionContext {
	var p = new(AssignableExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_assignableExpression
	return p
}

func InitEmptyAssignableExpressionContext(p *AssignableExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_assignableExpression
}

func (*AssignableExpressionContext) IsAssignableExpressionContext() {}

func NewAssignableExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignableExpressionContext {
	var p = new(AssignableExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_assignableExpression

	return p
}

func (s *AssignableExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignableExpressionContext) PrefixUnaryExpression() IPrefixUnaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrefixUnaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrefixUnaryExpressionContext)
}

func (s *AssignableExpressionContext) ParenthesizedAssignableExpression() IParenthesizedAssignableExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesizedAssignableExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesizedAssignableExpressionContext)
}

func (s *AssignableExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignableExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignableExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAssignableExpression(s)
	}
}

func (s *AssignableExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAssignableExpression(s)
	}
}

func (p *KotlinParser) AssignableExpression() (localctx IAssignableExpressionContext) {
	localctx = NewAssignableExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, KotlinParserRULE_assignableExpression)
	p.SetState(2369)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 352, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2367)
			p.PrefixUnaryExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2368)
			p.ParenthesizedAssignableExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParenthesizedAssignableExpressionContext is an interface to support dynamic dispatch.
type IParenthesizedAssignableExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AssignableExpression() IAssignableExpressionContext
	RPAREN() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsParenthesizedAssignableExpressionContext differentiates from other interfaces.
	IsParenthesizedAssignableExpressionContext()
}

type ParenthesizedAssignableExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesizedAssignableExpressionContext() *ParenthesizedAssignableExpressionContext {
	var p = new(ParenthesizedAssignableExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_parenthesizedAssignableExpression
	return p
}

func InitEmptyParenthesizedAssignableExpressionContext(p *ParenthesizedAssignableExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_parenthesizedAssignableExpression
}

func (*ParenthesizedAssignableExpressionContext) IsParenthesizedAssignableExpressionContext() {}

func NewParenthesizedAssignableExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesizedAssignableExpressionContext {
	var p = new(ParenthesizedAssignableExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_parenthesizedAssignableExpression

	return p
}

func (s *ParenthesizedAssignableExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesizedAssignableExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *ParenthesizedAssignableExpressionContext) AssignableExpression() IAssignableExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignableExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignableExpressionContext)
}

func (s *ParenthesizedAssignableExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *ParenthesizedAssignableExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ParenthesizedAssignableExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ParenthesizedAssignableExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedAssignableExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParenthesizedAssignableExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterParenthesizedAssignableExpression(s)
	}
}

func (s *ParenthesizedAssignableExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitParenthesizedAssignableExpression(s)
	}
}

func (p *KotlinParser) ParenthesizedAssignableExpression() (localctx IParenthesizedAssignableExpressionContext) {
	localctx = NewParenthesizedAssignableExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, KotlinParserRULE_parenthesizedAssignableExpression)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2371)
		p.Match(KotlinParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2375)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 353, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2372)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2377)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 353, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(2378)
		p.AssignableExpression()
	}
	p.SetState(2382)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2379)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(2384)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2385)
		p.Match(KotlinParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignableSuffixContext is an interface to support dynamic dispatch.
type IAssignableSuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeArguments() ITypeArgumentsContext
	IndexingSuffix() IIndexingSuffixContext
	NavigationSuffix() INavigationSuffixContext

	// IsAssignableSuffixContext differentiates from other interfaces.
	IsAssignableSuffixContext()
}

type AssignableSuffixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignableSuffixContext() *AssignableSuffixContext {
	var p = new(AssignableSuffixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_assignableSuffix
	return p
}

func InitEmptyAssignableSuffixContext(p *AssignableSuffixContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_assignableSuffix
}

func (*AssignableSuffixContext) IsAssignableSuffixContext() {}

func NewAssignableSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignableSuffixContext {
	var p = new(AssignableSuffixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_assignableSuffix

	return p
}

func (s *AssignableSuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignableSuffixContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *AssignableSuffixContext) IndexingSuffix() IIndexingSuffixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexingSuffixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexingSuffixContext)
}

func (s *AssignableSuffixContext) NavigationSuffix() INavigationSuffixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INavigationSuffixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INavigationSuffixContext)
}

func (s *AssignableSuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignableSuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignableSuffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAssignableSuffix(s)
	}
}

func (s *AssignableSuffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAssignableSuffix(s)
	}
}

func (p *KotlinParser) AssignableSuffix() (localctx IAssignableSuffixContext) {
	localctx = NewAssignableSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, KotlinParserRULE_assignableSuffix)
	p.SetState(2390)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KotlinParserLANGLE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2387)
			p.TypeArguments()
		}

	case KotlinParserLSQUARE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2388)
			p.IndexingSuffix()
		}

	case KotlinParserNL, KotlinParserDOT, KotlinParserCOLONCOLON, KotlinParserQUEST_NO_WS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2389)
			p.NavigationSuffix()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexingSuffixContext is an interface to support dynamic dispatch.
type IIndexingSuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LSQUARE() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	RSQUARE() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIndexingSuffixContext differentiates from other interfaces.
	IsIndexingSuffixContext()
}

type IndexingSuffixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexingSuffixContext() *IndexingSuffixContext {
	var p = new(IndexingSuffixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_indexingSuffix
	return p
}

func InitEmptyIndexingSuffixContext(p *IndexingSuffixContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_indexingSuffix
}

func (*IndexingSuffixContext) IsIndexingSuffixContext() {}

func NewIndexingSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexingSuffixContext {
	var p = new(IndexingSuffixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_indexingSuffix

	return p
}

func (s *IndexingSuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexingSuffixContext) LSQUARE() antlr.TerminalNode {
	return s.GetToken(KotlinParserLSQUARE, 0)
}

func (s *IndexingSuffixContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *IndexingSuffixContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IndexingSuffixContext) RSQUARE() antlr.TerminalNode {
	return s.GetToken(KotlinParserRSQUARE, 0)
}

func (s *IndexingSuffixContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *IndexingSuffixContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *IndexingSuffixContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *IndexingSuffixContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *IndexingSuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexingSuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexingSuffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterIndexingSuffix(s)
	}
}

func (s *IndexingSuffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitIndexingSuffix(s)
	}
}

func (p *KotlinParser) IndexingSuffix() (localctx IIndexingSuffixContext) {
	localctx = NewIndexingSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, KotlinParserRULE_indexingSuffix)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2392)
		p.Match(KotlinParserLSQUARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2396)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 356, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2393)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2398)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 356, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(2399)
		p.Expression()
	}
	p.SetState(2416)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 359, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2403)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2400)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(2405)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2406)
				p.Match(KotlinParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2410)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 358, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(2407)
						p.Match(KotlinParserNL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				p.SetState(2412)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 358, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			{
				p.SetState(2413)
				p.Expression()
			}

		}
		p.SetState(2418)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 359, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2426)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 361, p.GetParserRuleContext()) == 1 {
		p.SetState(2422)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2419)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(2424)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2425)
			p.Match(KotlinParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2431)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2428)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(2433)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2434)
		p.Match(KotlinParserRSQUARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INavigationSuffixContext is an interface to support dynamic dispatch.
type INavigationSuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MemberAccessOperator() IMemberAccessOperatorContext
	SimpleIdentifier() ISimpleIdentifierContext
	ParenthesizedExpression() IParenthesizedExpressionContext
	CLASS() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsNavigationSuffixContext differentiates from other interfaces.
	IsNavigationSuffixContext()
}

type NavigationSuffixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNavigationSuffixContext() *NavigationSuffixContext {
	var p = new(NavigationSuffixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_navigationSuffix
	return p
}

func InitEmptyNavigationSuffixContext(p *NavigationSuffixContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_navigationSuffix
}

func (*NavigationSuffixContext) IsNavigationSuffixContext() {}

func NewNavigationSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NavigationSuffixContext {
	var p = new(NavigationSuffixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_navigationSuffix

	return p
}

func (s *NavigationSuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *NavigationSuffixContext) MemberAccessOperator() IMemberAccessOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberAccessOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberAccessOperatorContext)
}

func (s *NavigationSuffixContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *NavigationSuffixContext) ParenthesizedExpression() IParenthesizedExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesizedExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesizedExpressionContext)
}

func (s *NavigationSuffixContext) CLASS() antlr.TerminalNode {
	return s.GetToken(KotlinParserCLASS, 0)
}

func (s *NavigationSuffixContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *NavigationSuffixContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *NavigationSuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NavigationSuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NavigationSuffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterNavigationSuffix(s)
	}
}

func (s *NavigationSuffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitNavigationSuffix(s)
	}
}

func (p *KotlinParser) NavigationSuffix() (localctx INavigationSuffixContext) {
	localctx = NewNavigationSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, KotlinParserRULE_navigationSuffix)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2436)
		p.MemberAccessOperator()
	}
	p.SetState(2440)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2437)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(2442)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(2446)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserIdentifier:
		{
			p.SetState(2443)
			p.SimpleIdentifier()
		}

	case KotlinParserLPAREN:
		{
			p.SetState(2444)
			p.ParenthesizedExpression()
		}

	case KotlinParserCLASS:
		{
			p.SetState(2445)
			p.Match(KotlinParserCLASS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICallSuffixContext is an interface to support dynamic dispatch.
type ICallSuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AnnotatedLambda() IAnnotatedLambdaContext
	ValueArguments() IValueArgumentsContext
	TypeArguments() ITypeArgumentsContext

	// IsCallSuffixContext differentiates from other interfaces.
	IsCallSuffixContext()
}

type CallSuffixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallSuffixContext() *CallSuffixContext {
	var p = new(CallSuffixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_callSuffix
	return p
}

func InitEmptyCallSuffixContext(p *CallSuffixContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_callSuffix
}

func (*CallSuffixContext) IsCallSuffixContext() {}

func NewCallSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallSuffixContext {
	var p = new(CallSuffixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_callSuffix

	return p
}

func (s *CallSuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *CallSuffixContext) AnnotatedLambda() IAnnotatedLambdaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotatedLambdaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotatedLambdaContext)
}

func (s *CallSuffixContext) ValueArguments() IValueArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueArgumentsContext)
}

func (s *CallSuffixContext) TypeArguments() ITypeArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *CallSuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallSuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallSuffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterCallSuffix(s)
	}
}

func (s *CallSuffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitCallSuffix(s)
	}
}

func (p *KotlinParser) CallSuffix() (localctx ICallSuffixContext) {
	localctx = NewCallSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, KotlinParserRULE_callSuffix)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2449)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserLANGLE {
		{
			p.SetState(2448)
			p.TypeArguments()
		}

	}
	p.SetState(2456)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 367, p.GetParserRuleContext()) {
	case 1:
		p.SetState(2452)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KotlinParserLPAREN {
			{
				p.SetState(2451)
				p.ValueArguments()
			}

		}
		{
			p.SetState(2454)
			p.AnnotatedLambda()
		}

	case 2:
		{
			p.SetState(2455)
			p.ValueArguments()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnnotatedLambdaContext is an interface to support dynamic dispatch.
type IAnnotatedLambdaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LambdaLiteral() ILambdaLiteralContext
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext
	Label() ILabelContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsAnnotatedLambdaContext differentiates from other interfaces.
	IsAnnotatedLambdaContext()
}

type AnnotatedLambdaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotatedLambdaContext() *AnnotatedLambdaContext {
	var p = new(AnnotatedLambdaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_annotatedLambda
	return p
}

func InitEmptyAnnotatedLambdaContext(p *AnnotatedLambdaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_annotatedLambda
}

func (*AnnotatedLambdaContext) IsAnnotatedLambdaContext() {}

func NewAnnotatedLambdaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotatedLambdaContext {
	var p = new(AnnotatedLambdaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_annotatedLambda

	return p
}

func (s *AnnotatedLambdaContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotatedLambdaContext) LambdaLiteral() ILambdaLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaLiteralContext)
}

func (s *AnnotatedLambdaContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *AnnotatedLambdaContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *AnnotatedLambdaContext) Label() ILabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *AnnotatedLambdaContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *AnnotatedLambdaContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *AnnotatedLambdaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotatedLambdaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotatedLambdaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAnnotatedLambda(s)
	}
}

func (s *AnnotatedLambdaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAnnotatedLambda(s)
	}
}

func (p *KotlinParser) AnnotatedLambda() (localctx IAnnotatedLambdaContext) {
	localctx = NewAnnotatedLambdaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, KotlinParserRULE_annotatedLambda)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2461)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS {
		{
			p.SetState(2458)
			p.Annotation()
		}

		p.SetState(2463)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(2465)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-63)) & ^0x3f) == 0 && ((int64(1)<<(_la-63))&-17588927330817) != 0) || ((int64((_la-127)) & ^0x3f) == 0 && ((int64(1)<<(_la-127))&2098175) != 0) {
		{
			p.SetState(2464)
			p.Label()
		}

	}
	p.SetState(2470)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2467)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(2472)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2473)
		p.LambdaLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeArgumentsContext is an interface to support dynamic dispatch.
type ITypeArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LANGLE() antlr.TerminalNode
	AllTypeProjection() []ITypeProjectionContext
	TypeProjection(i int) ITypeProjectionContext
	RANGLE() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypeArgumentsContext differentiates from other interfaces.
	IsTypeArgumentsContext()
}

type TypeArgumentsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentsContext() *TypeArgumentsContext {
	var p = new(TypeArgumentsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_typeArguments
	return p
}

func InitEmptyTypeArgumentsContext(p *TypeArgumentsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_typeArguments
}

func (*TypeArgumentsContext) IsTypeArgumentsContext() {}

func NewTypeArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentsContext {
	var p = new(TypeArgumentsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeArguments

	return p
}

func (s *TypeArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentsContext) LANGLE() antlr.TerminalNode {
	return s.GetToken(KotlinParserLANGLE, 0)
}

func (s *TypeArgumentsContext) AllTypeProjection() []ITypeProjectionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeProjectionContext); ok {
			len++
		}
	}

	tst := make([]ITypeProjectionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeProjectionContext); ok {
			tst[i] = t.(ITypeProjectionContext)
			i++
		}
	}

	return tst
}

func (s *TypeArgumentsContext) TypeProjection(i int) ITypeProjectionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeProjectionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeProjectionContext)
}

func (s *TypeArgumentsContext) RANGLE() antlr.TerminalNode {
	return s.GetToken(KotlinParserRANGLE, 0)
}

func (s *TypeArgumentsContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeArgumentsContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeArgumentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *TypeArgumentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *TypeArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeArguments(s)
	}
}

func (s *TypeArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeArguments(s)
	}
}

func (p *KotlinParser) TypeArguments() (localctx ITypeArgumentsContext) {
	localctx = NewTypeArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, KotlinParserRULE_typeArguments)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2475)
		p.Match(KotlinParserLANGLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2479)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2476)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(2481)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2482)
		p.TypeProjection()
	}
	p.SetState(2499)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 374, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2486)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2483)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(2488)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2489)
				p.Match(KotlinParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2493)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2490)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(2495)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2496)
				p.TypeProjection()
			}

		}
		p.SetState(2501)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 374, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2509)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 376, p.GetParserRuleContext()) == 1 {
		p.SetState(2505)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2502)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(2507)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2508)
			p.Match(KotlinParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2514)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2511)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(2516)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2517)
		p.Match(KotlinParserRANGLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueArgumentsContext is an interface to support dynamic dispatch.
type IValueArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	AllValueArgument() []IValueArgumentContext
	ValueArgument(i int) IValueArgumentContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsValueArgumentsContext differentiates from other interfaces.
	IsValueArgumentsContext()
}

type ValueArgumentsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueArgumentsContext() *ValueArgumentsContext {
	var p = new(ValueArgumentsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_valueArguments
	return p
}

func InitEmptyValueArgumentsContext(p *ValueArgumentsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_valueArguments
}

func (*ValueArgumentsContext) IsValueArgumentsContext() {}

func NewValueArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueArgumentsContext {
	var p = new(ValueArgumentsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_valueArguments

	return p
}

func (s *ValueArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueArgumentsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *ValueArgumentsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *ValueArgumentsContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ValueArgumentsContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ValueArgumentsContext) AllValueArgument() []IValueArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueArgumentContext); ok {
			len++
		}
	}

	tst := make([]IValueArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueArgumentContext); ok {
			tst[i] = t.(IValueArgumentContext)
			i++
		}
	}

	return tst
}

func (s *ValueArgumentsContext) ValueArgument(i int) IValueArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueArgumentContext)
}

func (s *ValueArgumentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *ValueArgumentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *ValueArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterValueArguments(s)
	}
}

func (s *ValueArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitValueArguments(s)
	}
}

func (p *KotlinParser) ValueArguments() (localctx IValueArgumentsContext) {
	localctx = NewValueArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, KotlinParserRULE_valueArguments)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2519)
		p.Match(KotlinParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2523)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 378, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2520)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2525)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 378, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2561)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-288219106103219680) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-8536323116289) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&27259903) != 0) {
		{
			p.SetState(2526)
			p.ValueArgument()
		}
		p.SetState(2543)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 381, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(2530)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == KotlinParserNL {
					{
						p.SetState(2527)
						p.Match(KotlinParserNL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

					p.SetState(2532)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(2533)
					p.Match(KotlinParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(2537)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 380, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(2534)
							p.Match(KotlinParserNL)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}

					}
					p.SetState(2539)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 380, p.GetParserRuleContext())
					if p.HasError() {
						goto errorExit
					}
				}
				{
					p.SetState(2540)
					p.ValueArgument()
				}

			}
			p.SetState(2545)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 381, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(2553)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 383, p.GetParserRuleContext()) == 1 {
			p.SetState(2549)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2546)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(2551)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2552)
				p.Match(KotlinParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2558)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2555)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(2560)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(2563)
		p.Match(KotlinParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueArgumentContext is an interface to support dynamic dispatch.
type IValueArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	Annotation() IAnnotationContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	SimpleIdentifier() ISimpleIdentifierContext
	ASSIGNMENT() antlr.TerminalNode
	MULT() antlr.TerminalNode

	// IsValueArgumentContext differentiates from other interfaces.
	IsValueArgumentContext()
}

type ValueArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueArgumentContext() *ValueArgumentContext {
	var p = new(ValueArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_valueArgument
	return p
}

func InitEmptyValueArgumentContext(p *ValueArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_valueArgument
}

func (*ValueArgumentContext) IsValueArgumentContext() {}

func NewValueArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueArgumentContext {
	var p = new(ValueArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_valueArgument

	return p
}

func (s *ValueArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueArgumentContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ValueArgumentContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ValueArgumentContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ValueArgumentContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ValueArgumentContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *ValueArgumentContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserASSIGNMENT, 0)
}

func (s *ValueArgumentContext) MULT() antlr.TerminalNode {
	return s.GetToken(KotlinParserMULT, 0)
}

func (s *ValueArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterValueArgument(s)
	}
}

func (s *ValueArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitValueArgument(s)
	}
}

func (p *KotlinParser) ValueArgument() (localctx IValueArgumentContext) {
	localctx = NewValueArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, KotlinParserRULE_valueArgument)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2566)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 386, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2565)
			p.Annotation()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2571)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 387, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2568)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2573)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 387, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2588)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 390, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2574)
			p.SimpleIdentifier()
		}
		p.SetState(2578)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2575)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(2580)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2581)
			p.Match(KotlinParserASSIGNMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2585)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 389, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2582)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(2587)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 389, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2591)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserMULT {
		{
			p.SetState(2590)
			p.Match(KotlinParserMULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(2596)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 392, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2593)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2598)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 392, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(2599)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParenthesizedExpression() IParenthesizedExpressionContext
	SimpleIdentifier() ISimpleIdentifierContext
	LiteralConstant() ILiteralConstantContext
	StringLiteral() IStringLiteralContext
	CallableReference() ICallableReferenceContext
	FunctionLiteral() IFunctionLiteralContext
	ObjectLiteral() IObjectLiteralContext
	CollectionLiteral() ICollectionLiteralContext
	ThisExpression() IThisExpressionContext
	SuperExpression() ISuperExpressionContext
	IfExpression() IIfExpressionContext
	WhenExpression() IWhenExpressionContext
	TryExpression() ITryExpressionContext
	JumpExpression() IJumpExpressionContext

	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_primaryExpression
	return p
}

func InitEmptyPrimaryExpressionContext(p *PrimaryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_primaryExpression
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) ParenthesizedExpression() IParenthesizedExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesizedExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesizedExpressionContext)
}

func (s *PrimaryExpressionContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *PrimaryExpressionContext) LiteralConstant() ILiteralConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralConstantContext)
}

func (s *PrimaryExpressionContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *PrimaryExpressionContext) CallableReference() ICallableReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallableReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallableReferenceContext)
}

func (s *PrimaryExpressionContext) FunctionLiteral() IFunctionLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionLiteralContext)
}

func (s *PrimaryExpressionContext) ObjectLiteral() IObjectLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectLiteralContext)
}

func (s *PrimaryExpressionContext) CollectionLiteral() ICollectionLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollectionLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollectionLiteralContext)
}

func (s *PrimaryExpressionContext) ThisExpression() IThisExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IThisExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IThisExpressionContext)
}

func (s *PrimaryExpressionContext) SuperExpression() ISuperExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISuperExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISuperExpressionContext)
}

func (s *PrimaryExpressionContext) IfExpression() IIfExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExpressionContext)
}

func (s *PrimaryExpressionContext) WhenExpression() IWhenExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenExpressionContext)
}

func (s *PrimaryExpressionContext) TryExpression() ITryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryExpressionContext)
}

func (s *PrimaryExpressionContext) JumpExpression() IJumpExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJumpExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJumpExpressionContext)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPrimaryExpression(s)
	}
}

func (s *PrimaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPrimaryExpression(s)
	}
}

func (p *KotlinParser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, KotlinParserRULE_primaryExpression)
	p.SetState(2615)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 393, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2601)
			p.ParenthesizedExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2602)
			p.SimpleIdentifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2603)
			p.LiteralConstant()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2604)
			p.StringLiteral()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2605)
			p.CallableReference()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2606)
			p.FunctionLiteral()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2607)
			p.ObjectLiteral()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2608)
			p.CollectionLiteral()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2609)
			p.ThisExpression()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2610)
			p.SuperExpression()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2611)
			p.IfExpression()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(2612)
			p.WhenExpression()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(2613)
			p.TryExpression()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(2614)
			p.JumpExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParenthesizedExpressionContext is an interface to support dynamic dispatch.
type IParenthesizedExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsParenthesizedExpressionContext differentiates from other interfaces.
	IsParenthesizedExpressionContext()
}

type ParenthesizedExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesizedExpressionContext() *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_parenthesizedExpression
	return p
}

func InitEmptyParenthesizedExpressionContext(p *ParenthesizedExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_parenthesizedExpression
}

func (*ParenthesizedExpressionContext) IsParenthesizedExpressionContext() {}

func NewParenthesizedExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_parenthesizedExpression

	return p
}

func (s *ParenthesizedExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesizedExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *ParenthesizedExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParenthesizedExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *ParenthesizedExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ParenthesizedExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParenthesizedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitParenthesizedExpression(s)
	}
}

func (p *KotlinParser) ParenthesizedExpression() (localctx IParenthesizedExpressionContext) {
	localctx = NewParenthesizedExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, KotlinParserRULE_parenthesizedExpression)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2617)
		p.Match(KotlinParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2621)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 394, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2618)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2623)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 394, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(2624)
		p.Expression()
	}
	p.SetState(2628)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2625)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(2630)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2631)
		p.Match(KotlinParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICollectionLiteralContext is an interface to support dynamic dispatch.
type ICollectionLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LSQUARE() antlr.TerminalNode
	RSQUARE() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCollectionLiteralContext differentiates from other interfaces.
	IsCollectionLiteralContext()
}

type CollectionLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollectionLiteralContext() *CollectionLiteralContext {
	var p = new(CollectionLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_collectionLiteral
	return p
}

func InitEmptyCollectionLiteralContext(p *CollectionLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_collectionLiteral
}

func (*CollectionLiteralContext) IsCollectionLiteralContext() {}

func NewCollectionLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollectionLiteralContext {
	var p = new(CollectionLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_collectionLiteral

	return p
}

func (s *CollectionLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *CollectionLiteralContext) LSQUARE() antlr.TerminalNode {
	return s.GetToken(KotlinParserLSQUARE, 0)
}

func (s *CollectionLiteralContext) RSQUARE() antlr.TerminalNode {
	return s.GetToken(KotlinParserRSQUARE, 0)
}

func (s *CollectionLiteralContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *CollectionLiteralContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *CollectionLiteralContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CollectionLiteralContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CollectionLiteralContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *CollectionLiteralContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *CollectionLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollectionLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollectionLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterCollectionLiteral(s)
	}
}

func (s *CollectionLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitCollectionLiteral(s)
	}
}

func (p *KotlinParser) CollectionLiteral() (localctx ICollectionLiteralContext) {
	localctx = NewCollectionLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, KotlinParserRULE_collectionLiteral)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2633)
		p.Match(KotlinParserLSQUARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2637)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 396, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2634)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2639)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 396, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2675)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-288219106103252448) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-8536323116289) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&27259903) != 0) {
		{
			p.SetState(2640)
			p.Expression()
		}
		p.SetState(2657)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 399, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(2644)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == KotlinParserNL {
					{
						p.SetState(2641)
						p.Match(KotlinParserNL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

					p.SetState(2646)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(2647)
					p.Match(KotlinParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(2651)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 398, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(2648)
							p.Match(KotlinParserNL)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}

					}
					p.SetState(2653)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 398, p.GetParserRuleContext())
					if p.HasError() {
						goto errorExit
					}
				}
				{
					p.SetState(2654)
					p.Expression()
				}

			}
			p.SetState(2659)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 399, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(2667)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 401, p.GetParserRuleContext()) == 1 {
			p.SetState(2663)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2660)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(2665)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2666)
				p.Match(KotlinParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2672)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2669)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(2674)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(2677)
		p.Match(KotlinParserRSQUARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralConstantContext is an interface to support dynamic dispatch.
type ILiteralConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BooleanLiteral() antlr.TerminalNode
	IntegerLiteral() antlr.TerminalNode
	HexLiteral() antlr.TerminalNode
	BinLiteral() antlr.TerminalNode
	CharacterLiteral() antlr.TerminalNode
	RealLiteral() antlr.TerminalNode
	NullLiteral() antlr.TerminalNode
	LongLiteral() antlr.TerminalNode
	UnsignedLiteral() antlr.TerminalNode

	// IsLiteralConstantContext differentiates from other interfaces.
	IsLiteralConstantContext()
}

type LiteralConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralConstantContext() *LiteralConstantContext {
	var p = new(LiteralConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_literalConstant
	return p
}

func InitEmptyLiteralConstantContext(p *LiteralConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_literalConstant
}

func (*LiteralConstantContext) IsLiteralConstantContext() {}

func NewLiteralConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralConstantContext {
	var p = new(LiteralConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_literalConstant

	return p
}

func (s *LiteralConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralConstantContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(KotlinParserBooleanLiteral, 0)
}

func (s *LiteralConstantContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(KotlinParserIntegerLiteral, 0)
}

func (s *LiteralConstantContext) HexLiteral() antlr.TerminalNode {
	return s.GetToken(KotlinParserHexLiteral, 0)
}

func (s *LiteralConstantContext) BinLiteral() antlr.TerminalNode {
	return s.GetToken(KotlinParserBinLiteral, 0)
}

func (s *LiteralConstantContext) CharacterLiteral() antlr.TerminalNode {
	return s.GetToken(KotlinParserCharacterLiteral, 0)
}

func (s *LiteralConstantContext) RealLiteral() antlr.TerminalNode {
	return s.GetToken(KotlinParserRealLiteral, 0)
}

func (s *LiteralConstantContext) NullLiteral() antlr.TerminalNode {
	return s.GetToken(KotlinParserNullLiteral, 0)
}

func (s *LiteralConstantContext) LongLiteral() antlr.TerminalNode {
	return s.GetToken(KotlinParserLongLiteral, 0)
}

func (s *LiteralConstantContext) UnsignedLiteral() antlr.TerminalNode {
	return s.GetToken(KotlinParserUnsignedLiteral, 0)
}

func (s *LiteralConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterLiteralConstant(s)
	}
}

func (s *LiteralConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitLiteralConstant(s)
	}
}

func (p *KotlinParser) LiteralConstant() (localctx ILiteralConstantContext) {
	localctx = NewLiteralConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, KotlinParserRULE_literalConstant)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2679)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-137)) & ^0x3f) == 0 && ((int64(1)<<(_la-137))&2041) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LineStringLiteral() ILineStringLiteralContext
	MultiLineStringLiteral() IMultiLineStringLiteralContext

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_stringLiteral
	return p
}

func InitEmptyStringLiteralContext(p *StringLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_stringLiteral
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) LineStringLiteral() ILineStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILineStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILineStringLiteralContext)
}

func (s *StringLiteralContext) MultiLineStringLiteral() IMultiLineStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiLineStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiLineStringLiteralContext)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

func (p *KotlinParser) StringLiteral() (localctx IStringLiteralContext) {
	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, KotlinParserRULE_stringLiteral)
	p.SetState(2683)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KotlinParserQUOTE_OPEN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2681)
			p.LineStringLiteral()
		}

	case KotlinParserTRIPLE_QUOTE_OPEN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2682)
			p.MultiLineStringLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILineStringLiteralContext is an interface to support dynamic dispatch.
type ILineStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QUOTE_OPEN() antlr.TerminalNode
	QUOTE_CLOSE() antlr.TerminalNode
	AllLineStringContent() []ILineStringContentContext
	LineStringContent(i int) ILineStringContentContext
	AllLineStringExpression() []ILineStringExpressionContext
	LineStringExpression(i int) ILineStringExpressionContext

	// IsLineStringLiteralContext differentiates from other interfaces.
	IsLineStringLiteralContext()
}

type LineStringLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLineStringLiteralContext() *LineStringLiteralContext {
	var p = new(LineStringLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_lineStringLiteral
	return p
}

func InitEmptyLineStringLiteralContext(p *LineStringLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_lineStringLiteral
}

func (*LineStringLiteralContext) IsLineStringLiteralContext() {}

func NewLineStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LineStringLiteralContext {
	var p = new(LineStringLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_lineStringLiteral

	return p
}

func (s *LineStringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LineStringLiteralContext) QUOTE_OPEN() antlr.TerminalNode {
	return s.GetToken(KotlinParserQUOTE_OPEN, 0)
}

func (s *LineStringLiteralContext) QUOTE_CLOSE() antlr.TerminalNode {
	return s.GetToken(KotlinParserQUOTE_CLOSE, 0)
}

func (s *LineStringLiteralContext) AllLineStringContent() []ILineStringContentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILineStringContentContext); ok {
			len++
		}
	}

	tst := make([]ILineStringContentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILineStringContentContext); ok {
			tst[i] = t.(ILineStringContentContext)
			i++
		}
	}

	return tst
}

func (s *LineStringLiteralContext) LineStringContent(i int) ILineStringContentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILineStringContentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILineStringContentContext)
}

func (s *LineStringLiteralContext) AllLineStringExpression() []ILineStringExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILineStringExpressionContext); ok {
			len++
		}
	}

	tst := make([]ILineStringExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILineStringExpressionContext); ok {
			tst[i] = t.(ILineStringExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LineStringLiteralContext) LineStringExpression(i int) ILineStringExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILineStringExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILineStringExpressionContext)
}

func (s *LineStringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LineStringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LineStringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterLineStringLiteral(s)
	}
}

func (s *LineStringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitLineStringLiteral(s)
	}
}

func (p *KotlinParser) LineStringLiteral() (localctx ILineStringLiteralContext) {
	localctx = NewLineStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, KotlinParserRULE_lineStringLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2685)
		p.Match(KotlinParserQUOTE_OPEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2690)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-161)) & ^0x3f) == 0 && ((int64(1)<<(_la-161))&15) != 0 {
		p.SetState(2688)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case KotlinParserLineStrRef, KotlinParserLineStrText, KotlinParserLineStrEscapedChar:
			{
				p.SetState(2686)
				p.LineStringContent()
			}

		case KotlinParserLineStrExprStart:
			{
				p.SetState(2687)
				p.LineStringExpression()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(2692)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2693)
		p.Match(KotlinParserQUOTE_CLOSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiLineStringLiteralContext is an interface to support dynamic dispatch.
type IMultiLineStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRIPLE_QUOTE_OPEN() antlr.TerminalNode
	TRIPLE_QUOTE_CLOSE() antlr.TerminalNode
	AllMultiLineStringContent() []IMultiLineStringContentContext
	MultiLineStringContent(i int) IMultiLineStringContentContext
	AllMultiLineStringExpression() []IMultiLineStringExpressionContext
	MultiLineStringExpression(i int) IMultiLineStringExpressionContext
	AllMultiLineStringQuote() []antlr.TerminalNode
	MultiLineStringQuote(i int) antlr.TerminalNode

	// IsMultiLineStringLiteralContext differentiates from other interfaces.
	IsMultiLineStringLiteralContext()
}

type MultiLineStringLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiLineStringLiteralContext() *MultiLineStringLiteralContext {
	var p = new(MultiLineStringLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_multiLineStringLiteral
	return p
}

func InitEmptyMultiLineStringLiteralContext(p *MultiLineStringLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_multiLineStringLiteral
}

func (*MultiLineStringLiteralContext) IsMultiLineStringLiteralContext() {}

func NewMultiLineStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiLineStringLiteralContext {
	var p = new(MultiLineStringLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_multiLineStringLiteral

	return p
}

func (s *MultiLineStringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiLineStringLiteralContext) TRIPLE_QUOTE_OPEN() antlr.TerminalNode {
	return s.GetToken(KotlinParserTRIPLE_QUOTE_OPEN, 0)
}

func (s *MultiLineStringLiteralContext) TRIPLE_QUOTE_CLOSE() antlr.TerminalNode {
	return s.GetToken(KotlinParserTRIPLE_QUOTE_CLOSE, 0)
}

func (s *MultiLineStringLiteralContext) AllMultiLineStringContent() []IMultiLineStringContentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultiLineStringContentContext); ok {
			len++
		}
	}

	tst := make([]IMultiLineStringContentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultiLineStringContentContext); ok {
			tst[i] = t.(IMultiLineStringContentContext)
			i++
		}
	}

	return tst
}

func (s *MultiLineStringLiteralContext) MultiLineStringContent(i int) IMultiLineStringContentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiLineStringContentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiLineStringContentContext)
}

func (s *MultiLineStringLiteralContext) AllMultiLineStringExpression() []IMultiLineStringExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultiLineStringExpressionContext); ok {
			len++
		}
	}

	tst := make([]IMultiLineStringExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultiLineStringExpressionContext); ok {
			tst[i] = t.(IMultiLineStringExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MultiLineStringLiteralContext) MultiLineStringExpression(i int) IMultiLineStringExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiLineStringExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiLineStringExpressionContext)
}

func (s *MultiLineStringLiteralContext) AllMultiLineStringQuote() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserMultiLineStringQuote)
}

func (s *MultiLineStringLiteralContext) MultiLineStringQuote(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserMultiLineStringQuote, i)
}

func (s *MultiLineStringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiLineStringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiLineStringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterMultiLineStringLiteral(s)
	}
}

func (s *MultiLineStringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitMultiLineStringLiteral(s)
	}
}

func (p *KotlinParser) MultiLineStringLiteral() (localctx IMultiLineStringLiteralContext) {
	localctx = NewMultiLineStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, KotlinParserRULE_multiLineStringLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2695)
		p.Match(KotlinParserTRIPLE_QUOTE_OPEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2701)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-166)) & ^0x3f) == 0 && ((int64(1)<<(_la-166))&15) != 0 {
		p.SetState(2699)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 407, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2696)
				p.MultiLineStringContent()
			}

		case 2:
			{
				p.SetState(2697)
				p.MultiLineStringExpression()
			}

		case 3:
			{
				p.SetState(2698)
				p.Match(KotlinParserMultiLineStringQuote)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

		p.SetState(2703)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2704)
		p.Match(KotlinParserTRIPLE_QUOTE_CLOSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILineStringContentContext is an interface to support dynamic dispatch.
type ILineStringContentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LineStrText() antlr.TerminalNode
	LineStrEscapedChar() antlr.TerminalNode
	LineStrRef() antlr.TerminalNode

	// IsLineStringContentContext differentiates from other interfaces.
	IsLineStringContentContext()
}

type LineStringContentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLineStringContentContext() *LineStringContentContext {
	var p = new(LineStringContentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_lineStringContent
	return p
}

func InitEmptyLineStringContentContext(p *LineStringContentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_lineStringContent
}

func (*LineStringContentContext) IsLineStringContentContext() {}

func NewLineStringContentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LineStringContentContext {
	var p = new(LineStringContentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_lineStringContent

	return p
}

func (s *LineStringContentContext) GetParser() antlr.Parser { return s.parser }

func (s *LineStringContentContext) LineStrText() antlr.TerminalNode {
	return s.GetToken(KotlinParserLineStrText, 0)
}

func (s *LineStringContentContext) LineStrEscapedChar() antlr.TerminalNode {
	return s.GetToken(KotlinParserLineStrEscapedChar, 0)
}

func (s *LineStringContentContext) LineStrRef() antlr.TerminalNode {
	return s.GetToken(KotlinParserLineStrRef, 0)
}

func (s *LineStringContentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LineStringContentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LineStringContentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterLineStringContent(s)
	}
}

func (s *LineStringContentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitLineStringContent(s)
	}
}

func (p *KotlinParser) LineStringContent() (localctx ILineStringContentContext) {
	localctx = NewLineStringContentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, KotlinParserRULE_lineStringContent)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2706)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-161)) & ^0x3f) == 0 && ((int64(1)<<(_la-161))&7) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILineStringExpressionContext is an interface to support dynamic dispatch.
type ILineStringExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LineStrExprStart() antlr.TerminalNode
	Expression() IExpressionContext
	RCURL() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsLineStringExpressionContext differentiates from other interfaces.
	IsLineStringExpressionContext()
}

type LineStringExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLineStringExpressionContext() *LineStringExpressionContext {
	var p = new(LineStringExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_lineStringExpression
	return p
}

func InitEmptyLineStringExpressionContext(p *LineStringExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_lineStringExpression
}

func (*LineStringExpressionContext) IsLineStringExpressionContext() {}

func NewLineStringExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LineStringExpressionContext {
	var p = new(LineStringExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_lineStringExpression

	return p
}

func (s *LineStringExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LineStringExpressionContext) LineStrExprStart() antlr.TerminalNode {
	return s.GetToken(KotlinParserLineStrExprStart, 0)
}

func (s *LineStringExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LineStringExpressionContext) RCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserRCURL, 0)
}

func (s *LineStringExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *LineStringExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *LineStringExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LineStringExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LineStringExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterLineStringExpression(s)
	}
}

func (s *LineStringExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitLineStringExpression(s)
	}
}

func (p *KotlinParser) LineStringExpression() (localctx ILineStringExpressionContext) {
	localctx = NewLineStringExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, KotlinParserRULE_lineStringExpression)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2708)
		p.Match(KotlinParserLineStrExprStart)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2712)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 409, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2709)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2714)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 409, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(2715)
		p.Expression()
	}
	p.SetState(2719)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2716)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(2721)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2722)
		p.Match(KotlinParserRCURL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiLineStringContentContext is an interface to support dynamic dispatch.
type IMultiLineStringContentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MultiLineStrText() antlr.TerminalNode
	MultiLineStringQuote() antlr.TerminalNode
	MultiLineStrRef() antlr.TerminalNode

	// IsMultiLineStringContentContext differentiates from other interfaces.
	IsMultiLineStringContentContext()
}

type MultiLineStringContentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiLineStringContentContext() *MultiLineStringContentContext {
	var p = new(MultiLineStringContentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_multiLineStringContent
	return p
}

func InitEmptyMultiLineStringContentContext(p *MultiLineStringContentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_multiLineStringContent
}

func (*MultiLineStringContentContext) IsMultiLineStringContentContext() {}

func NewMultiLineStringContentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiLineStringContentContext {
	var p = new(MultiLineStringContentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_multiLineStringContent

	return p
}

func (s *MultiLineStringContentContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiLineStringContentContext) MultiLineStrText() antlr.TerminalNode {
	return s.GetToken(KotlinParserMultiLineStrText, 0)
}

func (s *MultiLineStringContentContext) MultiLineStringQuote() antlr.TerminalNode {
	return s.GetToken(KotlinParserMultiLineStringQuote, 0)
}

func (s *MultiLineStringContentContext) MultiLineStrRef() antlr.TerminalNode {
	return s.GetToken(KotlinParserMultiLineStrRef, 0)
}

func (s *MultiLineStringContentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiLineStringContentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiLineStringContentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterMultiLineStringContent(s)
	}
}

func (s *MultiLineStringContentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitMultiLineStringContent(s)
	}
}

func (p *KotlinParser) MultiLineStringContent() (localctx IMultiLineStringContentContext) {
	localctx = NewMultiLineStringContentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, KotlinParserRULE_multiLineStringContent)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2724)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-166)) & ^0x3f) == 0 && ((int64(1)<<(_la-166))&7) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiLineStringExpressionContext is an interface to support dynamic dispatch.
type IMultiLineStringExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MultiLineStrExprStart() antlr.TerminalNode
	Expression() IExpressionContext
	RCURL() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsMultiLineStringExpressionContext differentiates from other interfaces.
	IsMultiLineStringExpressionContext()
}

type MultiLineStringExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiLineStringExpressionContext() *MultiLineStringExpressionContext {
	var p = new(MultiLineStringExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_multiLineStringExpression
	return p
}

func InitEmptyMultiLineStringExpressionContext(p *MultiLineStringExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_multiLineStringExpression
}

func (*MultiLineStringExpressionContext) IsMultiLineStringExpressionContext() {}

func NewMultiLineStringExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiLineStringExpressionContext {
	var p = new(MultiLineStringExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_multiLineStringExpression

	return p
}

func (s *MultiLineStringExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiLineStringExpressionContext) MultiLineStrExprStart() antlr.TerminalNode {
	return s.GetToken(KotlinParserMultiLineStrExprStart, 0)
}

func (s *MultiLineStringExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MultiLineStringExpressionContext) RCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserRCURL, 0)
}

func (s *MultiLineStringExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *MultiLineStringExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *MultiLineStringExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiLineStringExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiLineStringExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterMultiLineStringExpression(s)
	}
}

func (s *MultiLineStringExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitMultiLineStringExpression(s)
	}
}

func (p *KotlinParser) MultiLineStringExpression() (localctx IMultiLineStringExpressionContext) {
	localctx = NewMultiLineStringExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, KotlinParserRULE_multiLineStringExpression)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2726)
		p.Match(KotlinParserMultiLineStrExprStart)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2730)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 411, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2727)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2732)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 411, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(2733)
		p.Expression()
	}
	p.SetState(2737)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2734)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(2739)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2740)
		p.Match(KotlinParserRCURL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdaLiteralContext is an interface to support dynamic dispatch.
type ILambdaLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LCURL() antlr.TerminalNode
	Statements() IStatementsContext
	RCURL() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	ARROW() antlr.TerminalNode
	LambdaParameters() ILambdaParametersContext

	// IsLambdaLiteralContext differentiates from other interfaces.
	IsLambdaLiteralContext()
}

type LambdaLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaLiteralContext() *LambdaLiteralContext {
	var p = new(LambdaLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_lambdaLiteral
	return p
}

func InitEmptyLambdaLiteralContext(p *LambdaLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_lambdaLiteral
}

func (*LambdaLiteralContext) IsLambdaLiteralContext() {}

func NewLambdaLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaLiteralContext {
	var p = new(LambdaLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_lambdaLiteral

	return p
}

func (s *LambdaLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaLiteralContext) LCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserLCURL, 0)
}

func (s *LambdaLiteralContext) Statements() IStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementsContext)
}

func (s *LambdaLiteralContext) RCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserRCURL, 0)
}

func (s *LambdaLiteralContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *LambdaLiteralContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *LambdaLiteralContext) ARROW() antlr.TerminalNode {
	return s.GetToken(KotlinParserARROW, 0)
}

func (s *LambdaLiteralContext) LambdaParameters() ILambdaParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaParametersContext)
}

func (s *LambdaLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterLambdaLiteral(s)
	}
}

func (s *LambdaLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitLambdaLiteral(s)
	}
}

func (p *KotlinParser) LambdaLiteral() (localctx ILambdaLiteralContext) {
	localctx = NewLambdaLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, KotlinParserRULE_lambdaLiteral)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2742)
		p.Match(KotlinParserLCURL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2746)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 413, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2743)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2748)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 413, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2765)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 417, p.GetParserRuleContext()) == 1 {
		p.SetState(2750)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 414, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2749)
				p.LambdaParameters()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2755)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2752)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(2757)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2758)
			p.Match(KotlinParserARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2762)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 416, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2759)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(2764)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 416, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2767)
		p.Statements()
	}
	p.SetState(2771)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2768)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(2773)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2774)
		p.Match(KotlinParserRCURL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdaParametersContext is an interface to support dynamic dispatch.
type ILambdaParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLambdaParameter() []ILambdaParameterContext
	LambdaParameter(i int) ILambdaParameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsLambdaParametersContext differentiates from other interfaces.
	IsLambdaParametersContext()
}

type LambdaParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaParametersContext() *LambdaParametersContext {
	var p = new(LambdaParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_lambdaParameters
	return p
}

func InitEmptyLambdaParametersContext(p *LambdaParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_lambdaParameters
}

func (*LambdaParametersContext) IsLambdaParametersContext() {}

func NewLambdaParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaParametersContext {
	var p = new(LambdaParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_lambdaParameters

	return p
}

func (s *LambdaParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaParametersContext) AllLambdaParameter() []ILambdaParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILambdaParameterContext); ok {
			len++
		}
	}

	tst := make([]ILambdaParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILambdaParameterContext); ok {
			tst[i] = t.(ILambdaParameterContext)
			i++
		}
	}

	return tst
}

func (s *LambdaParametersContext) LambdaParameter(i int) ILambdaParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaParameterContext)
}

func (s *LambdaParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *LambdaParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *LambdaParametersContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *LambdaParametersContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *LambdaParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterLambdaParameters(s)
	}
}

func (s *LambdaParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitLambdaParameters(s)
	}
}

func (p *KotlinParser) LambdaParameters() (localctx ILambdaParametersContext) {
	localctx = NewLambdaParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, KotlinParserRULE_lambdaParameters)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2776)
		p.LambdaParameter()
	}
	p.SetState(2793)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 421, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2780)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2777)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(2782)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2783)
				p.Match(KotlinParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2787)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 420, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(2784)
						p.Match(KotlinParserNL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				p.SetState(2789)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 420, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			{
				p.SetState(2790)
				p.LambdaParameter()
			}

		}
		p.SetState(2795)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 421, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2803)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 423, p.GetParserRuleContext()) == 1 {
		p.SetState(2799)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2796)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(2801)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2802)
			p.Match(KotlinParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdaParameterContext is an interface to support dynamic dispatch.
type ILambdaParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VariableDeclaration() IVariableDeclarationContext
	MultiVariableDeclaration() IMultiVariableDeclarationContext
	COLON() antlr.TerminalNode
	Type_() ITypeContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsLambdaParameterContext differentiates from other interfaces.
	IsLambdaParameterContext()
}

type LambdaParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaParameterContext() *LambdaParameterContext {
	var p = new(LambdaParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_lambdaParameter
	return p
}

func InitEmptyLambdaParameterContext(p *LambdaParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_lambdaParameter
}

func (*LambdaParameterContext) IsLambdaParameterContext() {}

func NewLambdaParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaParameterContext {
	var p = new(LambdaParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_lambdaParameter

	return p
}

func (s *LambdaParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaParameterContext) VariableDeclaration() IVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *LambdaParameterContext) MultiVariableDeclaration() IMultiVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiVariableDeclarationContext)
}

func (s *LambdaParameterContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *LambdaParameterContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *LambdaParameterContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *LambdaParameterContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *LambdaParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterLambdaParameter(s)
	}
}

func (s *LambdaParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitLambdaParameter(s)
	}
}

func (p *KotlinParser) LambdaParameter() (localctx ILambdaParameterContext) {
	localctx = NewLambdaParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, KotlinParserRULE_lambdaParameter)
	var _la int

	p.SetState(2823)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KotlinParserNL, KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS, KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2805)
			p.VariableDeclaration()
		}

	case KotlinParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2806)
			p.MultiVariableDeclaration()
		}
		p.SetState(2821)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 426, p.GetParserRuleContext()) == 1 {
			p.SetState(2810)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2807)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(2812)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2813)
				p.Match(KotlinParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2817)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2814)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(2819)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2820)
				p.Type_()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnonymousFunctionContext is an interface to support dynamic dispatch.
type IAnonymousFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FUN() antlr.TerminalNode
	ParametersWithOptionalType() IParametersWithOptionalTypeContext
	SUSPEND() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	AllType_() []ITypeContext
	Type_(i int) ITypeContext
	DOT() antlr.TerminalNode
	COLON() antlr.TerminalNode
	TypeConstraints() ITypeConstraintsContext
	FunctionBody() IFunctionBodyContext

	// IsAnonymousFunctionContext differentiates from other interfaces.
	IsAnonymousFunctionContext()
}

type AnonymousFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnonymousFunctionContext() *AnonymousFunctionContext {
	var p = new(AnonymousFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_anonymousFunction
	return p
}

func InitEmptyAnonymousFunctionContext(p *AnonymousFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_anonymousFunction
}

func (*AnonymousFunctionContext) IsAnonymousFunctionContext() {}

func NewAnonymousFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnonymousFunctionContext {
	var p = new(AnonymousFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_anonymousFunction

	return p
}

func (s *AnonymousFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *AnonymousFunctionContext) FUN() antlr.TerminalNode {
	return s.GetToken(KotlinParserFUN, 0)
}

func (s *AnonymousFunctionContext) ParametersWithOptionalType() IParametersWithOptionalTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersWithOptionalTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersWithOptionalTypeContext)
}

func (s *AnonymousFunctionContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(KotlinParserSUSPEND, 0)
}

func (s *AnonymousFunctionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *AnonymousFunctionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *AnonymousFunctionContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *AnonymousFunctionContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *AnonymousFunctionContext) DOT() antlr.TerminalNode {
	return s.GetToken(KotlinParserDOT, 0)
}

func (s *AnonymousFunctionContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *AnonymousFunctionContext) TypeConstraints() ITypeConstraintsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeConstraintsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeConstraintsContext)
}

func (s *AnonymousFunctionContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *AnonymousFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnonymousFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnonymousFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAnonymousFunction(s)
	}
}

func (s *AnonymousFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAnonymousFunction(s)
	}
}

func (p *KotlinParser) AnonymousFunction() (localctx IAnonymousFunctionContext) {
	localctx = NewAnonymousFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, KotlinParserRULE_anonymousFunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2826)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserSUSPEND {
		{
			p.SetState(2825)
			p.Match(KotlinParserSUSPEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(2831)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2828)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(2833)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2834)
		p.Match(KotlinParserFUN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2850)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 432, p.GetParserRuleContext()) == 1 {
		p.SetState(2838)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2835)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(2840)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2841)
			p.Type_()
		}
		p.SetState(2845)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2842)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(2847)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2848)
			p.Match(KotlinParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2855)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2852)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(2857)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2858)
		p.ParametersWithOptionalType()
	}
	p.SetState(2873)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 436, p.GetParserRuleContext()) == 1 {
		p.SetState(2862)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2859)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(2864)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2865)
			p.Match(KotlinParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2869)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2866)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(2871)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2872)
			p.Type_()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2882)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 438, p.GetParserRuleContext()) == 1 {
		p.SetState(2878)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2875)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(2880)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2881)
			p.TypeConstraints()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2891)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 440, p.GetParserRuleContext()) == 1 {
		p.SetState(2887)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2884)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(2889)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2890)
			p.FunctionBody()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionLiteralContext is an interface to support dynamic dispatch.
type IFunctionLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LambdaLiteral() ILambdaLiteralContext
	AnonymousFunction() IAnonymousFunctionContext

	// IsFunctionLiteralContext differentiates from other interfaces.
	IsFunctionLiteralContext()
}

type FunctionLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionLiteralContext() *FunctionLiteralContext {
	var p = new(FunctionLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_functionLiteral
	return p
}

func InitEmptyFunctionLiteralContext(p *FunctionLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_functionLiteral
}

func (*FunctionLiteralContext) IsFunctionLiteralContext() {}

func NewFunctionLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionLiteralContext {
	var p = new(FunctionLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_functionLiteral

	return p
}

func (s *FunctionLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionLiteralContext) LambdaLiteral() ILambdaLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaLiteralContext)
}

func (s *FunctionLiteralContext) AnonymousFunction() IAnonymousFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnonymousFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnonymousFunctionContext)
}

func (s *FunctionLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFunctionLiteral(s)
	}
}

func (s *FunctionLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFunctionLiteral(s)
	}
}

func (p *KotlinParser) FunctionLiteral() (localctx IFunctionLiteralContext) {
	localctx = NewFunctionLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, KotlinParserRULE_functionLiteral)
	p.SetState(2895)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KotlinParserLCURL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2893)
			p.LambdaLiteral()
		}

	case KotlinParserNL, KotlinParserFUN, KotlinParserSUSPEND:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2894)
			p.AnonymousFunction()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectLiteralContext is an interface to support dynamic dispatch.
type IObjectLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT() antlr.TerminalNode
	DATA() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	COLON() antlr.TerminalNode
	DelegationSpecifiers() IDelegationSpecifiersContext
	ClassBody() IClassBodyContext

	// IsObjectLiteralContext differentiates from other interfaces.
	IsObjectLiteralContext()
}

type ObjectLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectLiteralContext() *ObjectLiteralContext {
	var p = new(ObjectLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_objectLiteral
	return p
}

func InitEmptyObjectLiteralContext(p *ObjectLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_objectLiteral
}

func (*ObjectLiteralContext) IsObjectLiteralContext() {}

func NewObjectLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectLiteralContext {
	var p = new(ObjectLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_objectLiteral

	return p
}

func (s *ObjectLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectLiteralContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(KotlinParserOBJECT, 0)
}

func (s *ObjectLiteralContext) DATA() antlr.TerminalNode {
	return s.GetToken(KotlinParserDATA, 0)
}

func (s *ObjectLiteralContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ObjectLiteralContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ObjectLiteralContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *ObjectLiteralContext) DelegationSpecifiers() IDelegationSpecifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelegationSpecifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelegationSpecifiersContext)
}

func (s *ObjectLiteralContext) ClassBody() IClassBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *ObjectLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterObjectLiteral(s)
	}
}

func (s *ObjectLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitObjectLiteral(s)
	}
}

func (p *KotlinParser) ObjectLiteral() (localctx IObjectLiteralContext) {
	localctx = NewObjectLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, KotlinParserRULE_objectLiteral)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2898)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserDATA {
		{
			p.SetState(2897)
			p.Match(KotlinParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(2903)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2900)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(2905)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2906)
		p.Match(KotlinParserOBJECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2927)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 447, p.GetParserRuleContext()) == 1 {
		p.SetState(2910)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2907)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(2912)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2913)
			p.Match(KotlinParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2917)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 445, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2914)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(2919)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 445, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(2920)
			p.DelegationSpecifiers()
		}
		p.SetState(2924)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 446, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2921)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(2926)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 446, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2936)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 449, p.GetParserRuleContext()) == 1 {
		p.SetState(2932)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(2929)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(2934)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2935)
			p.ClassBody()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IThisExpressionContext is an interface to support dynamic dispatch.
type IThisExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	THIS() antlr.TerminalNode
	THIS_AT() antlr.TerminalNode

	// IsThisExpressionContext differentiates from other interfaces.
	IsThisExpressionContext()
}

type ThisExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThisExpressionContext() *ThisExpressionContext {
	var p = new(ThisExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_thisExpression
	return p
}

func InitEmptyThisExpressionContext(p *ThisExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_thisExpression
}

func (*ThisExpressionContext) IsThisExpressionContext() {}

func NewThisExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThisExpressionContext {
	var p = new(ThisExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_thisExpression

	return p
}

func (s *ThisExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ThisExpressionContext) THIS() antlr.TerminalNode {
	return s.GetToken(KotlinParserTHIS, 0)
}

func (s *ThisExpressionContext) THIS_AT() antlr.TerminalNode {
	return s.GetToken(KotlinParserTHIS_AT, 0)
}

func (s *ThisExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThisExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThisExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterThisExpression(s)
	}
}

func (s *ThisExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitThisExpression(s)
	}
}

func (p *KotlinParser) ThisExpression() (localctx IThisExpressionContext) {
	localctx = NewThisExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, KotlinParserRULE_thisExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2938)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserTHIS_AT || _la == KotlinParserTHIS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISuperExpressionContext is an interface to support dynamic dispatch.
type ISuperExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUPER() antlr.TerminalNode
	LANGLE() antlr.TerminalNode
	Type_() ITypeContext
	RANGLE() antlr.TerminalNode
	AT_NO_WS() antlr.TerminalNode
	SimpleIdentifier() ISimpleIdentifierContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	SUPER_AT() antlr.TerminalNode

	// IsSuperExpressionContext differentiates from other interfaces.
	IsSuperExpressionContext()
}

type SuperExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySuperExpressionContext() *SuperExpressionContext {
	var p = new(SuperExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_superExpression
	return p
}

func InitEmptySuperExpressionContext(p *SuperExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_superExpression
}

func (*SuperExpressionContext) IsSuperExpressionContext() {}

func NewSuperExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SuperExpressionContext {
	var p = new(SuperExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_superExpression

	return p
}

func (s *SuperExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SuperExpressionContext) SUPER() antlr.TerminalNode {
	return s.GetToken(KotlinParserSUPER, 0)
}

func (s *SuperExpressionContext) LANGLE() antlr.TerminalNode {
	return s.GetToken(KotlinParserLANGLE, 0)
}

func (s *SuperExpressionContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *SuperExpressionContext) RANGLE() antlr.TerminalNode {
	return s.GetToken(KotlinParserRANGLE, 0)
}

func (s *SuperExpressionContext) AT_NO_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAT_NO_WS, 0)
}

func (s *SuperExpressionContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *SuperExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *SuperExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *SuperExpressionContext) SUPER_AT() antlr.TerminalNode {
	return s.GetToken(KotlinParserSUPER_AT, 0)
}

func (s *SuperExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuperExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SuperExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterSuperExpression(s)
	}
}

func (s *SuperExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitSuperExpression(s)
	}
}

func (p *KotlinParser) SuperExpression() (localctx ISuperExpressionContext) {
	localctx = NewSuperExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, KotlinParserRULE_superExpression)
	var _la int

	p.SetState(2964)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KotlinParserSUPER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2940)
			p.Match(KotlinParserSUPER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2957)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 452, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2941)
				p.Match(KotlinParserLANGLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2945)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2942)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(2947)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2948)
				p.Type_()
			}
			p.SetState(2952)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(2949)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(2954)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2955)
				p.Match(KotlinParserRANGLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2961)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 453, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2959)
				p.Match(KotlinParserAT_NO_WS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2960)
				p.SimpleIdentifier()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case KotlinParserSUPER_AT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2963)
			p.Match(KotlinParserSUPER_AT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfExpressionContext is an interface to support dynamic dispatch.
type IIfExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	AllControlStructureBody() []IControlStructureBodyContext
	ControlStructureBody(i int) IControlStructureBodyContext
	ELSE() antlr.TerminalNode
	AllSEMICOLON() []antlr.TerminalNode
	SEMICOLON(i int) antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsIfExpressionContext differentiates from other interfaces.
	IsIfExpressionContext()
}

type IfExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfExpressionContext() *IfExpressionContext {
	var p = new(IfExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_ifExpression
	return p
}

func InitEmptyIfExpressionContext(p *IfExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_ifExpression
}

func (*IfExpressionContext) IsIfExpressionContext() {}

func NewIfExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfExpressionContext {
	var p = new(IfExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_ifExpression

	return p
}

func (s *IfExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *IfExpressionContext) IF() antlr.TerminalNode {
	return s.GetToken(KotlinParserIF, 0)
}

func (s *IfExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *IfExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *IfExpressionContext) AllControlStructureBody() []IControlStructureBodyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IControlStructureBodyContext); ok {
			len++
		}
	}

	tst := make([]IControlStructureBodyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IControlStructureBodyContext); ok {
			tst[i] = t.(IControlStructureBodyContext)
			i++
		}
	}

	return tst
}

func (s *IfExpressionContext) ControlStructureBody(i int) IControlStructureBodyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IControlStructureBodyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IControlStructureBodyContext)
}

func (s *IfExpressionContext) ELSE() antlr.TerminalNode {
	return s.GetToken(KotlinParserELSE, 0)
}

func (s *IfExpressionContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserSEMICOLON)
}

func (s *IfExpressionContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserSEMICOLON, i)
}

func (s *IfExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *IfExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *IfExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterIfExpression(s)
	}
}

func (s *IfExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitIfExpression(s)
	}
}

func (p *KotlinParser) IfExpression() (localctx IIfExpressionContext) {
	localctx = NewIfExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, KotlinParserRULE_ifExpression)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2966)
		p.Match(KotlinParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2970)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2967)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(2972)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2973)
		p.Match(KotlinParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2977)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 456, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2974)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2979)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 456, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(2980)
		p.Expression()
	}
	p.SetState(2984)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(2981)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(2986)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2987)
		p.Match(KotlinParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2991)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 458, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2988)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2993)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 458, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(3025)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 465, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2994)
			p.ControlStructureBody()
		}

	case 2:
		p.SetState(2996)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 459, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2995)
				p.ControlStructureBody()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3001)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 460, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2998)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(3003)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 460, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(3005)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KotlinParserSEMICOLON {
			{
				p.SetState(3004)
				p.Match(KotlinParserSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3010)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3007)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(3012)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3013)
			p.Match(KotlinParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3017)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 463, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3014)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(3019)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 463, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(3022)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case KotlinParserNL, KotlinParserLPAREN, KotlinParserLSQUARE, KotlinParserLCURL, KotlinParserADD, KotlinParserSUB, KotlinParserINCR, KotlinParserDECR, KotlinParserEXCL_WS, KotlinParserEXCL_NO_WS, KotlinParserCOLONCOLON, KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS, KotlinParserRETURN_AT, KotlinParserCONTINUE_AT, KotlinParserBREAK_AT, KotlinParserTHIS_AT, KotlinParserSUPER_AT, KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCLASS, KotlinParserINTERFACE, KotlinParserFUN, KotlinParserOBJECT, KotlinParserVAL, KotlinParserVAR, KotlinParserTYPE_ALIAS, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserTHIS, KotlinParserSUPER, KotlinParserWHERE, KotlinParserIF, KotlinParserWHEN, KotlinParserTRY, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserFOR, KotlinParserDO, KotlinParserWHILE, KotlinParserTHROW, KotlinParserRETURN, KotlinParserCONTINUE, KotlinParserBREAK, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserRealLiteral, KotlinParserIntegerLiteral, KotlinParserHexLiteral, KotlinParserBinLiteral, KotlinParserUnsignedLiteral, KotlinParserLongLiteral, KotlinParserBooleanLiteral, KotlinParserNullLiteral, KotlinParserCharacterLiteral, KotlinParserIdentifier, KotlinParserQUOTE_OPEN, KotlinParserTRIPLE_QUOTE_OPEN:
			{
				p.SetState(3020)
				p.ControlStructureBody()
			}

		case KotlinParserSEMICOLON:
			{
				p.SetState(3021)
				p.Match(KotlinParserSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 3:
		{
			p.SetState(3024)
			p.Match(KotlinParserSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhenSubjectContext is an interface to support dynamic dispatch.
type IWhenSubjectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	VAL() antlr.TerminalNode
	VariableDeclaration() IVariableDeclarationContext
	ASSIGNMENT() antlr.TerminalNode
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsWhenSubjectContext differentiates from other interfaces.
	IsWhenSubjectContext()
}

type WhenSubjectContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenSubjectContext() *WhenSubjectContext {
	var p = new(WhenSubjectContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_whenSubject
	return p
}

func InitEmptyWhenSubjectContext(p *WhenSubjectContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_whenSubject
}

func (*WhenSubjectContext) IsWhenSubjectContext() {}

func NewWhenSubjectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenSubjectContext {
	var p = new(WhenSubjectContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_whenSubject

	return p
}

func (s *WhenSubjectContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenSubjectContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *WhenSubjectContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenSubjectContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *WhenSubjectContext) VAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserVAL, 0)
}

func (s *WhenSubjectContext) VariableDeclaration() IVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *WhenSubjectContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserASSIGNMENT, 0)
}

func (s *WhenSubjectContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *WhenSubjectContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *WhenSubjectContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *WhenSubjectContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *WhenSubjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenSubjectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenSubjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterWhenSubject(s)
	}
}

func (s *WhenSubjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitWhenSubject(s)
	}
}

func (p *KotlinParser) WhenSubject() (localctx IWhenSubjectContext) {
	localctx = NewWhenSubjectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, KotlinParserRULE_whenSubject)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3027)
		p.Match(KotlinParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3061)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 471, p.GetParserRuleContext()) == 1 {
		p.SetState(3031)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS {
			{
				p.SetState(3028)
				p.Annotation()
			}

			p.SetState(3033)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(3037)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3034)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(3039)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3040)
			p.Match(KotlinParserVAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3044)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 468, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3041)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(3046)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 468, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(3047)
			p.VariableDeclaration()
		}
		p.SetState(3051)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3048)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(3053)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3054)
			p.Match(KotlinParserASSIGNMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3058)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 470, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3055)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(3060)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 470, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3063)
		p.Expression()
	}
	{
		p.SetState(3064)
		p.Match(KotlinParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhenExpressionContext is an interface to support dynamic dispatch.
type IWhenExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHEN() antlr.TerminalNode
	LCURL() antlr.TerminalNode
	RCURL() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	WhenSubject() IWhenSubjectContext
	AllWhenEntry() []IWhenEntryContext
	WhenEntry(i int) IWhenEntryContext

	// IsWhenExpressionContext differentiates from other interfaces.
	IsWhenExpressionContext()
}

type WhenExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenExpressionContext() *WhenExpressionContext {
	var p = new(WhenExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_whenExpression
	return p
}

func InitEmptyWhenExpressionContext(p *WhenExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_whenExpression
}

func (*WhenExpressionContext) IsWhenExpressionContext() {}

func NewWhenExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenExpressionContext {
	var p = new(WhenExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_whenExpression

	return p
}

func (s *WhenExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenExpressionContext) WHEN() antlr.TerminalNode {
	return s.GetToken(KotlinParserWHEN, 0)
}

func (s *WhenExpressionContext) LCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserLCURL, 0)
}

func (s *WhenExpressionContext) RCURL() antlr.TerminalNode {
	return s.GetToken(KotlinParserRCURL, 0)
}

func (s *WhenExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *WhenExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *WhenExpressionContext) WhenSubject() IWhenSubjectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenSubjectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenSubjectContext)
}

func (s *WhenExpressionContext) AllWhenEntry() []IWhenEntryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenEntryContext); ok {
			len++
		}
	}

	tst := make([]IWhenEntryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenEntryContext); ok {
			tst[i] = t.(IWhenEntryContext)
			i++
		}
	}

	return tst
}

func (s *WhenExpressionContext) WhenEntry(i int) IWhenEntryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenEntryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenEntryContext)
}

func (s *WhenExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterWhenExpression(s)
	}
}

func (s *WhenExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitWhenExpression(s)
	}
}

func (p *KotlinParser) WhenExpression() (localctx IWhenExpressionContext) {
	localctx = NewWhenExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, KotlinParserRULE_whenExpression)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3066)
		p.Match(KotlinParserWHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3070)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 472, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3067)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3072)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 472, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(3074)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserLPAREN {
		{
			p.SetState(3073)
			p.WhenSubject()
		}

	}
	p.SetState(3079)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(3076)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(3081)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3082)
		p.Match(KotlinParserLCURL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3086)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 475, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3083)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3088)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 475, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(3098)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 477, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3089)
				p.WhenEntry()
			}
			p.SetState(3093)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 476, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(3090)
						p.Match(KotlinParserNL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				p.SetState(3095)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 476, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}

		}
		p.SetState(3100)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 477, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(3104)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(3101)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(3106)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3107)
		p.Match(KotlinParserRCURL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhenEntryContext is an interface to support dynamic dispatch.
type IWhenEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllWhenCondition() []IWhenConditionContext
	WhenCondition(i int) IWhenConditionContext
	ARROW() antlr.TerminalNode
	ControlStructureBody() IControlStructureBodyContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	Semi() ISemiContext
	ELSE() antlr.TerminalNode

	// IsWhenEntryContext differentiates from other interfaces.
	IsWhenEntryContext()
}

type WhenEntryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenEntryContext() *WhenEntryContext {
	var p = new(WhenEntryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_whenEntry
	return p
}

func InitEmptyWhenEntryContext(p *WhenEntryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_whenEntry
}

func (*WhenEntryContext) IsWhenEntryContext() {}

func NewWhenEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenEntryContext {
	var p = new(WhenEntryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_whenEntry

	return p
}

func (s *WhenEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenEntryContext) AllWhenCondition() []IWhenConditionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenConditionContext); ok {
			len++
		}
	}

	tst := make([]IWhenConditionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenConditionContext); ok {
			tst[i] = t.(IWhenConditionContext)
			i++
		}
	}

	return tst
}

func (s *WhenEntryContext) WhenCondition(i int) IWhenConditionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenConditionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenConditionContext)
}

func (s *WhenEntryContext) ARROW() antlr.TerminalNode {
	return s.GetToken(KotlinParserARROW, 0)
}

func (s *WhenEntryContext) ControlStructureBody() IControlStructureBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IControlStructureBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IControlStructureBodyContext)
}

func (s *WhenEntryContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserCOMMA)
}

func (s *WhenEntryContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, i)
}

func (s *WhenEntryContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *WhenEntryContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *WhenEntryContext) Semi() ISemiContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISemiContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISemiContext)
}

func (s *WhenEntryContext) ELSE() antlr.TerminalNode {
	return s.GetToken(KotlinParserELSE, 0)
}

func (s *WhenEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterWhenEntry(s)
	}
}

func (s *WhenEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitWhenEntry(s)
	}
}

func (p *KotlinParser) WhenEntry() (localctx IWhenEntryContext) {
	localctx = NewWhenEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, KotlinParserRULE_whenEntry)
	var _la int

	var _alt int

	p.SetState(3173)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KotlinParserNL, KotlinParserLPAREN, KotlinParserLSQUARE, KotlinParserLCURL, KotlinParserADD, KotlinParserSUB, KotlinParserINCR, KotlinParserDECR, KotlinParserEXCL_WS, KotlinParserEXCL_NO_WS, KotlinParserCOLONCOLON, KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS, KotlinParserRETURN_AT, KotlinParserCONTINUE_AT, KotlinParserBREAK_AT, KotlinParserTHIS_AT, KotlinParserSUPER_AT, KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserFUN, KotlinParserOBJECT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserTHIS, KotlinParserSUPER, KotlinParserWHERE, KotlinParserIF, KotlinParserWHEN, KotlinParserTRY, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserTHROW, KotlinParserRETURN, KotlinParserCONTINUE, KotlinParserBREAK, KotlinParserIS, KotlinParserIN, KotlinParserNOT_IS, KotlinParserNOT_IN, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserRealLiteral, KotlinParserIntegerLiteral, KotlinParserHexLiteral, KotlinParserBinLiteral, KotlinParserUnsignedLiteral, KotlinParserLongLiteral, KotlinParserBooleanLiteral, KotlinParserNullLiteral, KotlinParserCharacterLiteral, KotlinParserIdentifier, KotlinParserQUOTE_OPEN, KotlinParserTRIPLE_QUOTE_OPEN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3109)
			p.WhenCondition()
		}
		p.SetState(3126)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 481, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(3113)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == KotlinParserNL {
					{
						p.SetState(3110)
						p.Match(KotlinParserNL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

					p.SetState(3115)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(3116)
					p.Match(KotlinParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(3120)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 480, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(3117)
							p.Match(KotlinParserNL)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}

					}
					p.SetState(3122)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 480, p.GetParserRuleContext())
					if p.HasError() {
						goto errorExit
					}
				}
				{
					p.SetState(3123)
					p.WhenCondition()
				}

			}
			p.SetState(3128)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 481, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(3136)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 483, p.GetParserRuleContext()) == 1 {
			p.SetState(3132)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(3129)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(3134)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(3135)
				p.Match(KotlinParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3141)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3138)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(3143)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3144)
			p.Match(KotlinParserARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3148)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 485, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3145)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(3150)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 485, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(3151)
			p.ControlStructureBody()
		}
		p.SetState(3153)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 486, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3152)
				p.Semi()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case KotlinParserELSE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3155)
			p.Match(KotlinParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3159)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3156)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(3161)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3162)
			p.Match(KotlinParserARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3166)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 488, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3163)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(3168)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 488, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(3169)
			p.ControlStructureBody()
		}
		p.SetState(3171)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 489, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3170)
				p.Semi()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhenConditionContext is an interface to support dynamic dispatch.
type IWhenConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	RangeTest() IRangeTestContext
	TypeTest() ITypeTestContext

	// IsWhenConditionContext differentiates from other interfaces.
	IsWhenConditionContext()
}

type WhenConditionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenConditionContext() *WhenConditionContext {
	var p = new(WhenConditionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_whenCondition
	return p
}

func InitEmptyWhenConditionContext(p *WhenConditionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_whenCondition
}

func (*WhenConditionContext) IsWhenConditionContext() {}

func NewWhenConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenConditionContext {
	var p = new(WhenConditionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_whenCondition

	return p
}

func (s *WhenConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenConditionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenConditionContext) RangeTest() IRangeTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRangeTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRangeTestContext)
}

func (s *WhenConditionContext) TypeTest() ITypeTestContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeTestContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeTestContext)
}

func (s *WhenConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterWhenCondition(s)
	}
}

func (s *WhenConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitWhenCondition(s)
	}
}

func (p *KotlinParser) WhenCondition() (localctx IWhenConditionContext) {
	localctx = NewWhenConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, KotlinParserRULE_whenCondition)
	p.SetState(3178)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KotlinParserNL, KotlinParserLPAREN, KotlinParserLSQUARE, KotlinParserLCURL, KotlinParserADD, KotlinParserSUB, KotlinParserINCR, KotlinParserDECR, KotlinParserEXCL_WS, KotlinParserEXCL_NO_WS, KotlinParserCOLONCOLON, KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS, KotlinParserRETURN_AT, KotlinParserCONTINUE_AT, KotlinParserBREAK_AT, KotlinParserTHIS_AT, KotlinParserSUPER_AT, KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserFUN, KotlinParserOBJECT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserTHIS, KotlinParserSUPER, KotlinParserWHERE, KotlinParserIF, KotlinParserWHEN, KotlinParserTRY, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserTHROW, KotlinParserRETURN, KotlinParserCONTINUE, KotlinParserBREAK, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserRealLiteral, KotlinParserIntegerLiteral, KotlinParserHexLiteral, KotlinParserBinLiteral, KotlinParserUnsignedLiteral, KotlinParserLongLiteral, KotlinParserBooleanLiteral, KotlinParserNullLiteral, KotlinParserCharacterLiteral, KotlinParserIdentifier, KotlinParserQUOTE_OPEN, KotlinParserTRIPLE_QUOTE_OPEN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3175)
			p.Expression()
		}

	case KotlinParserIN, KotlinParserNOT_IN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3176)
			p.RangeTest()
		}

	case KotlinParserIS, KotlinParserNOT_IS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3177)
			p.TypeTest()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRangeTestContext is an interface to support dynamic dispatch.
type IRangeTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InOperator() IInOperatorContext
	Expression() IExpressionContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsRangeTestContext differentiates from other interfaces.
	IsRangeTestContext()
}

type RangeTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRangeTestContext() *RangeTestContext {
	var p = new(RangeTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_rangeTest
	return p
}

func InitEmptyRangeTestContext(p *RangeTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_rangeTest
}

func (*RangeTestContext) IsRangeTestContext() {}

func NewRangeTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangeTestContext {
	var p = new(RangeTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_rangeTest

	return p
}

func (s *RangeTestContext) GetParser() antlr.Parser { return s.parser }

func (s *RangeTestContext) InOperator() IInOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInOperatorContext)
}

func (s *RangeTestContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RangeTestContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *RangeTestContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *RangeTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangeTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterRangeTest(s)
	}
}

func (s *RangeTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitRangeTest(s)
	}
}

func (p *KotlinParser) RangeTest() (localctx IRangeTestContext) {
	localctx = NewRangeTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, KotlinParserRULE_rangeTest)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3180)
		p.InOperator()
	}
	p.SetState(3184)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 492, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3181)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3186)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 492, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(3187)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeTestContext is an interface to support dynamic dispatch.
type ITypeTestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IsOperator() IIsOperatorContext
	Type_() ITypeContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsTypeTestContext differentiates from other interfaces.
	IsTypeTestContext()
}

type TypeTestContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeTestContext() *TypeTestContext {
	var p = new(TypeTestContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_typeTest
	return p
}

func InitEmptyTypeTestContext(p *TypeTestContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_typeTest
}

func (*TypeTestContext) IsTypeTestContext() {}

func NewTypeTestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeTestContext {
	var p = new(TypeTestContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeTest

	return p
}

func (s *TypeTestContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeTestContext) IsOperator() IIsOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIsOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIsOperatorContext)
}

func (s *TypeTestContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypeTestContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeTestContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeTestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeTestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeTestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeTest(s)
	}
}

func (s *TypeTestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeTest(s)
	}
}

func (p *KotlinParser) TypeTest() (localctx ITypeTestContext) {
	localctx = NewTypeTestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, KotlinParserRULE_typeTest)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3189)
		p.IsOperator()
	}
	p.SetState(3193)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(3190)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(3195)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3196)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITryExpressionContext is an interface to support dynamic dispatch.
type ITryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRY() antlr.TerminalNode
	Block() IBlockContext
	FinallyBlock() IFinallyBlockContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	AllCatchBlock() []ICatchBlockContext
	CatchBlock(i int) ICatchBlockContext

	// IsTryExpressionContext differentiates from other interfaces.
	IsTryExpressionContext()
}

type TryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryExpressionContext() *TryExpressionContext {
	var p = new(TryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_tryExpression
	return p
}

func InitEmptyTryExpressionContext(p *TryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_tryExpression
}

func (*TryExpressionContext) IsTryExpressionContext() {}

func NewTryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryExpressionContext {
	var p = new(TryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_tryExpression

	return p
}

func (s *TryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *TryExpressionContext) TRY() antlr.TerminalNode {
	return s.GetToken(KotlinParserTRY, 0)
}

func (s *TryExpressionContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *TryExpressionContext) FinallyBlock() IFinallyBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFinallyBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFinallyBlockContext)
}

func (s *TryExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TryExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TryExpressionContext) AllCatchBlock() []ICatchBlockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICatchBlockContext); ok {
			len++
		}
	}

	tst := make([]ICatchBlockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICatchBlockContext); ok {
			tst[i] = t.(ICatchBlockContext)
			i++
		}
	}

	return tst
}

func (s *TryExpressionContext) CatchBlock(i int) ICatchBlockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatchBlockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatchBlockContext)
}

func (s *TryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTryExpression(s)
	}
}

func (s *TryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTryExpression(s)
	}
}

func (p *KotlinParser) TryExpression() (localctx ITryExpressionContext) {
	localctx = NewTryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, KotlinParserRULE_tryExpression)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3198)
		p.Match(KotlinParserTRY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3202)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(3199)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(3204)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3205)
		p.Block()
	}
	p.SetState(3233)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 500, p.GetParserRuleContext()) {
	case 1:
		p.SetState(3213)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				p.SetState(3209)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == KotlinParserNL {
					{
						p.SetState(3206)
						p.Match(KotlinParserNL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

					p.SetState(3211)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(3212)
					p.CatchBlock()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(3215)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 496, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(3224)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 498, p.GetParserRuleContext()) == 1 {
			p.SetState(3220)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(3217)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(3222)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(3223)
				p.FinallyBlock()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.SetState(3229)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3226)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(3231)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3232)
			p.FinallyBlock()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICatchBlockContext is an interface to support dynamic dispatch.
type ICatchBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CATCH() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	SimpleIdentifier() ISimpleIdentifierContext
	COLON() antlr.TerminalNode
	Type_() ITypeContext
	RPAREN() antlr.TerminalNode
	Block() IBlockContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext
	COMMA() antlr.TerminalNode

	// IsCatchBlockContext differentiates from other interfaces.
	IsCatchBlockContext()
}

type CatchBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchBlockContext() *CatchBlockContext {
	var p = new(CatchBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_catchBlock
	return p
}

func InitEmptyCatchBlockContext(p *CatchBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_catchBlock
}

func (*CatchBlockContext) IsCatchBlockContext() {}

func NewCatchBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchBlockContext {
	var p = new(CatchBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_catchBlock

	return p
}

func (s *CatchBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchBlockContext) CATCH() antlr.TerminalNode {
	return s.GetToken(KotlinParserCATCH, 0)
}

func (s *CatchBlockContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserLPAREN, 0)
}

func (s *CatchBlockContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *CatchBlockContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *CatchBlockContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *CatchBlockContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRPAREN, 0)
}

func (s *CatchBlockContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *CatchBlockContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *CatchBlockContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *CatchBlockContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *CatchBlockContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *CatchBlockContext) COMMA() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMMA, 0)
}

func (s *CatchBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterCatchBlock(s)
	}
}

func (s *CatchBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitCatchBlock(s)
	}
}

func (p *KotlinParser) CatchBlock() (localctx ICatchBlockContext) {
	localctx = NewCatchBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, KotlinParserRULE_catchBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3235)
		p.Match(KotlinParserCATCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3239)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(3236)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(3241)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3242)
		p.Match(KotlinParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3246)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS {
		{
			p.SetState(3243)
			p.Annotation()
		}

		p.SetState(3248)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3249)
		p.SimpleIdentifier()
	}
	{
		p.SetState(3250)
		p.Match(KotlinParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3251)
		p.Type_()
	}
	p.SetState(3259)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KotlinParserNL || _la == KotlinParserCOMMA {
		p.SetState(3255)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3252)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(3257)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3258)
			p.Match(KotlinParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3261)
		p.Match(KotlinParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3265)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(3262)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(3267)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3268)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFinallyBlockContext is an interface to support dynamic dispatch.
type IFinallyBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FINALLY() antlr.TerminalNode
	Block() IBlockContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsFinallyBlockContext differentiates from other interfaces.
	IsFinallyBlockContext()
}

type FinallyBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinallyBlockContext() *FinallyBlockContext {
	var p = new(FinallyBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_finallyBlock
	return p
}

func InitEmptyFinallyBlockContext(p *FinallyBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_finallyBlock
}

func (*FinallyBlockContext) IsFinallyBlockContext() {}

func NewFinallyBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FinallyBlockContext {
	var p = new(FinallyBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_finallyBlock

	return p
}

func (s *FinallyBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *FinallyBlockContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(KotlinParserFINALLY, 0)
}

func (s *FinallyBlockContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FinallyBlockContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *FinallyBlockContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *FinallyBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FinallyBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FinallyBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFinallyBlock(s)
	}
}

func (s *FinallyBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFinallyBlock(s)
	}
}

func (p *KotlinParser) FinallyBlock() (localctx IFinallyBlockContext) {
	localctx = NewFinallyBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, KotlinParserRULE_finallyBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3270)
		p.Match(KotlinParserFINALLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3274)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(3271)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(3276)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3277)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJumpExpressionContext is an interface to support dynamic dispatch.
type IJumpExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	THROW() antlr.TerminalNode
	Expression() IExpressionContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	RETURN() antlr.TerminalNode
	RETURN_AT() antlr.TerminalNode
	CONTINUE() antlr.TerminalNode
	CONTINUE_AT() antlr.TerminalNode
	BREAK() antlr.TerminalNode
	BREAK_AT() antlr.TerminalNode

	// IsJumpExpressionContext differentiates from other interfaces.
	IsJumpExpressionContext()
}

type JumpExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJumpExpressionContext() *JumpExpressionContext {
	var p = new(JumpExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_jumpExpression
	return p
}

func InitEmptyJumpExpressionContext(p *JumpExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_jumpExpression
}

func (*JumpExpressionContext) IsJumpExpressionContext() {}

func NewJumpExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JumpExpressionContext {
	var p = new(JumpExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_jumpExpression

	return p
}

func (s *JumpExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *JumpExpressionContext) THROW() antlr.TerminalNode {
	return s.GetToken(KotlinParserTHROW, 0)
}

func (s *JumpExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *JumpExpressionContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *JumpExpressionContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *JumpExpressionContext) RETURN() antlr.TerminalNode {
	return s.GetToken(KotlinParserRETURN, 0)
}

func (s *JumpExpressionContext) RETURN_AT() antlr.TerminalNode {
	return s.GetToken(KotlinParserRETURN_AT, 0)
}

func (s *JumpExpressionContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(KotlinParserCONTINUE, 0)
}

func (s *JumpExpressionContext) CONTINUE_AT() antlr.TerminalNode {
	return s.GetToken(KotlinParserCONTINUE_AT, 0)
}

func (s *JumpExpressionContext) BREAK() antlr.TerminalNode {
	return s.GetToken(KotlinParserBREAK, 0)
}

func (s *JumpExpressionContext) BREAK_AT() antlr.TerminalNode {
	return s.GetToken(KotlinParserBREAK_AT, 0)
}

func (s *JumpExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JumpExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JumpExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterJumpExpression(s)
	}
}

func (s *JumpExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitJumpExpression(s)
	}
}

func (p *KotlinParser) JumpExpression() (localctx IJumpExpressionContext) {
	localctx = NewJumpExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, KotlinParserRULE_jumpExpression)
	var _la int

	var _alt int

	p.SetState(3295)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KotlinParserTHROW:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3279)
			p.Match(KotlinParserTHROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3283)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 507, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3280)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(3285)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 507, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(3286)
			p.Expression()
		}

	case KotlinParserRETURN_AT, KotlinParserRETURN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3287)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KotlinParserRETURN_AT || _la == KotlinParserRETURN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(3289)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 508, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3288)
				p.Expression()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case KotlinParserCONTINUE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3291)
			p.Match(KotlinParserCONTINUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KotlinParserCONTINUE_AT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3292)
			p.Match(KotlinParserCONTINUE_AT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KotlinParserBREAK:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3293)
			p.Match(KotlinParserBREAK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KotlinParserBREAK_AT:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3294)
			p.Match(KotlinParserBREAK_AT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICallableReferenceContext is an interface to support dynamic dispatch.
type ICallableReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLONCOLON() antlr.TerminalNode
	SimpleIdentifier() ISimpleIdentifierContext
	CLASS() antlr.TerminalNode
	ReceiverType() IReceiverTypeContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsCallableReferenceContext differentiates from other interfaces.
	IsCallableReferenceContext()
}

type CallableReferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallableReferenceContext() *CallableReferenceContext {
	var p = new(CallableReferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_callableReference
	return p
}

func InitEmptyCallableReferenceContext(p *CallableReferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_callableReference
}

func (*CallableReferenceContext) IsCallableReferenceContext() {}

func NewCallableReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallableReferenceContext {
	var p = new(CallableReferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_callableReference

	return p
}

func (s *CallableReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *CallableReferenceContext) COLONCOLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLONCOLON, 0)
}

func (s *CallableReferenceContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *CallableReferenceContext) CLASS() antlr.TerminalNode {
	return s.GetToken(KotlinParserCLASS, 0)
}

func (s *CallableReferenceContext) ReceiverType() IReceiverTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiverTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiverTypeContext)
}

func (s *CallableReferenceContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *CallableReferenceContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *CallableReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallableReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallableReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterCallableReference(s)
	}
}

func (s *CallableReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitCallableReference(s)
	}
}

func (p *KotlinParser) CallableReference() (localctx ICallableReferenceContext) {
	localctx = NewCallableReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, KotlinParserRULE_callableReference)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3298)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9223361041738497536) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-8794463665409) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&1049087) != 0) {
		{
			p.SetState(3297)
			p.ReceiverType()
		}

	}
	{
		p.SetState(3300)
		p.Match(KotlinParserCOLONCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3304)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(3301)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(3306)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3309)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KotlinParserFILE, KotlinParserFIELD, KotlinParserPROPERTY, KotlinParserGET, KotlinParserSET, KotlinParserRECEIVER, KotlinParserPARAM, KotlinParserSETPARAM, KotlinParserDELEGATE, KotlinParserIMPORT, KotlinParserCONSTRUCTOR, KotlinParserBY, KotlinParserCOMPANION, KotlinParserINIT, KotlinParserWHERE, KotlinParserCATCH, KotlinParserFINALLY, KotlinParserOUT, KotlinParserDYNAMIC, KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserREIFIED, KotlinParserEXPECT, KotlinParserACTUAL, KotlinParserIdentifier:
		{
			p.SetState(3307)
			p.SimpleIdentifier()
		}

	case KotlinParserCLASS:
		{
			p.SetState(3308)
			p.Match(KotlinParserCLASS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentAndOperatorContext is an interface to support dynamic dispatch.
type IAssignmentAndOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD_ASSIGNMENT() antlr.TerminalNode
	SUB_ASSIGNMENT() antlr.TerminalNode
	MULT_ASSIGNMENT() antlr.TerminalNode
	DIV_ASSIGNMENT() antlr.TerminalNode
	MOD_ASSIGNMENT() antlr.TerminalNode

	// IsAssignmentAndOperatorContext differentiates from other interfaces.
	IsAssignmentAndOperatorContext()
}

type AssignmentAndOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentAndOperatorContext() *AssignmentAndOperatorContext {
	var p = new(AssignmentAndOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_assignmentAndOperator
	return p
}

func InitEmptyAssignmentAndOperatorContext(p *AssignmentAndOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_assignmentAndOperator
}

func (*AssignmentAndOperatorContext) IsAssignmentAndOperatorContext() {}

func NewAssignmentAndOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentAndOperatorContext {
	var p = new(AssignmentAndOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_assignmentAndOperator

	return p
}

func (s *AssignmentAndOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentAndOperatorContext) ADD_ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserADD_ASSIGNMENT, 0)
}

func (s *AssignmentAndOperatorContext) SUB_ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserSUB_ASSIGNMENT, 0)
}

func (s *AssignmentAndOperatorContext) MULT_ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserMULT_ASSIGNMENT, 0)
}

func (s *AssignmentAndOperatorContext) DIV_ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserDIV_ASSIGNMENT, 0)
}

func (s *AssignmentAndOperatorContext) MOD_ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(KotlinParserMOD_ASSIGNMENT, 0)
}

func (s *AssignmentAndOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentAndOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentAndOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAssignmentAndOperator(s)
	}
}

func (s *AssignmentAndOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAssignmentAndOperator(s)
	}
}

func (p *KotlinParser) AssignmentAndOperator() (localctx IAssignmentAndOperatorContext) {
	localctx = NewAssignmentAndOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, KotlinParserRULE_assignmentAndOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3311)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&16642998272) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEqualityOperatorContext is an interface to support dynamic dispatch.
type IEqualityOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXCL_EQ() antlr.TerminalNode
	EXCL_EQEQ() antlr.TerminalNode
	EQEQ() antlr.TerminalNode
	EQEQEQ() antlr.TerminalNode

	// IsEqualityOperatorContext differentiates from other interfaces.
	IsEqualityOperatorContext()
}

type EqualityOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEqualityOperatorContext() *EqualityOperatorContext {
	var p = new(EqualityOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_equalityOperator
	return p
}

func InitEmptyEqualityOperatorContext(p *EqualityOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_equalityOperator
}

func (*EqualityOperatorContext) IsEqualityOperatorContext() {}

func NewEqualityOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EqualityOperatorContext {
	var p = new(EqualityOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_equalityOperator

	return p
}

func (s *EqualityOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *EqualityOperatorContext) EXCL_EQ() antlr.TerminalNode {
	return s.GetToken(KotlinParserEXCL_EQ, 0)
}

func (s *EqualityOperatorContext) EXCL_EQEQ() antlr.TerminalNode {
	return s.GetToken(KotlinParserEXCL_EQEQ, 0)
}

func (s *EqualityOperatorContext) EQEQ() antlr.TerminalNode {
	return s.GetToken(KotlinParserEQEQ, 0)
}

func (s *EqualityOperatorContext) EQEQEQ() antlr.TerminalNode {
	return s.GetToken(KotlinParserEQEQEQ, 0)
}

func (s *EqualityOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualityOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EqualityOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterEqualityOperator(s)
	}
}

func (s *EqualityOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitEqualityOperator(s)
	}
}

func (p *KotlinParser) EqualityOperator() (localctx IEqualityOperatorContext) {
	localctx = NewEqualityOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, KotlinParserRULE_equalityOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3313)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&60798594969501696) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LANGLE() antlr.TerminalNode
	RANGLE() antlr.TerminalNode
	LE() antlr.TerminalNode
	GE() antlr.TerminalNode

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_comparisonOperator
	return p
}

func InitEmptyComparisonOperatorContext(p *ComparisonOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_comparisonOperator
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) LANGLE() antlr.TerminalNode {
	return s.GetToken(KotlinParserLANGLE, 0)
}

func (s *ComparisonOperatorContext) RANGLE() antlr.TerminalNode {
	return s.GetToken(KotlinParserRANGLE, 0)
}

func (s *ComparisonOperatorContext) LE() antlr.TerminalNode {
	return s.GetToken(KotlinParserLE, 0)
}

func (s *ComparisonOperatorContext) GE() antlr.TerminalNode {
	return s.GetToken(KotlinParserGE, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitComparisonOperator(s)
	}
}

func (p *KotlinParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, KotlinParserRULE_comparisonOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3315)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2111062325329920) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInOperatorContext is an interface to support dynamic dispatch.
type IInOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IN() antlr.TerminalNode
	NOT_IN() antlr.TerminalNode

	// IsInOperatorContext differentiates from other interfaces.
	IsInOperatorContext()
}

type InOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInOperatorContext() *InOperatorContext {
	var p = new(InOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_inOperator
	return p
}

func InitEmptyInOperatorContext(p *InOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_inOperator
}

func (*InOperatorContext) IsInOperatorContext() {}

func NewInOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InOperatorContext {
	var p = new(InOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_inOperator

	return p
}

func (s *InOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *InOperatorContext) IN() antlr.TerminalNode {
	return s.GetToken(KotlinParserIN, 0)
}

func (s *InOperatorContext) NOT_IN() antlr.TerminalNode {
	return s.GetToken(KotlinParserNOT_IN, 0)
}

func (s *InOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterInOperator(s)
	}
}

func (s *InOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitInOperator(s)
	}
}

func (p *KotlinParser) InOperator() (localctx IInOperatorContext) {
	localctx = NewInOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, KotlinParserRULE_inOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3317)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserIN || _la == KotlinParserNOT_IN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIsOperatorContext is an interface to support dynamic dispatch.
type IIsOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IS() antlr.TerminalNode
	NOT_IS() antlr.TerminalNode

	// IsIsOperatorContext differentiates from other interfaces.
	IsIsOperatorContext()
}

type IsOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIsOperatorContext() *IsOperatorContext {
	var p = new(IsOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_isOperator
	return p
}

func InitEmptyIsOperatorContext(p *IsOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_isOperator
}

func (*IsOperatorContext) IsIsOperatorContext() {}

func NewIsOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IsOperatorContext {
	var p = new(IsOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_isOperator

	return p
}

func (s *IsOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *IsOperatorContext) IS() antlr.TerminalNode {
	return s.GetToken(KotlinParserIS, 0)
}

func (s *IsOperatorContext) NOT_IS() antlr.TerminalNode {
	return s.GetToken(KotlinParserNOT_IS, 0)
}

func (s *IsOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IsOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterIsOperator(s)
	}
}

func (s *IsOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitIsOperator(s)
	}
}

func (p *KotlinParser) IsOperator() (localctx IIsOperatorContext) {
	localctx = NewIsOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, KotlinParserRULE_isOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3319)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserIS || _la == KotlinParserNOT_IS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdditiveOperatorContext is an interface to support dynamic dispatch.
type IAdditiveOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	SUB() antlr.TerminalNode

	// IsAdditiveOperatorContext differentiates from other interfaces.
	IsAdditiveOperatorContext()
}

type AdditiveOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditiveOperatorContext() *AdditiveOperatorContext {
	var p = new(AdditiveOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_additiveOperator
	return p
}

func InitEmptyAdditiveOperatorContext(p *AdditiveOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_additiveOperator
}

func (*AdditiveOperatorContext) IsAdditiveOperatorContext() {}

func NewAdditiveOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditiveOperatorContext {
	var p = new(AdditiveOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_additiveOperator

	return p
}

func (s *AdditiveOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditiveOperatorContext) ADD() antlr.TerminalNode {
	return s.GetToken(KotlinParserADD, 0)
}

func (s *AdditiveOperatorContext) SUB() antlr.TerminalNode {
	return s.GetToken(KotlinParserSUB, 0)
}

func (s *AdditiveOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditiveOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAdditiveOperator(s)
	}
}

func (s *AdditiveOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAdditiveOperator(s)
	}
}

func (p *KotlinParser) AdditiveOperator() (localctx IAdditiveOperatorContext) {
	localctx = NewAdditiveOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, KotlinParserRULE_additiveOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3321)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserADD || _la == KotlinParserSUB) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiplicativeOperatorContext is an interface to support dynamic dispatch.
type IMultiplicativeOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MULT() antlr.TerminalNode
	DIV() antlr.TerminalNode
	MOD() antlr.TerminalNode

	// IsMultiplicativeOperatorContext differentiates from other interfaces.
	IsMultiplicativeOperatorContext()
}

type MultiplicativeOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplicativeOperatorContext() *MultiplicativeOperatorContext {
	var p = new(MultiplicativeOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_multiplicativeOperator
	return p
}

func InitEmptyMultiplicativeOperatorContext(p *MultiplicativeOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_multiplicativeOperator
}

func (*MultiplicativeOperatorContext) IsMultiplicativeOperatorContext() {}

func NewMultiplicativeOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplicativeOperatorContext {
	var p = new(MultiplicativeOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_multiplicativeOperator

	return p
}

func (s *MultiplicativeOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplicativeOperatorContext) MULT() antlr.TerminalNode {
	return s.GetToken(KotlinParserMULT, 0)
}

func (s *MultiplicativeOperatorContext) DIV() antlr.TerminalNode {
	return s.GetToken(KotlinParserDIV, 0)
}

func (s *MultiplicativeOperatorContext) MOD() antlr.TerminalNode {
	return s.GetToken(KotlinParserMOD, 0)
}

func (s *MultiplicativeOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplicativeOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterMultiplicativeOperator(s)
	}
}

func (s *MultiplicativeOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitMultiplicativeOperator(s)
	}
}

func (p *KotlinParser) MultiplicativeOperator() (localctx IMultiplicativeOperatorContext) {
	localctx = NewMultiplicativeOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, KotlinParserRULE_multiplicativeOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3323)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&229376) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAsOperatorContext is an interface to support dynamic dispatch.
type IAsOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AS() antlr.TerminalNode
	AS_SAFE() antlr.TerminalNode

	// IsAsOperatorContext differentiates from other interfaces.
	IsAsOperatorContext()
}

type AsOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsOperatorContext() *AsOperatorContext {
	var p = new(AsOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_asOperator
	return p
}

func InitEmptyAsOperatorContext(p *AsOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_asOperator
}

func (*AsOperatorContext) IsAsOperatorContext() {}

func NewAsOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsOperatorContext {
	var p = new(AsOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_asOperator

	return p
}

func (s *AsOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AsOperatorContext) AS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAS, 0)
}

func (s *AsOperatorContext) AS_SAFE() antlr.TerminalNode {
	return s.GetToken(KotlinParserAS_SAFE, 0)
}

func (s *AsOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAsOperator(s)
	}
}

func (s *AsOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAsOperator(s)
	}
}

func (p *KotlinParser) AsOperator() (localctx IAsOperatorContext) {
	localctx = NewAsOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, KotlinParserRULE_asOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3325)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserAS_SAFE || _la == KotlinParserAS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrefixUnaryOperatorContext is an interface to support dynamic dispatch.
type IPrefixUnaryOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INCR() antlr.TerminalNode
	DECR() antlr.TerminalNode
	SUB() antlr.TerminalNode
	ADD() antlr.TerminalNode
	Excl() IExclContext

	// IsPrefixUnaryOperatorContext differentiates from other interfaces.
	IsPrefixUnaryOperatorContext()
}

type PrefixUnaryOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrefixUnaryOperatorContext() *PrefixUnaryOperatorContext {
	var p = new(PrefixUnaryOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_prefixUnaryOperator
	return p
}

func InitEmptyPrefixUnaryOperatorContext(p *PrefixUnaryOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_prefixUnaryOperator
}

func (*PrefixUnaryOperatorContext) IsPrefixUnaryOperatorContext() {}

func NewPrefixUnaryOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrefixUnaryOperatorContext {
	var p = new(PrefixUnaryOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_prefixUnaryOperator

	return p
}

func (s *PrefixUnaryOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *PrefixUnaryOperatorContext) INCR() antlr.TerminalNode {
	return s.GetToken(KotlinParserINCR, 0)
}

func (s *PrefixUnaryOperatorContext) DECR() antlr.TerminalNode {
	return s.GetToken(KotlinParserDECR, 0)
}

func (s *PrefixUnaryOperatorContext) SUB() antlr.TerminalNode {
	return s.GetToken(KotlinParserSUB, 0)
}

func (s *PrefixUnaryOperatorContext) ADD() antlr.TerminalNode {
	return s.GetToken(KotlinParserADD, 0)
}

func (s *PrefixUnaryOperatorContext) Excl() IExclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExclContext)
}

func (s *PrefixUnaryOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrefixUnaryOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrefixUnaryOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPrefixUnaryOperator(s)
	}
}

func (s *PrefixUnaryOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPrefixUnaryOperator(s)
	}
}

func (p *KotlinParser) PrefixUnaryOperator() (localctx IPrefixUnaryOperatorContext) {
	localctx = NewPrefixUnaryOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, KotlinParserRULE_prefixUnaryOperator)
	p.SetState(3332)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KotlinParserINCR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3327)
			p.Match(KotlinParserINCR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KotlinParserDECR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3328)
			p.Match(KotlinParserDECR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KotlinParserSUB:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3329)
			p.Match(KotlinParserSUB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KotlinParserADD:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3330)
			p.Match(KotlinParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KotlinParserEXCL_WS, KotlinParserEXCL_NO_WS:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3331)
			p.Excl()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPostfixUnaryOperatorContext is an interface to support dynamic dispatch.
type IPostfixUnaryOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INCR() antlr.TerminalNode
	DECR() antlr.TerminalNode
	EXCL_NO_WS() antlr.TerminalNode
	Excl() IExclContext

	// IsPostfixUnaryOperatorContext differentiates from other interfaces.
	IsPostfixUnaryOperatorContext()
}

type PostfixUnaryOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixUnaryOperatorContext() *PostfixUnaryOperatorContext {
	var p = new(PostfixUnaryOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_postfixUnaryOperator
	return p
}

func InitEmptyPostfixUnaryOperatorContext(p *PostfixUnaryOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_postfixUnaryOperator
}

func (*PostfixUnaryOperatorContext) IsPostfixUnaryOperatorContext() {}

func NewPostfixUnaryOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixUnaryOperatorContext {
	var p = new(PostfixUnaryOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_postfixUnaryOperator

	return p
}

func (s *PostfixUnaryOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixUnaryOperatorContext) INCR() antlr.TerminalNode {
	return s.GetToken(KotlinParserINCR, 0)
}

func (s *PostfixUnaryOperatorContext) DECR() antlr.TerminalNode {
	return s.GetToken(KotlinParserDECR, 0)
}

func (s *PostfixUnaryOperatorContext) EXCL_NO_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserEXCL_NO_WS, 0)
}

func (s *PostfixUnaryOperatorContext) Excl() IExclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExclContext)
}

func (s *PostfixUnaryOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixUnaryOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixUnaryOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPostfixUnaryOperator(s)
	}
}

func (s *PostfixUnaryOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPostfixUnaryOperator(s)
	}
}

func (p *KotlinParser) PostfixUnaryOperator() (localctx IPostfixUnaryOperatorContext) {
	localctx = NewPostfixUnaryOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, KotlinParserRULE_postfixUnaryOperator)
	p.SetState(3338)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KotlinParserINCR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3334)
			p.Match(KotlinParserINCR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KotlinParserDECR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3335)
			p.Match(KotlinParserDECR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KotlinParserEXCL_NO_WS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3336)
			p.Match(KotlinParserEXCL_NO_WS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3337)
			p.Excl()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExclContext is an interface to support dynamic dispatch.
type IExclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXCL_NO_WS() antlr.TerminalNode
	EXCL_WS() antlr.TerminalNode

	// IsExclContext differentiates from other interfaces.
	IsExclContext()
}

type ExclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExclContext() *ExclContext {
	var p = new(ExclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_excl
	return p
}

func InitEmptyExclContext(p *ExclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_excl
}

func (*ExclContext) IsExclContext() {}

func NewExclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExclContext {
	var p = new(ExclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_excl

	return p
}

func (s *ExclContext) GetParser() antlr.Parser { return s.parser }

func (s *ExclContext) EXCL_NO_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserEXCL_NO_WS, 0)
}

func (s *ExclContext) EXCL_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserEXCL_WS, 0)
}

func (s *ExclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterExcl(s)
	}
}

func (s *ExclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitExcl(s)
	}
}

func (p *KotlinParser) Excl() (localctx IExclContext) {
	localctx = NewExclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, KotlinParserRULE_excl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3340)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserEXCL_WS || _la == KotlinParserEXCL_NO_WS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMemberAccessOperatorContext is an interface to support dynamic dispatch.
type IMemberAccessOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOT() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	SafeNav() ISafeNavContext
	COLONCOLON() antlr.TerminalNode

	// IsMemberAccessOperatorContext differentiates from other interfaces.
	IsMemberAccessOperatorContext()
}

type MemberAccessOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemberAccessOperatorContext() *MemberAccessOperatorContext {
	var p = new(MemberAccessOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_memberAccessOperator
	return p
}

func InitEmptyMemberAccessOperatorContext(p *MemberAccessOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_memberAccessOperator
}

func (*MemberAccessOperatorContext) IsMemberAccessOperatorContext() {}

func NewMemberAccessOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemberAccessOperatorContext {
	var p = new(MemberAccessOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_memberAccessOperator

	return p
}

func (s *MemberAccessOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberAccessOperatorContext) DOT() antlr.TerminalNode {
	return s.GetToken(KotlinParserDOT, 0)
}

func (s *MemberAccessOperatorContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *MemberAccessOperatorContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *MemberAccessOperatorContext) SafeNav() ISafeNavContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISafeNavContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISafeNavContext)
}

func (s *MemberAccessOperatorContext) COLONCOLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLONCOLON, 0)
}

func (s *MemberAccessOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberAccessOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemberAccessOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterMemberAccessOperator(s)
	}
}

func (s *MemberAccessOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitMemberAccessOperator(s)
	}
}

func (p *KotlinParser) MemberAccessOperator() (localctx IMemberAccessOperatorContext) {
	localctx = NewMemberAccessOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, KotlinParserRULE_memberAccessOperator)
	var _la int

	p.SetState(3357)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 517, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3345)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3342)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(3347)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3348)
			p.Match(KotlinParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(3352)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3349)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(3354)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3355)
			p.SafeNav()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3356)
			p.Match(KotlinParserCOLONCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISafeNavContext is an interface to support dynamic dispatch.
type ISafeNavContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QUEST_NO_WS() antlr.TerminalNode
	DOT() antlr.TerminalNode

	// IsSafeNavContext differentiates from other interfaces.
	IsSafeNavContext()
}

type SafeNavContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySafeNavContext() *SafeNavContext {
	var p = new(SafeNavContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_safeNav
	return p
}

func InitEmptySafeNavContext(p *SafeNavContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_safeNav
}

func (*SafeNavContext) IsSafeNavContext() {}

func NewSafeNavContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SafeNavContext {
	var p = new(SafeNavContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_safeNav

	return p
}

func (s *SafeNavContext) GetParser() antlr.Parser { return s.parser }

func (s *SafeNavContext) QUEST_NO_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserQUEST_NO_WS, 0)
}

func (s *SafeNavContext) DOT() antlr.TerminalNode {
	return s.GetToken(KotlinParserDOT, 0)
}

func (s *SafeNavContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SafeNavContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SafeNavContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterSafeNav(s)
	}
}

func (s *SafeNavContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitSafeNav(s)
	}
}

func (p *KotlinParser) SafeNav() (localctx ISafeNavContext) {
	localctx = NewSafeNavContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, KotlinParserRULE_safeNav)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3359)
		p.Match(KotlinParserQUEST_NO_WS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3360)
		p.Match(KotlinParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifiersContext is an interface to support dynamic dispatch.
type IModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext
	AllModifier() []IModifierContext
	Modifier(i int) IModifierContext

	// IsModifiersContext differentiates from other interfaces.
	IsModifiersContext()
}

type ModifiersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifiersContext() *ModifiersContext {
	var p = new(ModifiersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_modifiers
	return p
}

func InitEmptyModifiersContext(p *ModifiersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_modifiers
}

func (*ModifiersContext) IsModifiersContext() {}

func NewModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifiersContext {
	var p = new(ModifiersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_modifiers

	return p
}

func (s *ModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifiersContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *ModifiersContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ModifiersContext) AllModifier() []IModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModifierContext); ok {
			len++
		}
	}

	tst := make([]IModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModifierContext); ok {
			tst[i] = t.(IModifierContext)
			i++
		}
	}

	return tst
}

func (s *ModifiersContext) Modifier(i int) IModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *ModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterModifiers(s)
	}
}

func (s *ModifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitModifiers(s)
	}
}

func (p *KotlinParser) Modifiers() (localctx IModifiersContext) {
	localctx = NewModifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, KotlinParserRULE_modifiers)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3364)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(3364)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS:
				{
					p.SetState(3362)
					p.Annotation()
				}

			case KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL, KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE, KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND, KotlinParserOVERRIDE, KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN, KotlinParserCONST, KotlinParserLATEINIT, KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE, KotlinParserEXPECT, KotlinParserACTUAL:
				{
					p.SetState(3363)
					p.Modifier()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(3366)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 519, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterModifiersContext is an interface to support dynamic dispatch.
type IParameterModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext
	AllParameterModifier() []IParameterModifierContext
	ParameterModifier(i int) IParameterModifierContext

	// IsParameterModifiersContext differentiates from other interfaces.
	IsParameterModifiersContext()
}

type ParameterModifiersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterModifiersContext() *ParameterModifiersContext {
	var p = new(ParameterModifiersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_parameterModifiers
	return p
}

func InitEmptyParameterModifiersContext(p *ParameterModifiersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_parameterModifiers
}

func (*ParameterModifiersContext) IsParameterModifiersContext() {}

func NewParameterModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterModifiersContext {
	var p = new(ParameterModifiersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_parameterModifiers

	return p
}

func (s *ParameterModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterModifiersContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *ParameterModifiersContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ParameterModifiersContext) AllParameterModifier() []IParameterModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParameterModifierContext); ok {
			len++
		}
	}

	tst := make([]IParameterModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParameterModifierContext); ok {
			tst[i] = t.(IParameterModifierContext)
			i++
		}
	}

	return tst
}

func (s *ParameterModifiersContext) ParameterModifier(i int) IParameterModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterModifierContext)
}

func (s *ParameterModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterModifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterParameterModifiers(s)
	}
}

func (s *ParameterModifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitParameterModifiers(s)
	}
}

func (p *KotlinParser) ParameterModifiers() (localctx IParameterModifiersContext) {
	localctx = NewParameterModifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, KotlinParserRULE_parameterModifiers)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3370)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(3370)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS:
				{
					p.SetState(3368)
					p.Annotation()
				}

			case KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE:
				{
					p.SetState(3369)
					p.ParameterModifier()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(3372)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 521, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifierContext is an interface to support dynamic dispatch.
type IModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassModifier() IClassModifierContext
	MemberModifier() IMemberModifierContext
	VisibilityModifier() IVisibilityModifierContext
	FunctionModifier() IFunctionModifierContext
	PropertyModifier() IPropertyModifierContext
	InheritanceModifier() IInheritanceModifierContext
	ParameterModifier() IParameterModifierContext
	PlatformModifier() IPlatformModifierContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsModifierContext differentiates from other interfaces.
	IsModifierContext()
}

type ModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifierContext() *ModifierContext {
	var p = new(ModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_modifier
	return p
}

func InitEmptyModifierContext(p *ModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_modifier
}

func (*ModifierContext) IsModifierContext() {}

func NewModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifierContext {
	var p = new(ModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_modifier

	return p
}

func (s *ModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifierContext) ClassModifier() IClassModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassModifierContext)
}

func (s *ModifierContext) MemberModifier() IMemberModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberModifierContext)
}

func (s *ModifierContext) VisibilityModifier() IVisibilityModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVisibilityModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVisibilityModifierContext)
}

func (s *ModifierContext) FunctionModifier() IFunctionModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionModifierContext)
}

func (s *ModifierContext) PropertyModifier() IPropertyModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyModifierContext)
}

func (s *ModifierContext) InheritanceModifier() IInheritanceModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInheritanceModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInheritanceModifierContext)
}

func (s *ModifierContext) ParameterModifier() IParameterModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterModifierContext)
}

func (s *ModifierContext) PlatformModifier() IPlatformModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPlatformModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPlatformModifierContext)
}

func (s *ModifierContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *ModifierContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *ModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterModifier(s)
	}
}

func (s *ModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitModifier(s)
	}
}

func (p *KotlinParser) Modifier() (localctx IModifierContext) {
	localctx = NewModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, KotlinParserRULE_modifier)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3382)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KotlinParserENUM, KotlinParserSEALED, KotlinParserANNOTATION, KotlinParserDATA, KotlinParserINNER, KotlinParserVALUE:
		{
			p.SetState(3374)
			p.ClassModifier()
		}

	case KotlinParserOVERRIDE, KotlinParserLATEINIT:
		{
			p.SetState(3375)
			p.MemberModifier()
		}

	case KotlinParserPUBLIC, KotlinParserPRIVATE, KotlinParserPROTECTED, KotlinParserINTERNAL:
		{
			p.SetState(3376)
			p.VisibilityModifier()
		}

	case KotlinParserTAILREC, KotlinParserOPERATOR, KotlinParserINLINE, KotlinParserINFIX, KotlinParserEXTERNAL, KotlinParserSUSPEND:
		{
			p.SetState(3377)
			p.FunctionModifier()
		}

	case KotlinParserCONST:
		{
			p.SetState(3378)
			p.PropertyModifier()
		}

	case KotlinParserABSTRACT, KotlinParserFINAL, KotlinParserOPEN:
		{
			p.SetState(3379)
			p.InheritanceModifier()
		}

	case KotlinParserVARARG, KotlinParserNOINLINE, KotlinParserCROSSINLINE:
		{
			p.SetState(3380)
			p.ParameterModifier()
		}

	case KotlinParserEXPECT, KotlinParserACTUAL:
		{
			p.SetState(3381)
			p.PlatformModifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(3387)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 523, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3384)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3389)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 523, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeModifiersContext is an interface to support dynamic dispatch.
type ITypeModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTypeModifier() []ITypeModifierContext
	TypeModifier(i int) ITypeModifierContext

	// IsTypeModifiersContext differentiates from other interfaces.
	IsTypeModifiersContext()
}

type TypeModifiersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeModifiersContext() *TypeModifiersContext {
	var p = new(TypeModifiersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_typeModifiers
	return p
}

func InitEmptyTypeModifiersContext(p *TypeModifiersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_typeModifiers
}

func (*TypeModifiersContext) IsTypeModifiersContext() {}

func NewTypeModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeModifiersContext {
	var p = new(TypeModifiersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeModifiers

	return p
}

func (s *TypeModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeModifiersContext) AllTypeModifier() []ITypeModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeModifierContext); ok {
			len++
		}
	}

	tst := make([]ITypeModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeModifierContext); ok {
			tst[i] = t.(ITypeModifierContext)
			i++
		}
	}

	return tst
}

func (s *TypeModifiersContext) TypeModifier(i int) ITypeModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeModifierContext)
}

func (s *TypeModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeModifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeModifiers(s)
	}
}

func (s *TypeModifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeModifiers(s)
	}
}

func (p *KotlinParser) TypeModifiers() (localctx ITypeModifiersContext) {
	localctx = NewTypeModifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, KotlinParserRULE_typeModifiers)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3391)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(3390)
				p.TypeModifier()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(3393)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 524, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeModifierContext is an interface to support dynamic dispatch.
type ITypeModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Annotation() IAnnotationContext
	SUSPEND() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsTypeModifierContext differentiates from other interfaces.
	IsTypeModifierContext()
}

type TypeModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeModifierContext() *TypeModifierContext {
	var p = new(TypeModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_typeModifier
	return p
}

func InitEmptyTypeModifierContext(p *TypeModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_typeModifier
}

func (*TypeModifierContext) IsTypeModifierContext() {}

func NewTypeModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeModifierContext {
	var p = new(TypeModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeModifier

	return p
}

func (s *TypeModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeModifierContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *TypeModifierContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(KotlinParserSUSPEND, 0)
}

func (s *TypeModifierContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeModifierContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeModifier(s)
	}
}

func (s *TypeModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeModifier(s)
	}
}

func (p *KotlinParser) TypeModifier() (localctx ITypeModifierContext) {
	localctx = NewTypeModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, KotlinParserRULE_typeModifier)
	var _la int

	p.SetState(3403)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3395)
			p.Annotation()
		}

	case KotlinParserSUSPEND:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3396)
			p.Match(KotlinParserSUSPEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3400)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3397)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(3402)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassModifierContext is an interface to support dynamic dispatch.
type IClassModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ENUM() antlr.TerminalNode
	SEALED() antlr.TerminalNode
	ANNOTATION() antlr.TerminalNode
	DATA() antlr.TerminalNode
	INNER() antlr.TerminalNode
	VALUE() antlr.TerminalNode

	// IsClassModifierContext differentiates from other interfaces.
	IsClassModifierContext()
}

type ClassModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassModifierContext() *ClassModifierContext {
	var p = new(ClassModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_classModifier
	return p
}

func InitEmptyClassModifierContext(p *ClassModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_classModifier
}

func (*ClassModifierContext) IsClassModifierContext() {}

func NewClassModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassModifierContext {
	var p = new(ClassModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_classModifier

	return p
}

func (s *ClassModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassModifierContext) ENUM() antlr.TerminalNode {
	return s.GetToken(KotlinParserENUM, 0)
}

func (s *ClassModifierContext) SEALED() antlr.TerminalNode {
	return s.GetToken(KotlinParserSEALED, 0)
}

func (s *ClassModifierContext) ANNOTATION() antlr.TerminalNode {
	return s.GetToken(KotlinParserANNOTATION, 0)
}

func (s *ClassModifierContext) DATA() antlr.TerminalNode {
	return s.GetToken(KotlinParserDATA, 0)
}

func (s *ClassModifierContext) INNER() antlr.TerminalNode {
	return s.GetToken(KotlinParserINNER, 0)
}

func (s *ClassModifierContext) VALUE() antlr.TerminalNode {
	return s.GetToken(KotlinParserVALUE, 0)
}

func (s *ClassModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterClassModifier(s)
	}
}

func (s *ClassModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitClassModifier(s)
	}
}

func (p *KotlinParser) ClassModifier() (localctx IClassModifierContext) {
	localctx = NewClassModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, KotlinParserRULE_classModifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3405)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-113)) & ^0x3f) == 0 && ((int64(1)<<(_la-113))&63) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMemberModifierContext is an interface to support dynamic dispatch.
type IMemberModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OVERRIDE() antlr.TerminalNode
	LATEINIT() antlr.TerminalNode

	// IsMemberModifierContext differentiates from other interfaces.
	IsMemberModifierContext()
}

type MemberModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemberModifierContext() *MemberModifierContext {
	var p = new(MemberModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_memberModifier
	return p
}

func InitEmptyMemberModifierContext(p *MemberModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_memberModifier
}

func (*MemberModifierContext) IsMemberModifierContext() {}

func NewMemberModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemberModifierContext {
	var p = new(MemberModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_memberModifier

	return p
}

func (s *MemberModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberModifierContext) OVERRIDE() antlr.TerminalNode {
	return s.GetToken(KotlinParserOVERRIDE, 0)
}

func (s *MemberModifierContext) LATEINIT() antlr.TerminalNode {
	return s.GetToken(KotlinParserLATEINIT, 0)
}

func (s *MemberModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemberModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterMemberModifier(s)
	}
}

func (s *MemberModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitMemberModifier(s)
	}
}

func (p *KotlinParser) MemberModifier() (localctx IMemberModifierContext) {
	localctx = NewMemberModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, KotlinParserRULE_memberModifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3407)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserOVERRIDE || _la == KotlinParserLATEINIT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVisibilityModifierContext is an interface to support dynamic dispatch.
type IVisibilityModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PUBLIC() antlr.TerminalNode
	PRIVATE() antlr.TerminalNode
	INTERNAL() antlr.TerminalNode
	PROTECTED() antlr.TerminalNode

	// IsVisibilityModifierContext differentiates from other interfaces.
	IsVisibilityModifierContext()
}

type VisibilityModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVisibilityModifierContext() *VisibilityModifierContext {
	var p = new(VisibilityModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_visibilityModifier
	return p
}

func InitEmptyVisibilityModifierContext(p *VisibilityModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_visibilityModifier
}

func (*VisibilityModifierContext) IsVisibilityModifierContext() {}

func NewVisibilityModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VisibilityModifierContext {
	var p = new(VisibilityModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_visibilityModifier

	return p
}

func (s *VisibilityModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *VisibilityModifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(KotlinParserPUBLIC, 0)
}

func (s *VisibilityModifierContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(KotlinParserPRIVATE, 0)
}

func (s *VisibilityModifierContext) INTERNAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserINTERNAL, 0)
}

func (s *VisibilityModifierContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(KotlinParserPROTECTED, 0)
}

func (s *VisibilityModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VisibilityModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VisibilityModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterVisibilityModifier(s)
	}
}

func (s *VisibilityModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitVisibilityModifier(s)
	}
}

func (p *KotlinParser) VisibilityModifier() (localctx IVisibilityModifierContext) {
	localctx = NewVisibilityModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, KotlinParserRULE_visibilityModifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3409)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-109)) & ^0x3f) == 0 && ((int64(1)<<(_la-109))&15) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVarianceModifierContext is an interface to support dynamic dispatch.
type IVarianceModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IN() antlr.TerminalNode
	OUT() antlr.TerminalNode

	// IsVarianceModifierContext differentiates from other interfaces.
	IsVarianceModifierContext()
}

type VarianceModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarianceModifierContext() *VarianceModifierContext {
	var p = new(VarianceModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_varianceModifier
	return p
}

func InitEmptyVarianceModifierContext(p *VarianceModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_varianceModifier
}

func (*VarianceModifierContext) IsVarianceModifierContext() {}

func NewVarianceModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarianceModifierContext {
	var p = new(VarianceModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_varianceModifier

	return p
}

func (s *VarianceModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *VarianceModifierContext) IN() antlr.TerminalNode {
	return s.GetToken(KotlinParserIN, 0)
}

func (s *VarianceModifierContext) OUT() antlr.TerminalNode {
	return s.GetToken(KotlinParserOUT, 0)
}

func (s *VarianceModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarianceModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarianceModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterVarianceModifier(s)
	}
}

func (s *VarianceModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitVarianceModifier(s)
	}
}

func (p *KotlinParser) VarianceModifier() (localctx IVarianceModifierContext) {
	localctx = NewVarianceModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, KotlinParserRULE_varianceModifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3411)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserIN || _la == KotlinParserOUT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeParameterModifiersContext is an interface to support dynamic dispatch.
type ITypeParameterModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTypeParameterModifier() []ITypeParameterModifierContext
	TypeParameterModifier(i int) ITypeParameterModifierContext

	// IsTypeParameterModifiersContext differentiates from other interfaces.
	IsTypeParameterModifiersContext()
}

type TypeParameterModifiersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterModifiersContext() *TypeParameterModifiersContext {
	var p = new(TypeParameterModifiersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_typeParameterModifiers
	return p
}

func InitEmptyTypeParameterModifiersContext(p *TypeParameterModifiersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_typeParameterModifiers
}

func (*TypeParameterModifiersContext) IsTypeParameterModifiersContext() {}

func NewTypeParameterModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterModifiersContext {
	var p = new(TypeParameterModifiersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeParameterModifiers

	return p
}

func (s *TypeParameterModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterModifiersContext) AllTypeParameterModifier() []ITypeParameterModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeParameterModifierContext); ok {
			len++
		}
	}

	tst := make([]ITypeParameterModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeParameterModifierContext); ok {
			tst[i] = t.(ITypeParameterModifierContext)
			i++
		}
	}

	return tst
}

func (s *TypeParameterModifiersContext) TypeParameterModifier(i int) ITypeParameterModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterModifierContext)
}

func (s *TypeParameterModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterModifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeParameterModifiers(s)
	}
}

func (s *TypeParameterModifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeParameterModifiers(s)
	}
}

func (p *KotlinParser) TypeParameterModifiers() (localctx ITypeParameterModifiersContext) {
	localctx = NewTypeParameterModifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, KotlinParserRULE_typeParameterModifiers)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3414)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(3413)
				p.TypeParameterModifier()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(3416)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 527, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeParameterModifierContext is an interface to support dynamic dispatch.
type ITypeParameterModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReificationModifier() IReificationModifierContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode
	VarianceModifier() IVarianceModifierContext
	Annotation() IAnnotationContext

	// IsTypeParameterModifierContext differentiates from other interfaces.
	IsTypeParameterModifierContext()
}

type TypeParameterModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterModifierContext() *TypeParameterModifierContext {
	var p = new(TypeParameterModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_typeParameterModifier
	return p
}

func InitEmptyTypeParameterModifierContext(p *TypeParameterModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_typeParameterModifier
}

func (*TypeParameterModifierContext) IsTypeParameterModifierContext() {}

func NewTypeParameterModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterModifierContext {
	var p = new(TypeParameterModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_typeParameterModifier

	return p
}

func (s *TypeParameterModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterModifierContext) ReificationModifier() IReificationModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReificationModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReificationModifierContext)
}

func (s *TypeParameterModifierContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *TypeParameterModifierContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *TypeParameterModifierContext) VarianceModifier() IVarianceModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarianceModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarianceModifierContext)
}

func (s *TypeParameterModifierContext) Annotation() IAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *TypeParameterModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterTypeParameterModifier(s)
	}
}

func (s *TypeParameterModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitTypeParameterModifier(s)
	}
}

func (p *KotlinParser) TypeParameterModifier() (localctx ITypeParameterModifierContext) {
	localctx = NewTypeParameterModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, KotlinParserRULE_typeParameterModifier)
	var _alt int

	p.SetState(3433)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KotlinParserREIFIED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3418)
			p.ReificationModifier()
		}
		p.SetState(3422)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 528, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3419)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(3424)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 528, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case KotlinParserIN, KotlinParserOUT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3425)
			p.VarianceModifier()
		}
		p.SetState(3429)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 529, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3426)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(3431)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 529, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case KotlinParserAT_NO_WS, KotlinParserAT_PRE_WS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3432)
			p.Annotation()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionModifierContext is an interface to support dynamic dispatch.
type IFunctionModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TAILREC() antlr.TerminalNode
	OPERATOR() antlr.TerminalNode
	INFIX() antlr.TerminalNode
	INLINE() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	SUSPEND() antlr.TerminalNode

	// IsFunctionModifierContext differentiates from other interfaces.
	IsFunctionModifierContext()
}

type FunctionModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionModifierContext() *FunctionModifierContext {
	var p = new(FunctionModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_functionModifier
	return p
}

func InitEmptyFunctionModifierContext(p *FunctionModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_functionModifier
}

func (*FunctionModifierContext) IsFunctionModifierContext() {}

func NewFunctionModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionModifierContext {
	var p = new(FunctionModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_functionModifier

	return p
}

func (s *FunctionModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionModifierContext) TAILREC() antlr.TerminalNode {
	return s.GetToken(KotlinParserTAILREC, 0)
}

func (s *FunctionModifierContext) OPERATOR() antlr.TerminalNode {
	return s.GetToken(KotlinParserOPERATOR, 0)
}

func (s *FunctionModifierContext) INFIX() antlr.TerminalNode {
	return s.GetToken(KotlinParserINFIX, 0)
}

func (s *FunctionModifierContext) INLINE() antlr.TerminalNode {
	return s.GetToken(KotlinParserINLINE, 0)
}

func (s *FunctionModifierContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserEXTERNAL, 0)
}

func (s *FunctionModifierContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(KotlinParserSUSPEND, 0)
}

func (s *FunctionModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterFunctionModifier(s)
	}
}

func (s *FunctionModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitFunctionModifier(s)
	}
}

func (p *KotlinParser) FunctionModifier() (localctx IFunctionModifierContext) {
	localctx = NewFunctionModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, KotlinParserRULE_functionModifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3435)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-119)) & ^0x3f) == 0 && ((int64(1)<<(_la-119))&63) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyModifierContext is an interface to support dynamic dispatch.
type IPropertyModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONST() antlr.TerminalNode

	// IsPropertyModifierContext differentiates from other interfaces.
	IsPropertyModifierContext()
}

type PropertyModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyModifierContext() *PropertyModifierContext {
	var p = new(PropertyModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_propertyModifier
	return p
}

func InitEmptyPropertyModifierContext(p *PropertyModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_propertyModifier
}

func (*PropertyModifierContext) IsPropertyModifierContext() {}

func NewPropertyModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyModifierContext {
	var p = new(PropertyModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_propertyModifier

	return p
}

func (s *PropertyModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyModifierContext) CONST() antlr.TerminalNode {
	return s.GetToken(KotlinParserCONST, 0)
}

func (s *PropertyModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPropertyModifier(s)
	}
}

func (s *PropertyModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPropertyModifier(s)
	}
}

func (p *KotlinParser) PropertyModifier() (localctx IPropertyModifierContext) {
	localctx = NewPropertyModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, KotlinParserRULE_propertyModifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3437)
		p.Match(KotlinParserCONST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInheritanceModifierContext is an interface to support dynamic dispatch.
type IInheritanceModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ABSTRACT() antlr.TerminalNode
	FINAL() antlr.TerminalNode
	OPEN() antlr.TerminalNode

	// IsInheritanceModifierContext differentiates from other interfaces.
	IsInheritanceModifierContext()
}

type InheritanceModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInheritanceModifierContext() *InheritanceModifierContext {
	var p = new(InheritanceModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_inheritanceModifier
	return p
}

func InitEmptyInheritanceModifierContext(p *InheritanceModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_inheritanceModifier
}

func (*InheritanceModifierContext) IsInheritanceModifierContext() {}

func NewInheritanceModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InheritanceModifierContext {
	var p = new(InheritanceModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_inheritanceModifier

	return p
}

func (s *InheritanceModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *InheritanceModifierContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(KotlinParserABSTRACT, 0)
}

func (s *InheritanceModifierContext) FINAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserFINAL, 0)
}

func (s *InheritanceModifierContext) OPEN() antlr.TerminalNode {
	return s.GetToken(KotlinParserOPEN, 0)
}

func (s *InheritanceModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InheritanceModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InheritanceModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterInheritanceModifier(s)
	}
}

func (s *InheritanceModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitInheritanceModifier(s)
	}
}

func (p *KotlinParser) InheritanceModifier() (localctx IInheritanceModifierContext) {
	localctx = NewInheritanceModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, KotlinParserRULE_inheritanceModifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3439)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-126)) & ^0x3f) == 0 && ((int64(1)<<(_la-126))&7) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterModifierContext is an interface to support dynamic dispatch.
type IParameterModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VARARG() antlr.TerminalNode
	NOINLINE() antlr.TerminalNode
	CROSSINLINE() antlr.TerminalNode

	// IsParameterModifierContext differentiates from other interfaces.
	IsParameterModifierContext()
}

type ParameterModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterModifierContext() *ParameterModifierContext {
	var p = new(ParameterModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_parameterModifier
	return p
}

func InitEmptyParameterModifierContext(p *ParameterModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_parameterModifier
}

func (*ParameterModifierContext) IsParameterModifierContext() {}

func NewParameterModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterModifierContext {
	var p = new(ParameterModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_parameterModifier

	return p
}

func (s *ParameterModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterModifierContext) VARARG() antlr.TerminalNode {
	return s.GetToken(KotlinParserVARARG, 0)
}

func (s *ParameterModifierContext) NOINLINE() antlr.TerminalNode {
	return s.GetToken(KotlinParserNOINLINE, 0)
}

func (s *ParameterModifierContext) CROSSINLINE() antlr.TerminalNode {
	return s.GetToken(KotlinParserCROSSINLINE, 0)
}

func (s *ParameterModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterParameterModifier(s)
	}
}

func (s *ParameterModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitParameterModifier(s)
	}
}

func (p *KotlinParser) ParameterModifier() (localctx IParameterModifierContext) {
	localctx = NewParameterModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, KotlinParserRULE_parameterModifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3441)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-131)) & ^0x3f) == 0 && ((int64(1)<<(_la-131))&7) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReificationModifierContext is an interface to support dynamic dispatch.
type IReificationModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REIFIED() antlr.TerminalNode

	// IsReificationModifierContext differentiates from other interfaces.
	IsReificationModifierContext()
}

type ReificationModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReificationModifierContext() *ReificationModifierContext {
	var p = new(ReificationModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_reificationModifier
	return p
}

func InitEmptyReificationModifierContext(p *ReificationModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_reificationModifier
}

func (*ReificationModifierContext) IsReificationModifierContext() {}

func NewReificationModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReificationModifierContext {
	var p = new(ReificationModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_reificationModifier

	return p
}

func (s *ReificationModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ReificationModifierContext) REIFIED() antlr.TerminalNode {
	return s.GetToken(KotlinParserREIFIED, 0)
}

func (s *ReificationModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReificationModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReificationModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterReificationModifier(s)
	}
}

func (s *ReificationModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitReificationModifier(s)
	}
}

func (p *KotlinParser) ReificationModifier() (localctx IReificationModifierContext) {
	localctx = NewReificationModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, KotlinParserRULE_reificationModifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3443)
		p.Match(KotlinParserREIFIED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPlatformModifierContext is an interface to support dynamic dispatch.
type IPlatformModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXPECT() antlr.TerminalNode
	ACTUAL() antlr.TerminalNode

	// IsPlatformModifierContext differentiates from other interfaces.
	IsPlatformModifierContext()
}

type PlatformModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPlatformModifierContext() *PlatformModifierContext {
	var p = new(PlatformModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_platformModifier
	return p
}

func InitEmptyPlatformModifierContext(p *PlatformModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_platformModifier
}

func (*PlatformModifierContext) IsPlatformModifierContext() {}

func NewPlatformModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PlatformModifierContext {
	var p = new(PlatformModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_platformModifier

	return p
}

func (s *PlatformModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *PlatformModifierContext) EXPECT() antlr.TerminalNode {
	return s.GetToken(KotlinParserEXPECT, 0)
}

func (s *PlatformModifierContext) ACTUAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserACTUAL, 0)
}

func (s *PlatformModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PlatformModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PlatformModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterPlatformModifier(s)
	}
}

func (s *PlatformModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitPlatformModifier(s)
	}
}

func (p *KotlinParser) PlatformModifier() (localctx IPlatformModifierContext) {
	localctx = NewPlatformModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, KotlinParserRULE_platformModifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3445)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserEXPECT || _la == KotlinParserACTUAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnnotationContext is an interface to support dynamic dispatch.
type IAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleAnnotation() ISingleAnnotationContext
	MultiAnnotation() IMultiAnnotationContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsAnnotationContext differentiates from other interfaces.
	IsAnnotationContext()
}

type AnnotationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationContext() *AnnotationContext {
	var p = new(AnnotationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_annotation
	return p
}

func InitEmptyAnnotationContext(p *AnnotationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_annotation
}

func (*AnnotationContext) IsAnnotationContext() {}

func NewAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationContext {
	var p = new(AnnotationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_annotation

	return p
}

func (s *AnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationContext) SingleAnnotation() ISingleAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleAnnotationContext)
}

func (s *AnnotationContext) MultiAnnotation() IMultiAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiAnnotationContext)
}

func (s *AnnotationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *AnnotationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *AnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAnnotation(s)
	}
}

func (s *AnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAnnotation(s)
	}
}

func (p *KotlinParser) Annotation() (localctx IAnnotationContext) {
	localctx = NewAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, KotlinParserRULE_annotation)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3449)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 531, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3447)
			p.SingleAnnotation()
		}

	case 2:
		{
			p.SetState(3448)
			p.MultiAnnotation()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(3454)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 532, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3451)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3456)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 532, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleAnnotationContext is an interface to support dynamic dispatch.
type ISingleAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnescapedAnnotation() IUnescapedAnnotationContext
	AnnotationUseSiteTarget() IAnnotationUseSiteTargetContext
	AT_NO_WS() antlr.TerminalNode
	AT_PRE_WS() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsSingleAnnotationContext differentiates from other interfaces.
	IsSingleAnnotationContext()
}

type SingleAnnotationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleAnnotationContext() *SingleAnnotationContext {
	var p = new(SingleAnnotationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_singleAnnotation
	return p
}

func InitEmptySingleAnnotationContext(p *SingleAnnotationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_singleAnnotation
}

func (*SingleAnnotationContext) IsSingleAnnotationContext() {}

func NewSingleAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleAnnotationContext {
	var p = new(SingleAnnotationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_singleAnnotation

	return p
}

func (s *SingleAnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleAnnotationContext) UnescapedAnnotation() IUnescapedAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnescapedAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnescapedAnnotationContext)
}

func (s *SingleAnnotationContext) AnnotationUseSiteTarget() IAnnotationUseSiteTargetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationUseSiteTargetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationUseSiteTargetContext)
}

func (s *SingleAnnotationContext) AT_NO_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAT_NO_WS, 0)
}

func (s *SingleAnnotationContext) AT_PRE_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAT_PRE_WS, 0)
}

func (s *SingleAnnotationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *SingleAnnotationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *SingleAnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleAnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleAnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterSingleAnnotation(s)
	}
}

func (s *SingleAnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitSingleAnnotation(s)
	}
}

func (p *KotlinParser) SingleAnnotation() (localctx ISingleAnnotationContext) {
	localctx = NewSingleAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, KotlinParserRULE_singleAnnotation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3466)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 534, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3457)
			p.AnnotationUseSiteTarget()
		}
		p.SetState(3461)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3458)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(3463)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		{
			p.SetState(3464)
			p.Match(KotlinParserAT_NO_WS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(3465)
			p.Match(KotlinParserAT_PRE_WS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(3468)
		p.UnescapedAnnotation()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiAnnotationContext is an interface to support dynamic dispatch.
type IMultiAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LSQUARE() antlr.TerminalNode
	RSQUARE() antlr.TerminalNode
	AnnotationUseSiteTarget() IAnnotationUseSiteTargetContext
	AT_NO_WS() antlr.TerminalNode
	AT_PRE_WS() antlr.TerminalNode
	AllUnescapedAnnotation() []IUnescapedAnnotationContext
	UnescapedAnnotation(i int) IUnescapedAnnotationContext
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsMultiAnnotationContext differentiates from other interfaces.
	IsMultiAnnotationContext()
}

type MultiAnnotationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiAnnotationContext() *MultiAnnotationContext {
	var p = new(MultiAnnotationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_multiAnnotation
	return p
}

func InitEmptyMultiAnnotationContext(p *MultiAnnotationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_multiAnnotation
}

func (*MultiAnnotationContext) IsMultiAnnotationContext() {}

func NewMultiAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiAnnotationContext {
	var p = new(MultiAnnotationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_multiAnnotation

	return p
}

func (s *MultiAnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiAnnotationContext) LSQUARE() antlr.TerminalNode {
	return s.GetToken(KotlinParserLSQUARE, 0)
}

func (s *MultiAnnotationContext) RSQUARE() antlr.TerminalNode {
	return s.GetToken(KotlinParserRSQUARE, 0)
}

func (s *MultiAnnotationContext) AnnotationUseSiteTarget() IAnnotationUseSiteTargetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationUseSiteTargetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationUseSiteTargetContext)
}

func (s *MultiAnnotationContext) AT_NO_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAT_NO_WS, 0)
}

func (s *MultiAnnotationContext) AT_PRE_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAT_PRE_WS, 0)
}

func (s *MultiAnnotationContext) AllUnescapedAnnotation() []IUnescapedAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnescapedAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IUnescapedAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnescapedAnnotationContext); ok {
			tst[i] = t.(IUnescapedAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *MultiAnnotationContext) UnescapedAnnotation(i int) IUnescapedAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnescapedAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnescapedAnnotationContext)
}

func (s *MultiAnnotationContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *MultiAnnotationContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *MultiAnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiAnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiAnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterMultiAnnotation(s)
	}
}

func (s *MultiAnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitMultiAnnotation(s)
	}
}

func (p *KotlinParser) MultiAnnotation() (localctx IMultiAnnotationContext) {
	localctx = NewMultiAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, KotlinParserRULE_multiAnnotation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3479)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 536, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3470)
			p.AnnotationUseSiteTarget()
		}
		p.SetState(3474)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KotlinParserNL {
			{
				p.SetState(3471)
				p.Match(KotlinParserNL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(3476)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		{
			p.SetState(3477)
			p.Match(KotlinParserAT_NO_WS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(3478)
			p.Match(KotlinParserAT_PRE_WS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(3481)
		p.Match(KotlinParserLSQUARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3483)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64((_la-63)) & ^0x3f) == 0 && ((int64(1)<<(_la-63))&-17588927330817) != 0) || ((int64((_la-127)) & ^0x3f) == 0 && ((int64(1)<<(_la-127))&2098175) != 0) {
		{
			p.SetState(3482)
			p.UnescapedAnnotation()
		}

		p.SetState(3485)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3487)
		p.Match(KotlinParserRSQUARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnnotationUseSiteTargetContext is an interface to support dynamic dispatch.
type IAnnotationUseSiteTargetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLON() antlr.TerminalNode
	AT_NO_WS() antlr.TerminalNode
	AT_PRE_WS() antlr.TerminalNode
	FIELD() antlr.TerminalNode
	PROPERTY() antlr.TerminalNode
	GET() antlr.TerminalNode
	SET() antlr.TerminalNode
	RECEIVER() antlr.TerminalNode
	PARAM() antlr.TerminalNode
	SETPARAM() antlr.TerminalNode
	DELEGATE() antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsAnnotationUseSiteTargetContext differentiates from other interfaces.
	IsAnnotationUseSiteTargetContext()
}

type AnnotationUseSiteTargetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationUseSiteTargetContext() *AnnotationUseSiteTargetContext {
	var p = new(AnnotationUseSiteTargetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_annotationUseSiteTarget
	return p
}

func InitEmptyAnnotationUseSiteTargetContext(p *AnnotationUseSiteTargetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_annotationUseSiteTarget
}

func (*AnnotationUseSiteTargetContext) IsAnnotationUseSiteTargetContext() {}

func NewAnnotationUseSiteTargetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationUseSiteTargetContext {
	var p = new(AnnotationUseSiteTargetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_annotationUseSiteTarget

	return p
}

func (s *AnnotationUseSiteTargetContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationUseSiteTargetContext) COLON() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOLON, 0)
}

func (s *AnnotationUseSiteTargetContext) AT_NO_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAT_NO_WS, 0)
}

func (s *AnnotationUseSiteTargetContext) AT_PRE_WS() antlr.TerminalNode {
	return s.GetToken(KotlinParserAT_PRE_WS, 0)
}

func (s *AnnotationUseSiteTargetContext) FIELD() antlr.TerminalNode {
	return s.GetToken(KotlinParserFIELD, 0)
}

func (s *AnnotationUseSiteTargetContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(KotlinParserPROPERTY, 0)
}

func (s *AnnotationUseSiteTargetContext) GET() antlr.TerminalNode {
	return s.GetToken(KotlinParserGET, 0)
}

func (s *AnnotationUseSiteTargetContext) SET() antlr.TerminalNode {
	return s.GetToken(KotlinParserSET, 0)
}

func (s *AnnotationUseSiteTargetContext) RECEIVER() antlr.TerminalNode {
	return s.GetToken(KotlinParserRECEIVER, 0)
}

func (s *AnnotationUseSiteTargetContext) PARAM() antlr.TerminalNode {
	return s.GetToken(KotlinParserPARAM, 0)
}

func (s *AnnotationUseSiteTargetContext) SETPARAM() antlr.TerminalNode {
	return s.GetToken(KotlinParserSETPARAM, 0)
}

func (s *AnnotationUseSiteTargetContext) DELEGATE() antlr.TerminalNode {
	return s.GetToken(KotlinParserDELEGATE, 0)
}

func (s *AnnotationUseSiteTargetContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *AnnotationUseSiteTargetContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *AnnotationUseSiteTargetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationUseSiteTargetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationUseSiteTargetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterAnnotationUseSiteTarget(s)
	}
}

func (s *AnnotationUseSiteTargetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitAnnotationUseSiteTarget(s)
	}
}

func (p *KotlinParser) AnnotationUseSiteTarget() (localctx IAnnotationUseSiteTargetContext) {
	localctx = NewAnnotationUseSiteTargetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, KotlinParserRULE_annotationUseSiteTarget)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3489)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KotlinParserAT_NO_WS || _la == KotlinParserAT_PRE_WS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(3490)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&255) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3494)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KotlinParserNL {
		{
			p.SetState(3491)
			p.Match(KotlinParserNL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(3496)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3497)
		p.Match(KotlinParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnescapedAnnotationContext is an interface to support dynamic dispatch.
type IUnescapedAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ConstructorInvocation() IConstructorInvocationContext
	UserType() IUserTypeContext

	// IsUnescapedAnnotationContext differentiates from other interfaces.
	IsUnescapedAnnotationContext()
}

type UnescapedAnnotationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnescapedAnnotationContext() *UnescapedAnnotationContext {
	var p = new(UnescapedAnnotationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_unescapedAnnotation
	return p
}

func InitEmptyUnescapedAnnotationContext(p *UnescapedAnnotationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_unescapedAnnotation
}

func (*UnescapedAnnotationContext) IsUnescapedAnnotationContext() {}

func NewUnescapedAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnescapedAnnotationContext {
	var p = new(UnescapedAnnotationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_unescapedAnnotation

	return p
}

func (s *UnescapedAnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *UnescapedAnnotationContext) ConstructorInvocation() IConstructorInvocationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstructorInvocationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstructorInvocationContext)
}

func (s *UnescapedAnnotationContext) UserType() IUserTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserTypeContext)
}

func (s *UnescapedAnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnescapedAnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnescapedAnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterUnescapedAnnotation(s)
	}
}

func (s *UnescapedAnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitUnescapedAnnotation(s)
	}
}

func (p *KotlinParser) UnescapedAnnotation() (localctx IUnescapedAnnotationContext) {
	localctx = NewUnescapedAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, KotlinParserRULE_unescapedAnnotation)
	p.SetState(3501)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 539, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3499)
			p.ConstructorInvocation()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3500)
			p.UserType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleIdentifierContext is an interface to support dynamic dispatch.
type ISimpleIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	ABSTRACT() antlr.TerminalNode
	ANNOTATION() antlr.TerminalNode
	BY() antlr.TerminalNode
	CATCH() antlr.TerminalNode
	COMPANION() antlr.TerminalNode
	CONSTRUCTOR() antlr.TerminalNode
	CROSSINLINE() antlr.TerminalNode
	DATA() antlr.TerminalNode
	DYNAMIC() antlr.TerminalNode
	ENUM() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	FINAL() antlr.TerminalNode
	FINALLY() antlr.TerminalNode
	GET() antlr.TerminalNode
	IMPORT() antlr.TerminalNode
	INFIX() antlr.TerminalNode
	INIT() antlr.TerminalNode
	INLINE() antlr.TerminalNode
	INNER() antlr.TerminalNode
	INTERNAL() antlr.TerminalNode
	LATEINIT() antlr.TerminalNode
	NOINLINE() antlr.TerminalNode
	OPEN() antlr.TerminalNode
	OPERATOR() antlr.TerminalNode
	OUT() antlr.TerminalNode
	OVERRIDE() antlr.TerminalNode
	PRIVATE() antlr.TerminalNode
	PROTECTED() antlr.TerminalNode
	PUBLIC() antlr.TerminalNode
	REIFIED() antlr.TerminalNode
	SEALED() antlr.TerminalNode
	TAILREC() antlr.TerminalNode
	SET() antlr.TerminalNode
	VARARG() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	FIELD() antlr.TerminalNode
	PROPERTY() antlr.TerminalNode
	RECEIVER() antlr.TerminalNode
	PARAM() antlr.TerminalNode
	SETPARAM() antlr.TerminalNode
	DELEGATE() antlr.TerminalNode
	FILE() antlr.TerminalNode
	EXPECT() antlr.TerminalNode
	ACTUAL() antlr.TerminalNode
	CONST() antlr.TerminalNode
	SUSPEND() antlr.TerminalNode
	VALUE() antlr.TerminalNode

	// IsSimpleIdentifierContext differentiates from other interfaces.
	IsSimpleIdentifierContext()
}

type SimpleIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleIdentifierContext() *SimpleIdentifierContext {
	var p = new(SimpleIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_simpleIdentifier
	return p
}

func InitEmptySimpleIdentifierContext(p *SimpleIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_simpleIdentifier
}

func (*SimpleIdentifierContext) IsSimpleIdentifierContext() {}

func NewSimpleIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleIdentifierContext {
	var p = new(SimpleIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_simpleIdentifier

	return p
}

func (s *SimpleIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleIdentifierContext) Identifier() antlr.TerminalNode {
	return s.GetToken(KotlinParserIdentifier, 0)
}

func (s *SimpleIdentifierContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(KotlinParserABSTRACT, 0)
}

func (s *SimpleIdentifierContext) ANNOTATION() antlr.TerminalNode {
	return s.GetToken(KotlinParserANNOTATION, 0)
}

func (s *SimpleIdentifierContext) BY() antlr.TerminalNode {
	return s.GetToken(KotlinParserBY, 0)
}

func (s *SimpleIdentifierContext) CATCH() antlr.TerminalNode {
	return s.GetToken(KotlinParserCATCH, 0)
}

func (s *SimpleIdentifierContext) COMPANION() antlr.TerminalNode {
	return s.GetToken(KotlinParserCOMPANION, 0)
}

func (s *SimpleIdentifierContext) CONSTRUCTOR() antlr.TerminalNode {
	return s.GetToken(KotlinParserCONSTRUCTOR, 0)
}

func (s *SimpleIdentifierContext) CROSSINLINE() antlr.TerminalNode {
	return s.GetToken(KotlinParserCROSSINLINE, 0)
}

func (s *SimpleIdentifierContext) DATA() antlr.TerminalNode {
	return s.GetToken(KotlinParserDATA, 0)
}

func (s *SimpleIdentifierContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(KotlinParserDYNAMIC, 0)
}

func (s *SimpleIdentifierContext) ENUM() antlr.TerminalNode {
	return s.GetToken(KotlinParserENUM, 0)
}

func (s *SimpleIdentifierContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserEXTERNAL, 0)
}

func (s *SimpleIdentifierContext) FINAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserFINAL, 0)
}

func (s *SimpleIdentifierContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(KotlinParserFINALLY, 0)
}

func (s *SimpleIdentifierContext) GET() antlr.TerminalNode {
	return s.GetToken(KotlinParserGET, 0)
}

func (s *SimpleIdentifierContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(KotlinParserIMPORT, 0)
}

func (s *SimpleIdentifierContext) INFIX() antlr.TerminalNode {
	return s.GetToken(KotlinParserINFIX, 0)
}

func (s *SimpleIdentifierContext) INIT() antlr.TerminalNode {
	return s.GetToken(KotlinParserINIT, 0)
}

func (s *SimpleIdentifierContext) INLINE() antlr.TerminalNode {
	return s.GetToken(KotlinParserINLINE, 0)
}

func (s *SimpleIdentifierContext) INNER() antlr.TerminalNode {
	return s.GetToken(KotlinParserINNER, 0)
}

func (s *SimpleIdentifierContext) INTERNAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserINTERNAL, 0)
}

func (s *SimpleIdentifierContext) LATEINIT() antlr.TerminalNode {
	return s.GetToken(KotlinParserLATEINIT, 0)
}

func (s *SimpleIdentifierContext) NOINLINE() antlr.TerminalNode {
	return s.GetToken(KotlinParserNOINLINE, 0)
}

func (s *SimpleIdentifierContext) OPEN() antlr.TerminalNode {
	return s.GetToken(KotlinParserOPEN, 0)
}

func (s *SimpleIdentifierContext) OPERATOR() antlr.TerminalNode {
	return s.GetToken(KotlinParserOPERATOR, 0)
}

func (s *SimpleIdentifierContext) OUT() antlr.TerminalNode {
	return s.GetToken(KotlinParserOUT, 0)
}

func (s *SimpleIdentifierContext) OVERRIDE() antlr.TerminalNode {
	return s.GetToken(KotlinParserOVERRIDE, 0)
}

func (s *SimpleIdentifierContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(KotlinParserPRIVATE, 0)
}

func (s *SimpleIdentifierContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(KotlinParserPROTECTED, 0)
}

func (s *SimpleIdentifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(KotlinParserPUBLIC, 0)
}

func (s *SimpleIdentifierContext) REIFIED() antlr.TerminalNode {
	return s.GetToken(KotlinParserREIFIED, 0)
}

func (s *SimpleIdentifierContext) SEALED() antlr.TerminalNode {
	return s.GetToken(KotlinParserSEALED, 0)
}

func (s *SimpleIdentifierContext) TAILREC() antlr.TerminalNode {
	return s.GetToken(KotlinParserTAILREC, 0)
}

func (s *SimpleIdentifierContext) SET() antlr.TerminalNode {
	return s.GetToken(KotlinParserSET, 0)
}

func (s *SimpleIdentifierContext) VARARG() antlr.TerminalNode {
	return s.GetToken(KotlinParserVARARG, 0)
}

func (s *SimpleIdentifierContext) WHERE() antlr.TerminalNode {
	return s.GetToken(KotlinParserWHERE, 0)
}

func (s *SimpleIdentifierContext) FIELD() antlr.TerminalNode {
	return s.GetToken(KotlinParserFIELD, 0)
}

func (s *SimpleIdentifierContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(KotlinParserPROPERTY, 0)
}

func (s *SimpleIdentifierContext) RECEIVER() antlr.TerminalNode {
	return s.GetToken(KotlinParserRECEIVER, 0)
}

func (s *SimpleIdentifierContext) PARAM() antlr.TerminalNode {
	return s.GetToken(KotlinParserPARAM, 0)
}

func (s *SimpleIdentifierContext) SETPARAM() antlr.TerminalNode {
	return s.GetToken(KotlinParserSETPARAM, 0)
}

func (s *SimpleIdentifierContext) DELEGATE() antlr.TerminalNode {
	return s.GetToken(KotlinParserDELEGATE, 0)
}

func (s *SimpleIdentifierContext) FILE() antlr.TerminalNode {
	return s.GetToken(KotlinParserFILE, 0)
}

func (s *SimpleIdentifierContext) EXPECT() antlr.TerminalNode {
	return s.GetToken(KotlinParserEXPECT, 0)
}

func (s *SimpleIdentifierContext) ACTUAL() antlr.TerminalNode {
	return s.GetToken(KotlinParserACTUAL, 0)
}

func (s *SimpleIdentifierContext) CONST() antlr.TerminalNode {
	return s.GetToken(KotlinParserCONST, 0)
}

func (s *SimpleIdentifierContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(KotlinParserSUSPEND, 0)
}

func (s *SimpleIdentifierContext) VALUE() antlr.TerminalNode {
	return s.GetToken(KotlinParserVALUE, 0)
}

func (s *SimpleIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterSimpleIdentifier(s)
	}
}

func (s *SimpleIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitSimpleIdentifier(s)
	}
}

func (p *KotlinParser) SimpleIdentifier() (localctx ISimpleIdentifierContext) {
	localctx = NewSimpleIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, KotlinParserRULE_simpleIdentifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3503)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-63)) & ^0x3f) == 0 && ((int64(1)<<(_la-63))&-17588927330817) != 0) || ((int64((_la-127)) & ^0x3f) == 0 && ((int64(1)<<(_la-127))&2098175) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSimpleIdentifier() []ISimpleIdentifierContext
	SimpleIdentifier(i int) ISimpleIdentifierContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	AllNL() []antlr.TerminalNode
	NL(i int) antlr.TerminalNode

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KotlinParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KotlinParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) AllSimpleIdentifier() []ISimpleIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			len++
		}
	}

	tst := make([]ISimpleIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimpleIdentifierContext); ok {
			tst[i] = t.(ISimpleIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierContext) SimpleIdentifier(i int) ISimpleIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *IdentifierContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserDOT)
}

func (s *IdentifierContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserDOT, i)
}

func (s *IdentifierContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(KotlinParserNL)
}

func (s *IdentifierContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(KotlinParserNL, i)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KotlinParserListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (p *KotlinParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, KotlinParserRULE_identifier)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3505)
		p.SimpleIdentifier()
	}
	p.SetState(3516)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 541, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(3509)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == KotlinParserNL {
				{
					p.SetState(3506)
					p.Match(KotlinParserNL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(3511)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(3512)
				p.Match(KotlinParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3513)
				p.SimpleIdentifier()
			}

		}
		p.SetState(3518)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 541, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}
